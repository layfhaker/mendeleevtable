
============================================================
ФАЙЛ: .\build-icons.js
============================================================

const fs = require('fs');
const path = require('path');

// Директории
const iconsDir = path.join(__dirname, 'icons');
const outputFile = path.join(__dirname, 'js', 'icons.js');

// Список всех иконок
const iconFiles = [
    'icon-calc',
    'icon-sun',
    'icon-moon',
    'icon-particles',
    'icon-menu',
    'icon-close',
    'icon-filter',
    'icon-search',
    'icon-palette',
    'icon-bolt',
    'icon-info'
];

// Начало спрайта
let spriteContent = `// SVG Спрайт иконок (автоматически сгенерирован из icons/*.svg)\nconst iconsSVG = \`\n<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">\n`;

// Читаем каждый SVG файл и конвертируем в symbol
iconFiles.forEach(iconName => {
    const filePath = path.join(iconsDir, `${iconName}.svg`);

    if (!fs.existsSync(filePath)) {
        console.error(`Файл ${iconName}.svg не найден!`);
        return;
    }

    const svgContent = fs.readFileSync(filePath, 'utf8');

    // Извлекаем содержимое между тегами <svg> и </svg>
    const svgMatch = svgContent.match(/<svg[^>]*>([\s\S]*)<\/svg>/);
    if (!svgMatch) {
        console.error(`Неверный формат SVG в ${iconName}.svg`);
        return;
    }

    // Извлекаем атрибуты из тега <svg>
    const svgTagMatch = svgContent.match(/<svg([^>]*)>/);
    const svgAttributes = svgTagMatch ? svgTagMatch[1] : '';

    // Извлекаем нужные атрибуты
    const viewBox = (svgAttributes.match(/viewBox="([^"]*)"/) || [])[1] || '0 0 24 24';
    const fill = (svgAttributes.match(/fill="([^"]*)"/) || [])[1];
    const stroke = (svgAttributes.match(/stroke="([^"]*)"/) || [])[1];
    const strokeWidth = (svgAttributes.match(/stroke-width="([^"]*)"/) || [])[1];
    const strokeLinecap = (svgAttributes.match(/stroke-linecap="([^"]*)"/) || [])[1];
    const strokeLinejoin = (svgAttributes.match(/stroke-linejoin="([^"]*)"/) || [])[1];

    // Формируем symbol
    let symbolTag = `    <symbol id="${iconName}" viewBox="${viewBox}"`;
    if (fill) symbolTag += ` fill="${fill}"`;
    if (stroke) symbolTag += ` stroke="${stroke}"`;
    if (strokeWidth) symbolTag += ` stroke-width="${strokeWidth}"`;
    if (strokeLinecap) symbolTag += ` stroke-linecap="${strokeLinecap}"`;
    if (strokeLinejoin) symbolTag += ` stroke-linejoin="${strokeLinejoin}"`;
    symbolTag += `>\n`;

    // Добавляем содержимое SVG
    const innerContent = svgMatch[1].trim().split('\n').map(line => `        ${line}`).join('\n');
    symbolTag += innerContent + '\n';
    symbolTag += `    </symbol>\n`;

    spriteContent += symbolTag;
    spriteContent += '\n';

    console.log(`✓ Обработан ${iconName}.svg`);
});

// Завершаем спрайт
spriteContent += `</svg>\n\`;\n\n`;
spriteContent += `// Вставляем в начало body\n`;
spriteContent += `document.body.insertAdjacentHTML('afterbegin', iconsSVG);\n`;

// Записываем результат
fs.writeFileSync(outputFile, spriteContent, 'utf8');
console.log(`\n✓ Спрайт успешно сгенерирован: ${outputFile}`);


============================================================
ФАЙЛ: .\codebreakdown.py
============================================================


#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
from pathlib import Path
from datetime import datetime

# ================= CONFIG =================

EXT_TO_CATEGORY = {
    ".html": "HTML", ".htm": "HTML",
    ".css": "CSS", ".scss": "CSS", ".sass": "CSS", ".less": "CSS",
    ".js": "JavaScript", ".mjs": "JavaScript", ".cjs": "JavaScript",
    ".ts": "TypeScript", ".tsx": "TypeScript", ".jsx": "JavaScript",
    ".py": "Python", ".pyi": "Python",
    ".tex": "LaTeX", ".sty": "LaTeX", ".cls": "LaTeX", ".bib": "LaTeX",
    ".md": "Markdown",
    ".json": "Data", ".yaml": "Data", ".yml": "Data", ".csv": "Data",
    ".toml": "Config", ".ini": "Config", ".cfg": "Config",
}

EXCLUDE_DIRS = {
    ".git", "node_modules", "dist", "build",
    ".venv", "venv", "__pycache__",
    ".idea", ".vscode"
}

OUTPUT_MD_NAME = "code_breakdown.md"

# ==========================================

def detect_category(path: Path) -> str:
    return EXT_TO_CATEGORY.get(path.suffix.lower(), "Other")

def count_nonempty_lines(text: str) -> int:
    return sum(1 for line in text.splitlines() if line.strip())

def iter_files(root: Path):
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]
        for fname in filenames:
            yield Path(dirpath) / fname

def main():
    # Folder where THIS script is located
    script_dir = Path(__file__).resolve().parent

    stats = {}

    for file in iter_files(script_dir):
        if file == Path(__file__):
            continue

        try:
            text = file.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            continue

        lines = count_nonempty_lines(text)
        if lines == 0:
            continue

        category = detect_category(file)
        stats[category] = stats.get(category, 0) + lines

    total = sum(stats.values()) or 1
    rows = sorted(stats.items(), key=lambda x: x[1], reverse=True)

    output_path = script_dir / OUTPUT_MD_NAME

    with output_path.open("w", encoding="utf-8") as md:
        md.write("# Code breakdown report\n\n")
        md.write(f"**Project folder:** `{script_dir}`  \n")
        md.write(f"**Generated:** {datetime.now().isoformat(timespec='seconds')}\n\n")
        md.write("| Category | Lines | Percent |\n")
        md.write("|---------|-------|---------|\n")

        for category, lines in rows:
            percent = lines / total * 100
            md.write(f"| {category} | {lines} | {percent:.2f}% |\n")

        md.write(f"\n**Total lines:** {total}\n")

    # Windows-friendly: show message in console if launched from terminal
    print(f"Markdown report created: {output_path}")

if __name__ == "__main__":
    main()


============================================================
ФАЙЛ: .\codeextractor.py
============================================================

import os
import sys


def is_ignored_path(relative_path, ignored_exact_paths, ignored_prefixes):
    if relative_path in ignored_exact_paths:
        return True
    return any(
        relative_path == prefix or relative_path.startswith(prefix + os.sep)
        for prefix in ignored_prefixes
    )


def combine_code(root_dir, output_file, extensions=None):
    if extensions is None:
        extensions = ['.py', '.js', '.ts', '.html', '.css', '.json', '.md']

    ignored_dir_names = {'node_modules', '__pycache__', 'venv'}
    ignored_relative_prefixes = {
        os.path.normpath(os.path.join('electron-app', 'dist')),
        os.path.normpath(os.path.join('electron-app', 'release')),
        os.path.normpath(os.path.join('electron-app', 'out')),
    }
    ignored_relative_paths = {
        os.path.normpath(os.path.join('electron-app', 'package-lock.json')),
        os.path.normpath(os.path.join('data', 'reactions-db.json')),
        os.path.normpath(os.path.join('js', 'reactions-db.js')),
        os.path.normpath(os.path.join('data', 'bad-apple-payload.js')),
        os.path.normpath(os.path.join('data', 'bad-apple-payload-solubility.js')),
        os.path.normpath('audit_reactions_report.json'),
    }

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            root_relative = os.path.normpath(os.path.relpath(root, root_dir))
            if root_relative == '.':
                root_relative = ''

            filtered_dirs = []
            for d in dirs:
                if d.startswith('.') or d in ignored_dir_names:
                    continue
                dir_relative_path = os.path.normpath(os.path.join(root_relative, d))
                if is_ignored_path(dir_relative_path, ignored_relative_paths, ignored_relative_prefixes):
                    continue
                filtered_dirs.append(d)
            dirs[:] = filtered_dirs

            for file in files:
                if not any(file.endswith(ext) for ext in extensions):
                    continue

                filepath = os.path.join(root, file)
                relative_path = os.path.normpath(os.path.join(root_relative, file))
                if is_ignored_path(relative_path, ignored_relative_paths, ignored_relative_prefixes):
                    continue

                try:
                    with open(filepath, 'r', encoding='utf-8') as infile:
                        outfile.write(f"\n{'=' * 60}\n")
                        outfile.write(f"ФАЙЛ: {filepath}\n")
                        outfile.write(f"{'=' * 60}\n\n")
                        outfile.write(infile.read())
                        outfile.write("\n")
                except Exception:
                    continue


if __name__ == "__main__":
    combine_code(".", "all_code.txt")


============================================================
ФАЙЛ: .\etalon_mass_audit_report.json
============================================================

{
  "generated_at": "2026-02-08T12:13:00.028Z",
  "etalon_direct": {
    "total": 195,
    "passed": 195,
    "failed": 0,
    "pass_rate": 1
  },
  "etalon_swap": {
    "total": 161,
    "passed": 161,
    "failed": 0,
    "pass_rate": 1
  },
  "top_fail_rules": [],
  "failure_samples": [],
  "all_results_count": 356
}

============================================================
ФАЙЛ: .\huge_inorganic_audit_report.json
============================================================

{
  "meta": {
    "generated_at": "2026-02-08T12:06:16.500Z",
    "scope": "full_inorganic_audit"
  },
  "examples": {
    "total": 195,
    "hit": 195,
    "balanced": 195,
    "marker_ok": 195,
    "issues": []
  },
  "swap": {
    "total": 161,
    "hit": 161,
    "balanced": 161,
    "marker_ok": 161,
    "issues": []
  },
  "fuzz_pairs": {
    "total_pairs": 1711,
    "reactions_found": 688,
    "balanced": 688,
    "marker_ok": 688,
    "bad_samples": []
  },
  "fuzz_triples": {
    "total_triples": 32509,
    "reactions_found": 893,
    "balanced": 893,
    "marker_ok": 893,
    "bad_samples": []
  },
  "singles_conditions": {
    "total": 295,
    "reactions_found": 60,
    "balanced": 60,
    "marker_ok": 60,
    "bad_samples": []
  }
}

============================================================
ФАЙЛ: .\index.html
============================================================

﻿<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Интерактивная Таблица Менделеева</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- ЛОАДЕР — должен быть первым для мгновенного отображения -->
    <link rel="stylesheet" href="css/loader.css">

    <!-- Favicon -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'><stop offset='0%25' style='stop-color:%232196F3'/><stop offset='100%25' style='stop-color:%231976D2'/></linearGradient></defs><circle cx='50' cy='50' r='48' fill='url(%23g)'/><ellipse cx='50' cy='50' rx='35' ry='12' fill='none' stroke='rgba(255,255,255,0.4)' stroke-width='2'/><ellipse cx='50' cy='50' rx='35' ry='12' fill='none' stroke='rgba(255,255,255,0.4)' stroke-width='2' transform='rotate(60 50 50)'/><ellipse cx='50' cy='50' rx='35' ry='12' fill='none' stroke='rgba(255,255,255,0.4)' stroke-width='2' transform='rotate(120 50 50)'/><circle cx='50' cy='50' r='6' fill='%23FF4081'/><circle cx='85' cy='50' r='4' fill='%2300E5FF'/><circle cx='15' cy='50' r='4' fill='%2300E5FF'/><circle cx='50' cy='62' r='4' fill='%2300E5FF'/><circle cx='50' cy='38' r='4' fill='%2300E5FF'/></svg>">
    <link rel="apple-touch-icon" href="img/icon-192.png">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2196F3">

    <!-- Критичный CSS для калькулятора — должен быть загружен ДО взаимодействия -->

    <!-- Полные стили загружаем сразу для корректного отображения в Chrome -->
    <link rel="stylesheet" href="css/style.css?v=6">
    <link rel="stylesheet" href="css/reactions.css?v=1">
    <link rel="stylesheet" href="css/radioactive.css">

    <!-- FLIP-анимации для модалок -->



    <!-- Fallback для Chrome: логика перенесена в js/scrypt.js -->
</head>

<body>
    <!-- ЛОАДЕР — загружается первым -->
    <script src="js/loader.js"></script>
    <script src="js/modules/radioactive.js"></script>

    <!-- Синхронная загрузка SVG иконок для Safari iOS -->

    <canvas id="particles-canvas"></canvas>
    <div id="theme-toggle" class="chem-toggle" role="switch" aria-checked="false" aria-label="Переключить тему"
        tabindex="0" title="Сменить тему">
        <div class="chem-toggle-track">
            <div class="chem-toggle-scene chem-toggle-scene-periodic" aria-hidden="true">
                <div class="chem-toggle-scene-content">
                    <div class="chem-toggle-periodic-bg">
                        <div class="chem-toggle-energy-wave ct-wave-1"></div>
                        <div class="chem-toggle-energy-wave ct-wave-2"></div>
                        <div class="chem-toggle-energy-wave ct-wave-3"></div>
                    </div>

                    <div class="chem-toggle-grid">
                        <div class="chem-toggle-element">
                            <div class="chem-toggle-element-number">1</div>
                            <div class="chem-toggle-element-symbol">H</div>
                            <div class="chem-toggle-element-glow"></div>
                        </div>
                        <div class="chem-toggle-element">
                            <div class="chem-toggle-element-number">8</div>
                            <div class="chem-toggle-element-symbol">O</div>
                            <div class="chem-toggle-element-glow"></div>
                        </div>
                        <div class="chem-toggle-element">
                            <div class="chem-toggle-element-number">26</div>
                            <div class="chem-toggle-element-symbol">Fe</div>
                            <div class="chem-toggle-element-glow"></div>
                        </div>
                        <div class="chem-toggle-element">
                            <div class="chem-toggle-element-number">79</div>
                            <div class="chem-toggle-element-symbol">Au</div>
                            <div class="chem-toggle-element-glow"></div>
                        </div>
                    </div>

                    <div class="chem-toggle-shell-info">
                        <div class="chem-toggle-shell-label ct-label-1">K</div>
                        <div class="chem-toggle-shell-label ct-label-2">L</div>
                        <div class="chem-toggle-shell-label ct-label-3">M</div>
                    </div>

                    <div class="chem-toggle-atomic-particles">
                        <div class="chem-toggle-particle ct-ap1"></div>
                        <div class="chem-toggle-particle ct-ap2"></div>
                        <div class="chem-toggle-particle ct-ap3"></div>
                        <div class="chem-toggle-particle ct-ap4"></div>
                    </div>
                </div>
            </div>

            <div class="chem-toggle-thumb chem-toggle-thumb-atom" aria-hidden="true">
                <div class="chem-toggle-atom">
                    <div class="chem-toggle-nucleus">
                        <div class="chem-toggle-proton ct-p1"></div>
                        <div class="chem-toggle-proton ct-p2"></div>
                        <div class="chem-toggle-neutron ct-n1"></div>
                        <div class="chem-toggle-neutron ct-n2"></div>
                        <div class="chem-toggle-nucleus-glow"></div>
                    </div>
                    <div class="chem-toggle-orbit ct-orbit-1">
                        <div class="chem-toggle-electron ct-e1">
                            <div class="chem-toggle-electron-trail"></div>
                        </div>
                    </div>
                    <div class="chem-toggle-orbit ct-orbit-2">
                        <div class="chem-toggle-electron ct-e2">
                            <div class="chem-toggle-electron-trail"></div>
                        </div>
                        <div class="chem-toggle-electron ct-e3">
                            <div class="chem-toggle-electron-trail"></div>
                        </div>
                    </div>
                    <div class="chem-toggle-orbit ct-orbit-3">
                        <div class="chem-toggle-electron ct-e4">
                            <div class="chem-toggle-electron-trail"></div>
                        </div>
                        <div class="chem-toggle-electron ct-e5">
                            <div class="chem-toggle-electron-trail"></div>
                        </div>
                    </div>
                    <div class="chem-toggle-quantum-field"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="periodic-table-container">
        <div class="table-wrapper">
            <div class="container">
                <!-- Все элементы основной таблицы -->
                <div id="H" class="element nonmetal" data-symbol="H">
                    <span class="atomic-number">1</span>
                    <span class="symbol">H</span>
                    <span class="name">Водород</span>
                </div>
                <div id="He" class="element noble-gas" data-symbol="He">
                    <span class="atomic-number">2</span>
                    <span class="symbol">He</span>
                    <span class="name">Гелий</span>
                </div>
                <div id="Li" class="element alkali-metal" data-symbol="Li">
                    <span class="atomic-number">3</span>
                    <span class="symbol">Li</span>
                    <span class="name">Литий</span>
                </div>
                <div id="Be" class="element alkaline-earth-metal" data-symbol="Be">
                    <span class="atomic-number">4</span>
                    <span class="symbol">Be</span>
                    <span class="name">Бериллий</span>
                </div>
                <div id="B" class="element metalloid" data-symbol="B">
                    <span class="atomic-number">5</span>
                    <span class="symbol">B</span>
                    <span class="name">Бор</span>
                </div>
                <div id="C" class="element nonmetal" data-symbol="C">
                    <span class="atomic-number">6</span>
                    <span class="symbol">C</span>
                    <span class="name">Углерод</span>
                </div>
                <div id="N" class="element nonmetal" data-symbol="N">
                    <span class="atomic-number">7</span>
                    <span class="symbol">N</span>
                    <span class="name">Азот</span>
                </div>
                <div id="O" class="element nonmetal" data-symbol="O">
                    <span class="atomic-number">8</span>
                    <span class="symbol">O</span>
                    <span class="name">Кислород</span>
                </div>
                <div id="F" class="element halogen" data-symbol="F">
                    <span class="atomic-number">9</span>
                    <span class="symbol">F</span>
                    <span class="name">Фтор</span>
                </div>
                <div id="Ne" class="element noble-gas" data-symbol="Ne">
                    <span class="atomic-number">10</span>
                    <span class="symbol">Ne</span>
                    <span class="name">Неон</span>
                </div>
                <div id="Na" class="element alkali-metal" data-symbol="Na">
                    <span class="atomic-number">11</span>
                    <span class="symbol">Na</span>
                    <span class="name">Натрий</span>
                </div>
                <div id="Mg" class="element alkaline-earth-metal" data-symbol="Mg">
                    <span class="atomic-number">12</span>
                    <span class="symbol">Mg</span>
                    <span class="name">Магний</span>
                </div>
                <div id="Al" class="element post-transition-metal" data-symbol="Al">
                    <span class="atomic-number">13</span>
                    <span class="symbol">Al</span>
                    <span class="name">Алюминий</span>
                </div>
                <div id="Si" class="element metalloid" data-symbol="Si">
                    <span class="atomic-number">14</span>
                    <span class="symbol">Si</span>
                    <span class="name">Кремний</span>
                </div>
                <div id="P" class="element nonmetal" data-symbol="P">
                    <span class="atomic-number">15</span>
                    <span class="symbol">P</span>
                    <span class="name">Фосфор</span>
                </div>
                <div id="S" class="element nonmetal" data-symbol="S">
                    <span class="atomic-number">16</span>
                    <span class="symbol">S</span>
                    <span class="name">Сера</span>
                </div>
                <div id="Cl" class="element halogen" data-symbol="Cl">
                    <span class="atomic-number">17</span>
                    <span class="symbol">Cl</span>
                    <span class="name">Хлор</span>
                </div>
                <div id="Ar" class="element noble-gas" data-symbol="Ar">
                    <span class="atomic-number">18</span>
                    <span class="symbol">Ar</span>
                    <span class="name">Аргон</span>
                </div>
                <div id="K" class="element alkali-metal" data-symbol="K">
                    <span class="atomic-number">19</span>
                    <span class="symbol">K</span>
                    <span class="name">Калий</span>
                </div>
                <div id="Ca" class="element alkaline-earth-metal" data-symbol="Ca">
                    <span class="atomic-number">20</span>
                    <span class="symbol">Ca</span>
                    <span class="name">Кальций</span>
                </div>
                <div id="Sc" class="element transition-metal" data-symbol="Sc">
                    <span class="atomic-number">21</span>
                    <span class="symbol">Sc</span>
                    <span class="name">Скандий</span>
                </div>
                <div id="Ti" class="element transition-metal" data-symbol="Ti">
                    <span class="atomic-number">22</span>
                    <span class="symbol">Ti</span>
                    <span class="name">Титан</span>
                </div>
                <div id="V" class="element transition-metal" data-symbol="V">
                    <span class="atomic-number">23</span>
                    <span class="symbol">V</span>
                    <span class="name">Ванадий</span>
                </div>
                <div id="Cr" class="element transition-metal" data-symbol="Cr">
                    <span class="atomic-number">24</span>
                    <span class="symbol">Cr</span>
                    <span class="name">Хром</span>
                </div>
                <div id="Mn" class="element transition-metal" data-symbol="Mn">
                    <span class="atomic-number">25</span>
                    <span class="symbol">Mn</span>
                    <span class="name">Марганец</span>
                </div>
                <div id="Fe" class="element transition-metal" data-symbol="Fe">
                    <span class="atomic-number">26</span>
                    <span class="symbol">Fe</span>
                    <span class="name">Железо</span>
                </div>
                <div id="Co" class="element transition-metal" data-symbol="Co">
                    <span class="atomic-number">27</span>
                    <span class="symbol">Co</span>
                    <span class="name">Кобальт</span>
                </div>
                <div id="Ni" class="element transition-metal" data-symbol="Ni">
                    <span class="atomic-number">28</span>
                    <span class="symbol">Ni</span>
                    <span class="name">Никель</span>
                </div>
                <div id="Cu" class="element transition-metal" data-symbol="Cu">
                    <span class="atomic-number">29</span>
                    <span class="symbol">Cu</span>
                    <span class="name">Медь</span>
                </div>
                <div id="Zn" class="element transition-metal" data-symbol="Zn">
                    <span class="atomic-number">30</span>
                    <span class="symbol">Zn</span>
                    <span class="name">Цинк</span>
                </div>
                <div id="Ga" class="element post-transition-metal" data-symbol="Ga">
                    <span class="atomic-number">31</span>
                    <span class="symbol">Ga</span>
                    <span class="name">Галлий</span>
                </div>
                <div id="Ge" class="element metalloid" data-symbol="Ge">
                    <span class="atomic-number">32</span>
                    <span class="symbol">Ge</span>
                    <span class="name">Германий</span>
                </div>
                <div id="As" class="element metalloid" data-symbol="As">
                    <span class="atomic-number">33</span>
                    <span class="symbol">As</span>
                    <span class="name">Мышьяк</span>
                </div>
                <div id="Se" class="element nonmetal" data-symbol="Se">
                    <span class="atomic-number">34</span>
                    <span class="symbol">Se</span>
                    <span class="name">Селен</span>
                </div>
                <div id="Br" class="element halogen" data-symbol="Br">
                    <span class="atomic-number">35</span>
                    <span class="symbol">Br</span>
                    <span class="name">Бром</span>
                </div>
                <div id="Kr" class="element noble-gas" data-symbol="Kr">
                    <span class="atomic-number">36</span>
                    <span class="symbol">Kr</span>
                    <span class="name">Криптон</span>
                </div>
                <div id="Rb" class="element alkali-metal" data-symbol="Rb">
                    <span class="atomic-number">37</span>
                    <span class="symbol">Rb</span>
                    <span class="name">Рубидий</span>
                </div>
                <div id="Sr" class="element alkaline-earth-metal" data-symbol="Sr">
                    <span class="atomic-number">38</span>
                    <span class="symbol">Sr</span>
                    <span class="name">Стронций</span>
                </div>
                <div id="Y" class="element transition-metal" data-symbol="Y">
                    <span class="atomic-number">39</span>
                    <span class="symbol">Y</span>
                    <span class="name">Иттрий</span>
                </div>
                <div id="Zr" class="element transition-metal" data-symbol="Zr">
                    <span class="atomic-number">40</span>
                    <span class="symbol">Zr</span>
                    <span class="name">Цирконий</span>
                </div>
                <div id="Nb" class="element transition-metal" data-symbol="Nb">
                    <span class="atomic-number">41</span>
                    <span class="symbol">Nb</span>
                    <span class="name">Ниобий</span>
                </div>
                <div id="Mo" class="element transition-metal" data-symbol="Mo">
                    <span class="atomic-number">42</span>
                    <span class="symbol">Mo</span>
                    <span class="name">Молибден</span>
                </div>
                <div id="Tc" class="element transition-metal" data-symbol="Tc">
                    <span class="atomic-number">43</span>
                    <span class="symbol">Tc</span>
                    <span class="name">Технеций</span>
                </div>
                <div id="Ru" class="element transition-metal" data-symbol="Ru">
                    <span class="atomic-number">44</span>
                    <span class="symbol">Ru</span>
                    <span class="name">Рутений</span>
                </div>
                <div id="Rh" class="element transition-metal" data-symbol="Rh">
                    <span class="atomic-number">45</span>
                    <span class="symbol">Rh</span>
                    <span class="name">Родий</span>
                </div>
                <div id="Pd" class="element transition-metal" data-symbol="Pd">
                    <span class="atomic-number">46</span>
                    <span class="symbol">Pd</span>
                    <span class="name">Палладий</span>
                </div>
                <div id="Ag" class="element transition-metal" data-symbol="Ag">
                    <span class="atomic-number">47</span>
                    <span class="symbol">Ag</span>
                    <span class="name">Серебро</span>
                </div>
                <div id="Cd" class="element transition-metal" data-symbol="Cd">
                    <span class="atomic-number">48</span>
                    <span class="symbol">Cd</span>
                    <span class="name">Кадмий</span>
                </div>
                <div id="In" class="element post-transition-metal" data-symbol="In">
                    <span class="atomic-number">49</span>
                    <span class="symbol">In</span>
                    <span class="name">Индий</span>
                </div>
                <div id="Sn" class="element post-transition-metal" data-symbol="Sn">
                    <span class="atomic-number">50</span>
                    <span class="symbol">Sn</span>
                    <span class="name">Олово</span>
                </div>
                <div id="Sb" class="element metalloid" data-symbol="Sb">
                    <span class="atomic-number">51</span>
                    <span class="symbol">Sb</span>
                    <span class="name">Сурьма</span>
                </div>
                <div id="Te" class="element metalloid" data-symbol="Te">
                    <span class="atomic-number">52</span>
                    <span class="symbol">Te</span>
                    <span class="name">Теллур</span>
                </div>
                <div id="I" class="element halogen" data-symbol="I">
                    <span class="atomic-number">53</span>
                    <span class="symbol">I</span>
                    <span class="name">Иод</span>
                </div>
                <div id="Xe" class="element noble-gas" data-symbol="Xe">
                    <span class="atomic-number">54</span>
                    <span class="symbol">Xe</span>
                    <span class="name">Ксенон</span>
                </div>
                <div id="Cs" class="element alkali-metal" data-symbol="Cs">
                    <span class="atomic-number">55</span>
                    <span class="symbol">Cs</span>
                    <span class="name">Цезий</span>
                </div>
                <div id="Ba" class="element alkaline-earth-metal" data-symbol="Ba">
                    <span class="atomic-number">56</span>
                    <span class="symbol">Ba</span>
                    <span class="name">Барий</span>
                </div>
                <div id="La" class="element lanthanide" data-symbol="La">
                    <span class="atomic-number">57</span>
                    <span class="symbol">La</span>
                    <span class="name">Лантан</span>
                </div>
                <div id="Hf" class="element transition-metal" data-symbol="Hf">
                    <span class="atomic-number">72</span>
                    <span class="symbol">Hf</span>
                    <span class="name">Гафний</span>
                </div>
                <div id="Ta" class="element transition-metal" data-symbol="Ta">
                    <span class="atomic-number">73</span>
                    <span class="symbol">Ta</span>
                    <span class="name">Тантал</span>
                </div>
                <div id="W" class="element transition-metal" data-symbol="W">
                    <span class="atomic-number">74</span>
                    <span class="symbol">W</span>
                    <span class="name">Вольфрам</span>
                </div>
                <div id="Re" class="element transition-metal" data-symbol="Re">
                    <span class="atomic-number">75</span>
                    <span class="symbol">Re</span>
                    <span class="name">Рений</span>
                </div>
                <div id="Os" class="element transition-metal" data-symbol="Os">
                    <span class="atomic-number">76</span>
                    <span class="symbol">Os</span>
                    <span class="name">Осмий</span>
                </div>
                <div id="Ir" class="element transition-metal" data-symbol="Ir">
                    <span class="atomic-number">77</span>
                    <span class="symbol">Ir</span>
                    <span class="name">Иридий</span>
                </div>
                <div id="Pt" class="element transition-metal" data-symbol="Pt">
                    <span class="atomic-number">78</span>
                    <span class="symbol">Pt</span>
                    <span class="name">Платина</span>
                </div>
                <div id="Au" class="element transition-metal" data-symbol="Au">
                    <span class="atomic-number">79</span>
                    <span class="symbol">Au</span>
                    <span class="name">Золото</span>
                </div>
                <div id="Hg" class="element transition-metal" data-symbol="Hg">
                    <span class="atomic-number">80</span>
                    <span class="symbol">Hg</span>
                    <span class="name">Ртуть</span>
                </div>
                <div id="Tl" class="element post-transition-metal" data-symbol="Tl">
                    <span class="atomic-number">81</span>
                    <span class="symbol">Tl</span>
                    <span class="name">Таллий</span>
                </div>
                <div id="Pb" class="element post-transition-metal" data-symbol="Pb">
                    <span class="atomic-number">82</span>
                    <span class="symbol">Pb</span>
                    <span class="name">Свинец</span>
                </div>
                <div id="Bi" class="element post-transition-metal" data-symbol="Bi">
                    <span class="atomic-number">83</span>
                    <span class="symbol">Bi</span>
                    <span class="name">Висмут</span>
                </div>
                <div id="Po" class="element post-transition-metal" data-symbol="Po">
                    <span class="atomic-number">84</span>
                    <span class="symbol">Po</span>
                    <span class="name">Полоний</span>
                </div>
                <div id="At" class="element halogen" data-symbol="At">
                    <span class="atomic-number">85</span>
                    <span class="symbol">At</span>
                    <span class="name">Астат</span>
                </div>
                <div id="Rn" class="element noble-gas" data-symbol="Rn">
                    <span class="atomic-number">86</span>
                    <span class="symbol">Rn</span>
                    <span class="name">Радон</span>
                </div>
                <div id="Fr" class="element alkali-metal" data-symbol="Fr">
                    <span class="atomic-number">87</span>
                    <span class="symbol">Fr</span>
                    <span class="name">Франций</span>
                </div>
                <div id="Ra" class="element alkaline-earth-metal" data-symbol="Ra">
                    <span class="atomic-number">88</span>
                    <span class="symbol">Ra</span>
                    <span class="name">Радий</span>
                </div>
                <div id="Ac" class="element actinide" data-symbol="Ac">
                    <span class="atomic-number">89</span>
                    <span class="symbol">Ac</span>
                    <span class="name">Актиний</span>
                </div>
                <div id="Rf" class="element transition-metal" data-symbol="Rf">
                    <span class="atomic-number">104</span>
                    <span class="symbol">Rf</span>
                    <span class="name">Резерфордий</span>
                </div>
                <div id="Db" class="element transition-metal" data-symbol="Db">
                    <span class="atomic-number">105</span>
                    <span class="symbol">Db</span>
                    <span class="name">Дубний</span>
                </div>
                <div id="Sg" class="element transition-metal" data-symbol="Sg">
                    <span class="atomic-number">106</span>
                    <span class="symbol">Sg</span>
                    <span class="name">Сиборгий</span>
                </div>
                <div id="Bh" class="element transition-metal" data-symbol="Bh">
                    <span class="atomic-number">107</span>
                    <span class="symbol">Bh</span>
                    <span class="name">Борий</span>
                </div>
                <div id="Hs" class="element transition-metal" data-symbol="Hs">
                    <span class="atomic-number">108</span>
                    <span class="symbol">Hs</span>
                    <span class="name">Хассий</span>
                </div>
                <div id="Mt" class="element unknown" data-symbol="Mt">
                    <span class="atomic-number">109</span>
                    <span class="symbol">Mt</span>
                    <span class="name">Мейтнерий</span>
                </div>
                <div id="Ds" class="element unknown" data-symbol="Ds">
                    <span class="atomic-number">110</span>
                    <span class="symbol">Ds</span>
                    <span class="name">Дармштадтий</span>
                </div>
                <div id="Rg" class="element unknown" data-symbol="Rg">
                    <span class="atomic-number">111</span>
                    <span class="symbol">Rg</span>
                    <span class="name">Рентгений</span>
                </div>
                <div id="Cn" class="element unknown" data-symbol="Cn">
                    <span class="atomic-number">112</span>
                    <span class="symbol">Cn</span>
                    <span class="name">Коперниций</span>
                </div>
                <div id="Nh" class="element unknown" data-symbol="Nh">
                    <span class="atomic-number">113</span>
                    <span class="symbol">Nh</span>
                    <span class="name">Нихоний</span>
                </div>
                <div id="Fl" class="element unknown" data-symbol="Fl">
                    <span class="atomic-number">114</span>
                    <span class="symbol">Fl</span>
                    <span class="name">Флеровий</span>
                </div>
                <div id="Mc" class="element unknown" data-symbol="Mc">
                    <span class="atomic-number">115</span>
                    <span class="symbol">Mc</span>
                    <span class="name">Московий</span>
                </div>
                <div id="Lv" class="element unknown" data-symbol="Lv">
                    <span class="atomic-number">116</span>
                    <span class="symbol">Lv</span>
                    <span class="name">Ливерморий</span>
                </div>
                <div id="Ts" class="element unknown" data-symbol="Ts">
                    <span class="atomic-number">117</span>
                    <span class="symbol">Ts</span>
                    <span class="name">Теннессин</span>
                </div>
                <div id="Og" class="element unknown" data-symbol="Og">
                    <span class="atomic-number">118</span>
                    <span class="symbol">Og</span>
                    <span class="name">Оганесон</span>
                </div>


            </div>
        </div>

        <!-- Лантаноиды -->
        <div class="lanthanides">
            <div id="Ce" class="element lanthanide" data-symbol="Ce">
                <span class="atomic-number">58</span>
                <span class="symbol">Ce</span>
                <span class="name">Церий</span>
            </div>
            <div id="Pr" class="element lanthanide" data-symbol="Pr">
                <span class="atomic-number">59</span>
                <span class="symbol">Pr</span>
                <span class="name">Празеодим</span>
            </div>
            <div id="Nd" class="element lanthanide" data-symbol="Nd">
                <span class="atomic-number">60</span>
                <span class="symbol">Nd</span>
                <span class="name">Неодим</span>
            </div>
            <div id="Pm" class="element lanthanide" data-symbol="Pm">
                <span class="atomic-number">61</span>
                <span class="symbol">Pm</span>
                <span class="name">Прометий</span>
            </div>
            <div id="Sm" class="element lanthanide" data-symbol="Sm">
                <span class="atomic-number">62</span>
                <span class="symbol">Sm</span>
                <span class="name">Самарий</span>
            </div>
            <div id="Eu" class="element lanthanide" data-symbol="Eu">
                <span class="atomic-number">63</span>
                <span class="symbol">Eu</span>
                <span class="name">Европий</span>
            </div>
            <div id="Gd" class="element lanthanide" data-symbol="Gd">
                <span class="atomic-number">64</span>
                <span class="symbol">Gd</span>
                <span class="name">Гадолиний</span>
            </div>
            <div id="Tb" class="element lanthanide" data-symbol="Tb">
                <span class="atomic-number">65</span>
                <span class="symbol">Tb</span>
                <span class="name">Тербий</span>
            </div>
            <div id="Dy" class="element lanthanide" data-symbol="Dy">
                <span class="atomic-number">66</span>
                <span class="symbol">Dy</span>
                <span class="name">Диспрозий</span>
            </div>
            <div id="Ho" class="element lanthanide" data-symbol="Ho">
                <span class="atomic-number">67</span>
                <span class="symbol">Ho</span>
                <span class="name">Гольмий</span>
            </div>
            <div id="Er" class="element lanthanide" data-symbol="Er">
                <span class="atomic-number">68</span>
                <span class="symbol">Er</span>
                <span class="name">Эрбий</span>
            </div>
            <div id="Tm" class="element lanthanide" data-symbol="Tm">
                <span class="atomic-number">69</span>
                <span class="symbol">Tm</span>
                <span class="name">Тулий</span>
            </div>
            <div id="Yb" class="element lanthanide" data-symbol="Yb">
                <span class="atomic-number">70</span>
                <span class="symbol">Yb</span>
                <span class="name">Иттербий</span>
            </div>
            <div id="Lu" class="element lanthanide" data-symbol="Lu">
                <span class="atomic-number">71</span>
                <span class="symbol">Lu</span>
                <span class="name">Лютеций</span>
            </div>
        </div>
        <!-- Актиноиды -->
        <div class="actinides">
            <div id="Th" class="element actinide" data-symbol="Th">
                <span class="atomic-number">90</span>
                <span class="symbol">Th</span>
                <span class="name">Торий</span>
            </div>
            <div id="Pa" class="element actinide" data-symbol="Pa">
                <span class="atomic-number">91</span>
                <span class="symbol">Pa</span>
                <span class="name">Протактиний</span>
            </div>
            <div id="U" class="element actinide" data-symbol="U">
                <span class="atomic-number">92</span>
                <span class="symbol">U</span>
                <span class="name">Уран</span>
            </div>
            <div id="Np" class="element actinide" data-symbol="Np">
                <span class="atomic-number">93</span>
                <span class="symbol">Np</span>
                <span class="name">Нептуний</span>
            </div>
            <div id="Pu" class="element actinide" data-symbol="Pu">
                <span class="atomic-number">94</span>
                <span class="symbol">Pu</span>
                <span class="name">Плутоний</span>
            </div>
            <div id="Am" class="element actinide" data-symbol="Am">
                <span class="atomic-number">95</span>
                <span class="symbol">Am</span>
                <span class="name">Америций</span>
            </div>
            <div id="Cm" class="element actinide" data-symbol="Cm">
                <span class="atomic-number">96</span>
                <span class="symbol">Cm</span>
                <span class="name">Кюрий</span>
            </div>
            <div id="Bk" class="element actinide" data-symbol="Bk">
                <span class="atomic-number">97</span>
                <span class="symbol">Bk</span>
                <span class="name">Берклий</span>
            </div>
            <div id="Cf" class="element actinide" data-symbol="Cf">
                <span class="atomic-number">98</span>
                <span class="symbol">Cf</span>
                <span class="name">Калифорний</span>
            </div>
            <div id="Es" class="element actinide" data-symbol="Es">
                <span class="atomic-number">99</span>
                <span class="symbol">Es</span>
                <span class="name">Эйнштейний</span>
            </div>
            <div id="Fm" class="element actinide" data-symbol="Fm">
                <span class="atomic-number">100</span>
                <span class="symbol">Fm</span>
                <span class="name">Фермий</span>
            </div>
            <div id="Md" class="element actinide" data-symbol="Md">
                <span class="atomic-number">101</span>
                <span class="symbol">Md</span>
                <span class="name">Менделевий</span>
            </div>
            <div id="No" class="element actinide" data-symbol="No">
                <span class="atomic-number">102</span>
                <span class="symbol">No</span>
                <span class="name">Нобелий</span>
            </div>
            <div id="Lr" class="element actinide" data-symbol="Lr">
                <span class="atomic-number">103</span>
                <span class="symbol">Lr</span>
                <span class="name">Лоуренсий</span>
            </div>
        </div>
    </div>
    </div>

    <!-- Контент под таблицей (появляется после разблокировки скролла) -->
    <div class="below-table-content">
        <!-- Секция скачивания приложения -->
        <div class="download-app-section">
            <div class="download-card">
                <a href="https://github.com/layfhaker/mendeleevtable/releases/download/vnightly-20260120-170417/ChemicalAssistant-Setup-1.0.0.exe"
                    class="download-btn-large" id="download-app-btn" target="_blank" rel="noopener">
                    <div class="download-btn-large-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                    </div>
                </a>
                <div class="download-detailes-all">
                    <div class="download-details">
                        <span>Версия 1.0.0</span>
                        <span>•</span>
                        <span>Windows 10/11</span>
                        <span>•</span>
                        <span>~100 МБ</span>
                    </div>
                    <div class="download-links">
                        <a href="https://github.com/layfhaker/mendeleevtable/releases" target="_blank"
                            rel="noopener">Все релизы</a>
                        <span>|</span>
                        <a href="https://github.com/layfhaker/mendeleevtable" target="_blank" rel="noopener">GitHub</a>
                    </div>
                </div>
            </div>

            <!-- Новая кнопка скачивания для Linux -->
            <div class="download-card">
                <a href="https://github.com/layfhaker/mendeleevtable/releases" class="download-btn-large"
                    id="download-linux-btn" target="_blank" rel="noopener"
                    aria-label="Скачать Linux версию Chemical Assistant">
                    <div class="download-btn-large-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                            stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                    </div>
                </a>
                <div class="download-detailes-all">
                    <div class="download-details">
                        <span>Linux версия</span>
                        <span>•</span>
                        <span>AppImage</span>
                        <span>•</span>
                        <span>Все функции</span>
                    </div>
                    <div class="download-links">
                        <a href="https://github.com/layfhaker/mendeleevtable/releases" id="download-linux-appimage"
                            data-asset-ext="appimage" target="_blank" rel="noopener">AppImage</a>
                        <span>|</span>
                        <a href="https://github.com/layfhaker/mendeleevtable/releases" id="download-linux-deb"
                            data-asset-ext="deb" target="_blank" rel="noopener">DEB</a>
                        <span>|</span>
                        <a href="https://github.com/layfhaker/mendeleevtable/releases" target="_blank"
                            rel="noopener">Все версии</a>
                    </div>
                </div>
            </div>
        </div>

        <p>Прокрутите обратно в самый верх, чтобы вернуть таблицу в полноэкранный режим.</p>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <button class="pdf-export-icon-btn" onclick="window.generateElementPDF(window.currentElementData)"
                aria-label="Экспорт в PDF" title="Экспорт в PDF">
                <svg viewBox="0 0 24 24">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <line x1="12" y1="18" x2="12" y2="12"></line>
                    <line x1="9" y1="15" x2="15" y2="15"></line>
                </svg>
            </button>
            <button class="close" aria-label="Закрыть">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <h2 id="element-title"></h2>

            <div id="allotrope-tabs-placeholder"></div>

            <div id="element-info"></div>
        </div>
    </div>

    <div id="electron-config-modal" class="modal" aria-hidden="true">
        <div class="electron-config-content" role="dialog" aria-modal="true" aria-labelledby="electron-config-title">
            <button id="electron-config-close" class="electron-config-close" aria-label="Закрыть">&times;</button>
            <div class="electron-config-header">
                <div>
                    <div class="electron-config-title" id="electron-config-title">

                        <span id="electron-config-heading">Строение атома</span>
                    </div>
                    <div class="electron-config-subtitle" id="electron-config-subtitle"></div>
                </div>
            </div>
            <div class="electron-config-main">
                <div class="electron-config-body">
                    <div class="electron-config-left">
                        <div class="electron-config-symbol">
                            <span class="symbol" id="electron-config-symbol"></span>
                            <span class="number" id="electron-config-number"></span>
                        </div>
                        <div class="electron-config-meta">
                            <span class="charge" id="electron-config-charge"></span>
                            <span class="mass" id="electron-config-mass"></span>
                        </div>
                        <div class="electron-shells" id="electron-config-shells"></div>
                    </div>
                    <div class="electron-config-right">
                        <div id="electron-config-orbitals"></div>
                    </div>
                </div>
                <div class="electron-config-footer">
                    <div class="electron-meta-row">
                        <span class="label">Электроны внешнего уровня</span>
                        <span class="value" id="electron-config-outer-shell"></span>
                    </div>
                    <div class="electron-meta-row">
                        <span class="label">Валентные электроны</span>
                        <span class="value" id="electron-config-valence-electrons"></span>
                    </div>
                    <div class="electron-config-footer-divider"></div>
                    <div class="electron-meta-row">
                        <span class="label">Валентные возможности</span>
                        <span class="value" id="electron-config-valence"></span>
                    </div>
                    <div class="electron-meta-row">
                        <span class="label">Краткая электронная формула</span>
                        <span class="value" id="electron-config-short"></span>
                    </div>
                    <div class="electron-meta-row">
                        <span class="label">Полная электронная формула</span>
                        <span class="value" id="electron-config-full"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="calc-panel" class="calc-panel">
        <div class="calc-header">
            <h3>Калькулятор Массы</h3>
            <span class="close-calc-panel" onclick="toggleCalc(event)">✕</span>
        </div>

        <div id="drop-zone" class="drop-zone">
            <div class="drop-placeholder">Перетащи элементы сюда 👇</div>
        </div>

        <div id="calc-result">
            <div class="mass-value">0 <span class="unit">г/моль</span></div>
            <button class="clear-btn" onclick="clearCalculator()">Очистить</button>
        </div>
    </div>

    <div id="balancer-panel" class="balancer-panel">
        <div class="calc-header">
            <h3>Уравнитель Реакций</h3>
            <span class="close-calc-panel" onclick="toggleBalancer(event)">✕</span>
        </div>

        <div class="balancer-content">
            <div class="balancer-input-row">
                <input type="text" id="balancer-input" placeholder="Например: H2 + O2 = H2O">
                <button id="balance-btn" onclick="performBalance()" aria-label="Уравнять" title="Уравнять">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M5 12h14"></path>
                        <path d="M12 5l7 7-7 7"></path>
                    </svg>
                </button>
            </div>

            <div id="balancer-result" class="balancer-result">
                <span class="placeholder-text">Уравнение появится здесь</span>
            </div>

            <div id="balancer-error" class="balancer-error"></div>

            <div class="balancer-examples">
                <span>Примеры:</span>
                <div class="ex-chips">
                    <button onclick="fillBalance('Fe + Cl2 = FeCl3')">Fe + Cl2</button>
                    <button onclick="fillBalance('Al + O2 = Al2O3')">Al + O2</button>
                    <button onclick="fillBalance('CH4 + O2 = CO2 + H2O')">CH4 + O2</button>
                </div>
            </div>
        </div>
    </div>

    <div class="fab-container" id="fab-container">
        <div class="fab-options">
            <div class="fab-option" onclick="toggleParticles()">
                <span class="fab-label">Анимация фона <span id="particles-status"
                        class="wallpaper-status-badge active">ON</span></span>
                <button class="fab-btn" aria-label="Включить анимацию частиц">
                    <svg>
                        <use href="#icon-particles"></use>
                    </svg>
                </button>
            </div>
            <div class="fab-option" onclick="toggleCalc()">
                <span class="fab-label">Калькулятор</span>
                <button class="fab-btn" aria-label="Открыть калькулятор">
                    <svg>
                        <use href="#icon-calc"></use>
                    </svg>
                </button>
            </div>
            <div class="fab-option" onclick="toggleFilters()">
                <span class="fab-label">Фильтры</span>
                <button class="fab-btn" aria-label="Открыть фильтры">
                    <svg>
                        <use href="#icon-filter"></use>
                    </svg>
                </button>
            </div>
            <div class="fab-option" onclick="toggleSolubility()">
                <span class="fab-label">Растворимость</span>
                <button class="fab-btn" aria-label="Открыть/закрыть таблицу растворимости">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>
                    </svg>
                </button>
            </div>
            <div class="fab-option" onclick="toggleBalancerPanel(event)">
                <span class="fab-label">Уравнитель</span>
                <button class="fab-btn" aria-label="Открыть уравнитель">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18M3 18h18M8 6v12M16 6v12M8 12h8" />
                    </svg>
                </button>
            </div>
            <div class="fab-option" onclick="toggleReactionsModal()">
                <span class="fab-label">Реакции</span>
                <button class="fab-btn" aria-label="Открыть реакции">
                    <svg>
                        <use href="#icon-bolt"></use>
                    </svg>
                </button>
            </div>
            <div class="fab-option" id="live-wallpaper-option" onclick="toggleLiveWallpaper()" style="display: none;">
                <span class="fab-label">Живые Обои <span id="wallpaper-status"
                        class="wallpaper-status-badge">OFF</span></span>
                <button class="fab-btn" id="live-wallpaper-btn" aria-label="Живые обои">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
                        <line x1="8" y1="21" x2="16" y2="21" />
                        <line x1="12" y1="17" x2="12" y2="21" />
                    </svg>
                </button>
            </div>
            <div class="fab-option" id="settings-option" onclick="openSettingsModal()" style="display: none;">
                <span class="fab-label">Настройки</span>
                <button class="fab-btn" aria-label="Настройки">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3" />
                        <path
                            d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
                    </svg>
                </button>
            </div>
        </div>
        <button class="fab-main" onclick="toggleMenu()" aria-label="Открыть меню">
            <span class="icon-menu">
                <svg>
                    <use href="#icon-menu"></use>
                </svg>
            </span>
            <span class="icon-close">
                <svg>
                    <use href="#icon-close"></use>
                </svg>
            </span>
        </button>

    </div>
    <div id="filters-panel" class="filters-panel">
        <div class="filters-header">
            <h3>Фильтры</h3>
            <span class="close-filters" onclick="toggleFilters()" role="button" aria-label="Закрыть фильтры">✕</span>
        </div>
        <div class="filters-section search-section">
            <h4>Поиск</h4>
            <div class="search-wrapper">
                <input type="text" id="element-search" placeholder="Введите текст для поиска...">
                <button class="search-clear" onclick="clearSearch()" aria-label="Очистить поиск">✕</button>
                <button class="search-btn" onclick="performSearch()" aria-label="Найти">
                    <svg>
                        <use href="#icon-search"></use>
                    </svg>
                </button>
            </div>
            <div id="search-results" class="search-results"></div>
        </div>
        <div class="filters-section" id="categories-section">
            <h4>Категории</h4>
            <div class="filter-buttons">
                <button class="filter-btn" data-filter="alkali-metal">Щелочные</button>
                <button class="filter-btn" data-filter="alkaline-earth-metal">Щёлочноземельные</button>
                <button class="filter-btn" data-filter="transition-metal">Переходные</button>
                <button class="filter-btn" data-filter="post-transition-metal">Постпереходные</button>
                <button class="filter-btn" data-filter="metalloid">Металлоиды</button>
                <button class="filter-btn" data-filter="nonmetal">Неметаллы</button>
                <button class="filter-btn" data-filter="halogen">Галогены</button>
                <button class="filter-btn" data-filter="noble-gas">Благородные газы</button>
                <button class="filter-btn" data-filter="lanthanide">Лантаноиды</button>
                <button class="filter-btn" data-filter="actinide">Актиноиды</button>
                <button class="filter-btn" data-filter="unknown">"Неизвестные св-ва"</button>
            </div>
        </div>

        <div class="filters-actions">
            <button class="filter-reset" onclick="resetFilters()">Сбросить</button>
        </div>
    </div>

    <div id="solubility-modal" class="modal"
        onclick="if (event.target === this || event.target.classList.contains('solubility-backdrop')) closeSolubility()">
        <div class="solubility-backdrop"></div>

        <div class="modal-content solubility-content">
            <div class="modal-header">
                <h2>Таблица растворимости</h2>
                <div class="modal-header-controls">
                    <button id="color-mode-btn" onclick="toggleColorMode()" title="Реальные цвета веществ">
                        <svg>
                            <use href="#icon-palette"></use>
                        </svg>
                    </button>

                    <button id="activity-mode-btn" title="Ряд активности металлов" onclick="toggleActivitySeries()">
                        <svg>
                            <use href="#icon-bolt"></use>
                        </svg>
                    </button>

                    <button id="advanced-mode-info-btn"
                        title="💡 Двойной клик = подробная информация о веществе&#10;(или долгое нажатие на мобильных)">
                        <svg>
                            <use href="#icon-info"></use>
                        </svg>
                    </button>

                    <button id="solubility-search-btn" onclick="toggleSolubilitySearch()" title="Поиск">
                        <svg>
                            <use href="#icon-search"></use>
                        </svg>
                    </button>

                    <button id="solubility-close-btn" class="close-solubility" onclick="closeSolubility()"
                        aria-label="Закрыть">
                        <svg>
                            <use href="#icon-close"></use>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Панель рядов активности -->
            <div id="activity-series-panel" class="activity-series-panel">
                <div class="activity-series-content">
                    <div class="activity-header">
                        <h4 id="activity-title">Ряд активности металлов</h4>
                        <button id="toggle-nonmetals-btn" class="toggle-series-btn" onclick="toggleNonmetalsSeries()">
                            Переключить на неметаллы
                        </button>
                    </div>

                    <div id="metals-series" class="series-container active">
                        <div class="activity-series-row">
                            Li → Rb → K → Ba → Sr → Ca → Na → Mg → Al → Mn → Zn → Cr → Fe → Cd → Co → Ni → Sn → Pb →
                            <span class="hydrogen-marker">(H)</span> → Sb → Bi → Cu → Hg → Ag → Pt → Au
                        </div>
                        <p class="activity-note">Слева направо — уменьшение восстановительных свойств (активности)
                            металлов</p>
                    </div>

                    <div id="nonmetals-series" class="series-container">
                        <div class="activity-series-row">
                            F → O → N → Cl → Br → I → S → C → P → Si
                        </div>
                        <p class="activity-note">Слева направо — уменьшение окислительных свойств
                            (электроотрицательности) неметаллов</p>
                    </div>
                </div>
            </div>

            <div class="solubility-wrapper">
                <table id="solubility-table"></table>
            </div>
        </div>

    </div>

    <!-- Модальное окно "Реакции" -->
    <div id="reactions-modal" class="modal">
        <div class="modal-content solubility-content reactions-content">
            <div class="modal-header">
                <div class="reactions-title">
                    <h2>Подбор продуктов реакции</h2>
                    <p class="reactions-subtitle">Введите реагенты, а продукты подставятся автоматически.</p>
                </div>
                <div class="modal-header-controls">
                    <button class="close-reactions" onclick="toggleReactionsModal(event)" aria-label="Закрыть">
                        <svg>
                            <use href="#icon-close"></use>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="reactions-body">
                <div class="reactions-input-block reactions-input-primary">
                    <label for="reactions-input">Реагенты</label>
                    <div class="reactions-hint">Можно указать только исходные вещества. Пример: H2 + O2 → ?</div>
                    <textarea id="reactions-input" placeholder="H2 + O2 -> ?"></textarea>
                </div>
                <div class="reactions-output-block reactions-output-secondary">
                    <label for="reactions-output">Уравнение реакции</label>
                    <textarea id="reactions-output" readonly placeholder="Здесь появится уравнение реакции"></textarea>
                    <div id="reactions-tags" class="reactions-tags"></div>
                </div>
                <div class="reactions-examples">
                    <span>Примеры реагентов:</span>
                    <div class="reactions-chips">
                        <button type="button" onclick="fillReactionInput('Fe + Cl2')">Fe + Cl2</button>
                        <button type="button" onclick="fillReactionInput('Al + O2')">Al + O2</button>
                        <button type="button" onclick="fillReactionInput('CH4 + O2')">CH4 + O2</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Мобильное окно поиска для таблицы растворимости -->
    <div id="solubility-search-panel" class="solubility-search-panel">
        <div class="solubility-search-header">
            <h4>Поиск вещества</h4>
            <span class="close-solubility-search" onclick="toggleSolubilitySearch()">✕</span>
        </div>
        <div class="solubility-search-content">
            <div class="search-wrapper">
                <input type="text" id="solubility-search-input" placeholder="Введите формулу (NaCl, BaSO4...)">
                <button class="solubility-search-clear" onclick="clearSolubilitySearch()">✕</button>
                <button class="search-btn" onclick="performSolubilitySearch()" aria-label="Найти">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно продвинутого режима -->
    <div id="advanced-substance-modal" class="modal">
        <div class="advanced-modal-content">
            <div id="advanced-substance-content">
                <!-- Содержимое генерируется динамически через advanced-modal.js -->
            </div>
            <button class="close-advanced-modal" onclick="closeAdvancedModal()" aria-label="Закрыть">
                &times;
            </button>
        </div>
    </div>

    <!-- Settings Modal for Electron -->
    <div id="settings-modal" class="modal">
        <div class="modal-content settings-modal-content">
            <span class="close" onclick="closeSettingsModal()">&times;</span>
            <h2>Настройки</h2>

            <div class="settings-section">
                <h3>Автозапуск</h3>
                <label class="switch-label">
                    <input type="checkbox" id="autostart-checkbox" class="switch-input">
                    <span class="switch-slider"></span>
                    <span class="switch-text">Запускать с Windows</span>
                </label>
                <p class="setting-description">
                    Автоматически запускать Chemical Assistant при загрузке Windows (необходимо для постоянных живых
                    обоев)
                </p>
            </div>

            <div class="settings-section">
                <h3>Информация о живых обоях</h3>
                <p class="info-text">
                    Когда живые обои включены и вы закрываете главное окно,
                    приложение продолжает работать в системном трее.
                </p>
                <p class="info-text">
                    Щёлкните правой кнопкой мыши по иконке в трее, чтобы переключить обои или выйти из приложения.
                </p>
            </div>

            <div class="settings-section">
                <h3>О приложении</h3>
                <p class="info-text" id="app-info-text">Chemical Assistant</p>
            </div>
        </div>
    </div>

    <script src="data/bad-apple-payload.js"></script>
    <script src="data/bad-apple-payload-solubility.js"></script>
    <script src="js/scrypt.js"></script>



    <!-- KaTeX для формул -->

    <!-- html2pdf для генерации PDF -->

    <!-- Модуль экспорта -->

    <!-- Основные данные и функции -->

    <!-- Модуль поиска и фильтров -->
    <!-- Основные данные и функции -->
    <script src="js/reactions-db.js"></script>
    <script src="js/modules/reactions.js"></script>
    <script src="js/modules/search-filters.js"></script>
    <script src="js/modules/ui.js"></script>
</body>

</html>

============================================================
ФАЙЛ: .\manifest.json
============================================================

{
  "name": "Химический Ассистент",
  "short_name": "Химия",
  "start_url": "./index.html",
  "display": "standalone",
  "background_color": "#1a1a2e",
  "theme_color": "#2196F3",
  "orientation": "any",
  "icons": [
    {
      "src": "img/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "img/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}


============================================================
ФАЙЛ: .\QWEN.md
============================================================

# Qwen Code Context File

## Project Overview

**Chemical Assistant** is an interactive periodic table of elements application built with pure HTML, CSS, and JavaScript. It features an extensive database of chemical elements with detailed information, including physical properties, history, applications, and interesting facts. The project also includes advanced features like a solubility table, molecular mass calculator, and a unique "nodemap" visualization system for code architecture.

The application is designed as a Progressive Web App (PWA) with offline capabilities and also has a desktop version built with Electron that includes special features like Windows wallpaper integration.

### Key Features

- **Interactive Periodic Table**: Complete Mendeleev table with 118 elements, color-coded by categories
- **Element Information**: Detailed data for each element including atomic properties, discovery history, applications, and facts
- **Alloytrope Support**: Information about different forms of elements (e.g., diamond/graphite for carbon)
- **Solubility Table**: Comprehensive 24×16 table showing solubility of compounds with realistic colors
- **Molecular Mass Calculator**: Drag-and-drop calculator for determining compound masses
- **Search & Filters**: Smart search functionality and category filtering
- **Dark/Light Themes**: With wave animations and particle effects
- **LaTeX Export**: Generate `.tex` files with element data and reactions
- **PWA Support**: Works offline with service worker caching
- **Electron Desktop App**: Windows/Linux builds with Windows wallpaper integration
- **Large Screen Optimization**: Adaptive sizing for wide displays
- **Nodemap Visualization**: Interactive graph visualization of code architecture and dependencies

### Technology Stack

- **Frontend**: Pure HTML5, CSS3, JavaScript (ES6+)
- **No Frameworks**: Built without external frameworks for maximum performance
- **Canvas API**: Used for particle animations and 3D atom visualization
- **SVG**: Vector icons and graphics
- **PWA**: Service workers, manifest for offline functionality
- **Electron**: Desktop application wrapper with native API integration

## Project Structure

```
mendeleevtable/
├── index.html                 # Main HTML structure
├── manifest.json              # PWA manifest
├── sw.js                     # Service worker for offline functionality
├── css/                      # Stylesheets (modular system)
│   ├── style.css             # Main import file
│   ├── base.css              # Base styles and canvas
│   ├── table.css             # Periodic table styling
│   ├── modal.css             # Element modal window
│   ├── theme.css             # Dark theme and animations
│   ├── fab.css               # Floating action button menu
│   ├── calculator.css        # Molecular mass calculator
│   ├── filters.css           # Search and filter panel
│   ├── solubility.css        # Solubility table styling
│   ├── advanced-modal.css    # Advanced substance modal
│   ├── nodemap.css           # Nodemap visualization
│   └── scroll-collapse.css   # Scroll-collapse system
├── js/                       # JavaScript modules
│   ├── scrypt.js             # Module loader (entry point)
│   ├── icons.js              # SVG icon sprite
│   ├── elements.js           # Elements database (118 elements)
│   ├── particles.js          # Canvas animations and 3D atoms
│   ├── scroll-collapse.js    # Virtual scroll and collapse system
│   ├── wallpaper-handler.js  # Wallpaper functionality (Electron)
│   ├── download-link-updater.js # Dynamic download links
│   ├── modules/              # Core modules
│   │   ├── modal.js          # Element modal functionality
│   │   ├── theme.js          # Theme switching
│   │   ├── calculator.js     # Molecular mass calculator
│   │   ├── balancer.js       # Reaction balancer
│   │   ├── latex-export.js   # LaTeX export
│   │   ├── search-filters.js # Search and filtering
│   │   ├── ui.js             # FAB menu and UI interactions
│   │   └── mobile-layout.js  # Mobile responsiveness
│   ├── solubility/           # Solubility table modules
│   │   ├── data.js           # Cation/anion matrix data
│   │   ├── colors.js         # Substance color mapping
│   │   ├── solubility-table.js # Table rendering
│   │   ├── filters.js        # Filtering and highlighting
│   │   ├── search.js         # Substance search
│   │   ├── modal.js          # Main modal functionality
│   │   └── advanced-modal.js # Detailed substance info
│   └── nodemap/              # Architecture visualization
│       ├── nodemap-init.js   # Initialization
│       ├── nodemap-parser.js # Function parsing
│       ├── nodemap-layout.js # Placement algorithm
│       ├── nodemap-canvas.js # Canvas rendering
│       ├── nodemap-modal.js  # Modal interface
│       ├── nodemap-flow-data.js # Data flow analysis
│       ├── nodemap-flow-layout.js # Flow diagram layout
│       └── nodemap-flow-canvas.js # Flow diagram rendering
├── electron-app/             # Electron desktop application
│   ├── electron/             # Electron main process files
│   │   ├── main.js           # Main Electron process
│   │   ├── preload.js        # Secure renderer API
│   │   └── wallpaper-api.js  # Windows wallpaper API
│   ├── package.json          # Electron app config
│   └── README.md             # Electron setup instructions
├── latex/                    # LaTeX templates
│   ├── element-template.tex
│   └── preamble.tex
├── img/                      # Image assets
└── md/                       # Documentation files
```

## Building and Running

### Web Version
1. Clone the repository
2. Open `index.html` directly in a browser (no server required)
3. Or serve via a local HTTP server for optimal functionality

### Development Setup
```bash
# For Electron desktop app
cd electron-app
npm install
npm start
```

### Electron Desktop App Build
```bash
# Install dependencies
npm install

# Run in development
npm run dev

# Build for production
npm run build

# Build Windows installer
npm run build:win

# Build Linux packages (AppImage/deb/snap)
npm run build:linux
```

## Development Conventions

- **Pure JavaScript**: No bundlers, frameworks, or transpilers used
- **Modular Loading**: Custom module system via `scrypt.js`
- **File Protocol Support**: Code works with `file://` protocol
- **Performance First**: Optimized for speed and efficiency
- **Mobile Responsive**: Designed with mobile-first approach
- **Progressive Enhancement**: Core functionality works without JavaScript

## Key Files and Components

- `js/elements.js`: Contains comprehensive database of chemical elements with detailed properties
- `js/scrypt.js`: Custom module loading system that loads scripts progressively
- `js/nodemap/`: Advanced code visualization system that analyzes and displays function dependencies
- `electron-app/electron/`: Desktop application wrapper with Windows integration features
- `sw.js`: Service worker implementing comprehensive caching strategy

## Special Features

### Electron Integration
The desktop version includes unique features:
- **Live Wallpaper**: Sets the periodic table as animated Windows desktop wallpaper
- **System Tray**: Application continues running in system tray when closed
- **Auto-start**: Option to launch with Windows
- **NSIS Installer**: Professional installation package
 - **Linux Packages**: AppImage / deb / snap builds (without wallpaper integration)

### Nodemap Visualization
An innovative feature that automatically analyzes the codebase and creates an interactive graph visualization showing:
- Function dependencies and relationships
- Call frequency heat map (Cold/Normal/Warm/Hot)
- Function types (Entry/Hub/Leaf/Island)
- Complexity metrics
- Warning panel for dead code, circular dependencies, and high complexity

### Solubility Table
Comprehensive 24×16 table with:
- Sticky headers for easy navigation
- Crosshair highlighting for selected compounds
- Realistic colors representing actual substance colors
- Toggle functionality for highlighting
- Search and filter capabilities


============================================================
ФАЙЛ: .\reactions-analysis-v2.md
============================================================

# Анализ reactions.js — Ошибки и недостающие правила

## ЧАСТЬ 1: ОШИБКИ И БАГИ

### 1. Fe2O3 классифицируется и как basic, и как amphoteric_weak
В `substance_classes` Fe2O3 встречается дважды:
- `{ formula: "Fe2O3", class: "oxide", subclass: "basic" }`
- `{ formula: "Fe2O3", class: "oxide", subclass: "amphoteric_weak" }`

Последняя запись перезаписывает первую в `classMap`. Из-за этого `ruleBasicOxideAcid` может не сработать для Fe2O3, потому что функция проверяет `classifyFormula` → `kind: 'oxide'`, но подкласс будет `amphoteric_weak`, а не `basic`. Нужно решить — Fe2O3 в школьном курсе чаще считается основным оксидом (с кислотами реагирует как основный).

### 2. ruleMetalOxygen — Na + O2 → Na2O2
Строка 823: `if (metalStr === 'Na') return '2Na + O2 → Na2O2';`

Это верно для горения на воздухе, но если пользователь хочет именно Na2O, нужно условие "недостаток O2". К тому же для Li должен быть Li2O (Li — единственный щелочной, который даёт нормальный оксид при горении), а для K — KO2 (супероксид). Сейчас Li и K обрабатываются общим правилом через `metalToOxideMap`, что для Li правильно, но для K некорректно (K + O2 → KO2, а не K2O).

### 3. ruleHalogenAlkaliDisproportionation — ошибка в hot-формуле
Строка 1083: при нагревании Cl2 + NaOH даёт `NaClO3`, а не `NaClO`. Формула:
```
3Cl2 + 6NaOH → 5NaCl + NaClO3 + 3H2O
```
В коде: `${m}${halogen.replace('2', '')}O3` — это даст `NaClO3`, что верно для Cl.  
Но для Br2 и I2 эта реакция протекает иначе: Br2 и I2 при нагревании со щёлочью также диспропорционируют, но Br → BrO3⁻, а I → IO3⁻, что тоже `O3`. Формально код верный, но стоит проверить, что I2 + KOH(горяч.) действительно даёт KIO3.

### 4. ruleNeutralization — неправильный расчёт cationCharge
Строка 599: `const cationCharge = base.ohCount || getIonCharge(...)`.  
Здесь `ohCount` используется как заряд катиона, что верно только когда заряд = кол-ву OH. Для Ca(OH)2 `ohCount = 2`, `charge = 2` — совпадает. Но если бы была экзотическая запись, это может сломаться. Лучше всегда использовать `getIonCharge` и fallback на `ohCount`.

### 5. ruleMetalAcid — не расставлены коэффициенты
Строка 928: `return \`${metalStr} + ${acidStr} → ${salt} + H2↑\``  
Коэффициенты не расставлены (нет acid coeff, metal coeff, H2 coeff). Это полагается на `autoBalanceRuleEquation`, но для многих случаев brute force с maxCoeff=12 может не найти решение для сложных формул или работать медленно.

### 6. ruleHydrolysis — кислая соль строится неверно для многих случаев
Строки 1178-1179: `buildSaltFormula(salt.cationFormula, salt.cationCharge, \`H${salt.anionFormula}\`, salt.anionCharge + 1)`

Проблема: для Na2CO3 гидролиз даёт NaHCO3. Анион H(CO3) должен иметь заряд -1, а `salt.anionCharge + 1 = -2 + 1 = -1` — верно. Но формула `H${salt.anionFormula}` = `HCO3` — это корректно. Однако для Na2SO4 (сильная кислота) гидролиз не идёт — это должно отсечься раньше. А для Na3PO4 анион HPO4²⁻, не H(PO4). Формула `HPO4` с зарядом -2 — нужно проверить, что `buildSaltFormula` даст `Na2HPO4`, а не `NaHPO4`.

### 7. ruleAmphotericFusion — неполный map
Строка 1012-1017: map содержит Al2O3, ZnO, Al(OH)3, Cr2O3, но не содержит:
- Zn(OH)2 (при сплавлении → Na2ZnO2 + H2O)
- BeO, Be(OH)2 (при сплавлении → Na2BeO2 + H2O)
- PbO, Pb(OH)2
- SnO, Sn(OH)2

### 8. CrO3 → H2CrO4 / H2Cr2O7 — парсинг сломается
В `acid_oxide_pairs`: `{ oxide: "CrO3", acid: "H2CrO4 / H2Cr2O7" }`.  
`parseAcid("H2CrO4 / H2Cr2O7")` вернёт null или неверный результат из-за пробелов и слеша.

### 9. metalToOxideMap — ключ для Fe
В `metal_oxide_pairs` есть `metal: "Fe(II)"` и `metal: "Fe(III)"`. Код делает `pair.metal.replace(/\(.*\)$/, '')` → `"Fe"` для обоих. Второй (Fe2O3) перезапишет первый (FeO) в `metalToOxideMap`. Значит `metalToOxideMap.get('Fe')` = `Fe2O3`, а не `FeO`. Это влияет на `ruleDecompositionCarbonates` (FeCO3 обработан hardcoded) и `ruleDecompositionNitrates` (Fe(NO3)2 даст Fe2O3 вместо FeO).

### 10. Дублирование хэндлеров в applyRules
R28 и R36 оба вызывают `ruleKMnO4`. R29/R29B и R37/R38 оба вызывают `ruleK2Cr2O7`/`ruleK2Cr2O7FeSO4`. Это не баг, но лишние вызовы — если первый не матчит, второй тоже не матчит.

---

## ЧАСТЬ 2: НЕДОСТАЮЩИЕ ПРАВИЛА / РЕАКЦИИ

### A. Химия кремния (SiO2)
- **SiO2 + NaOH(сплавл.)** → Na2SiO3 + H2O ✗ (не покрыто — `ruleAcidicOxideBase` требует `strong` base, но `SiO2` отдельно не обработан для сплавления)
- **SiO2 + Na2CO3(сплавл.)** → Na2SiO3 + CO2↑ ✗
- **SiO2 + CaO(сплавл.)** → CaSiO3 ✗
- **SiO2 + HF** → SiF4↑ + 2H2O ✗ (уникальная реакция кремнезёма)
- **Si + NaOH + H2O** → Na2SiO3 + H2↑ ✗
- **Na2SiO3 + CO2 + H2O** → Na2CO3 + H2SiO3↓ ✗ (вытеснение слабой кислоты)

### B. Сульфиды
- **FeS + HCl** → FeCl2 + H2S↑ ✗ (в общем ruleSaltAcid есть, но FeS не факт, что корректно парсится как "соль")
- **Na2S + HCl** → 2NaCl + H2S↑ ✗ (должно работать через ruleSaltAcid, но нужно проверить)
- **CuS + HNO3(конц)** → Cu(NO3)2 + S + ... ✗ (нерастворимые сульфиды + окислитель)
- **FeS2 (пирит)** — горение: 4FeS2 + 11O2 → 2Fe2O3 + 8SO2 ✗
- **PbS + HNO3** ✗

### C. Фосфор
- **P + O2** — сейчас `ruleNonmetalOxygen` берёт первый оксид из oxideToAcidMap (P2O5), что верно только для избытка O2. При недостатке → P2O3.
- **P + Cl2** → PCl3 (недост.) / PCl5 (избыток) ✗
- **P + металлы** → фосфиды (Ca3P2, Na3P) ✗
- **PCl3 + H2O** → H3PO3 + HCl ✗
- **PCl5 + H2O** → H3PO4 + HCl ✗

### D. Азот и аммиак (расширение)
- **NH4Cl** разложение при нагревании: NH4Cl → NH3↑ + HCl↑ ✗
- **(NH4)2Cr2O7** разложение: (NH4)2Cr2O7 → Cr2O3 + N2↑ + 4H2O ✗ (вулканчик)
- **NH4HCO3** разложение: NH4HCO3 → NH3↑ + CO2↑ + H2O ✗
- **NH4NO3** при нагревании (есть, но только один вариант). При сильном нагревании: 2NH4NO3 → 2N2↑ + O2↑ + 4H2O ✗
- **N2 + H2** → NH3 (синтез аммиака) ✗
- **N2 + металлы** → нитриды (Li3N, Ca3N2, Mg3N2) ✗
- **NH3 + CuO** → Cu + N2 + H2O ✗

### E. Углерод
- **C + H2O(пар)** → CO + H2 (водяной газ) ✗
- **CO + NaOH(конц, давление)** → HCOONa ✗ (специфично, но встречается в ЕГЭ)
- **CO2 + C** → 2CO (реакция Будуара) ✗
- **CO2 + Mg** → MgO + C (горение магния в CO2) ✗

### F. Сера
- **S + металлы** → сульфиды (Fe + S → FeS, Cu + S → CuS, Na + S → Na2S и др.) ✗
- **S + O2** → SO2 (уже есть через ruleNonmetalOxygen? надо проверить)
- **SO2 + H2O** — покрыто через ruleAcidicOxideWater ✓
- **SO3 + H2O** — покрыто ✓
- **SO2 + H2S** → S + H2O (ОВР) ✗
- **SO2 + NaOH** → Na2SO3 + H2O / NaHSO3 (избыток SO2) ✗ (через ruleAcidicOxideBase есть первая, но нет второй)
- **H2SO4(конц) + NaCl(тв)** → NaHSO4 + HCl↑ ✗ (получение HCl в лаборатории)
- **H2SO4(конц) + NaNO3(тв)** → NaHSO4 + HNO3↑ ✗ (получение HNO3 в лаборатории)
- **H2SO4(конц) + сахароза** — есть в ruleDehydration ✓

### G. Галогены (расширение)
- **F2 + H2O** → HF + OF2 / HF + O2 ✗ (фтор — особый случай, не просто HF + HFO)
- **HF + SiO2** → SiF4 + H2O ✗
- **HCl + MnO2** → MnCl2 + Cl2 + H2O ✗ (получение хлора в лаборатории)
- **Cl2 + Fe** → FeCl3 (есть в ruleSpecialCombination ✓)
- **I2 + крахмал** — качественная, не уравнение

### H. Металлы — дополнительные ОВР
- **Fe + H2O(пар)** — есть в ruleMetalSteam ✓
- **Fe(OH)2 + O2 + H2O** → Fe(OH)3 ✗ (окисление на воздухе)
- **Fe2O3 + H2** → Fe + H2O ✗ (восстановление водородом)
- **CuO + H2** → Cu + H2O ✗ (восстановление водородом)
- **WO3 + H2** → W + H2O ✗
- Другие оксиды + H2 ✗
- **Cu + конц. HNO3** — покрыто через ruleMetalHNO3 ✓
- **Cu + разб. HNO3** — покрыто ✓
- **3Cu + 8HNO3(разб)** — нужно проверить коэффициенты

### I. Электролиз (серьёзно расширить)
Сейчас электролиз покрыт только hardcoded для NaCl, AgNO3, KBr, Al2O3, NaOH, MgCl2, CuSO4, H2O. Нужно добавить:
- **Раствор**: общее правило по катоду (ряд активности) и аноду (тип аниона)
- Расплав солей активных металлов с кислородсодержащими анионами
- Расплав гидроксидов
- электролиз Cu(NO3)2, FeCl2, NiBr2 и др.

### J. Термолиз (разложение при нагревании)
- **Сульфаты**: FeSO4 → Fe2O3 + SO2 + SO3 ✗ (сложные продукты)
- **Сульфиты**: Na2SO3 → Na2SO4 + Na2S ✗ (диспропорционирование)
- **Хлораты**: KClO3 → KCl + O2 (есть ✓), но KClO3 + MnO2(кат) → KCl + O2 ✗
- **Оксалаты, ацетаты** (органика — может быть вне scope)
- **CaCO3** → CaO + CO2 — покрыто через ruleDecompositionCarbonates ✓
- **Cu(OH)2** → CuO + H2O — покрыто через ruleDecompositionHydroxides ✓
- **NH4Cl** → NH3 + HCl ✗
- **NH4HCO3** → NH3 + CO2 + H2O ✗
- **KNO2** разложение ✗

### K. Комплексные соединения (расширить)
Сейчас только Cu(OH)2 + NH3 и AgCl + NH3. Нужно:
- **Fe(OH)3 + 3HCl** → FeCl3 + 3H2O (не комплекс, но часто путают)
- **FeCl3 + KSCN** → Fe(SCN)3 + KCl (качественная на Fe³⁺) ✗
- **FeCl3 + K4[Fe(CN)6]** → KFe[Fe(CN)6]↓ + KCl (берлинская лазурь) ✗
- **FeCl2 + K3[Fe(CN)6]** → KFe[Fe(CN)6]↓ + KCl (турнбулева синь) ✗
- **AgNO3 + NH3 → [Ag(NH3)2]NO3** ✗
- **CuSO4 + NaOH(изб)** — сначала Cu(OH)2↓, потом не растворяется (амфотерность Cu слабая)
- **Zn(OH)2 + NH3** → [Zn(NH3)4](OH)2 ✗
- **AlCl3 + NaOH(изб.)** → Na[Al(OH)4] / NaAlO2 + NaCl + H2O ✗ (поэтапное добавление щёлочи к соли)

### L. Качественные реакции (уравнения)
- **Ca(OH)2 + CO2** → CaCO3↓ + H2O (помутнение известковой воды) ✗
- **Ca(OH)2 + CO2(изб)** → Ca(HCO3)2 (просветление) ✗
- **BaCl2 + Na2SO4** → BaSO4↓ + 2NaCl — покрыто через ruleSaltSalt ✓
- **AgNO3 + NaCl** → AgCl↓ + NaNO3 — покрыто через ruleSaltSalt ✓

### M. Общие структурные пробелы
1. **Нет правила: неметалл + неметалл** (H2 + Cl2 → 2HCl, H2 + S → H2S, H2 + N2 → NH3 и т.д.)
2. **Нет правила: металл + неметалл** (кроме O2 и галогенов) — Fe + S, Na + S, Ca + N2, и др.
3. **Нет правила: оксид + восстановитель H2** (только CO и C есть)
4. **Нет правила: SiO2 + специфика** (плавка с основаниями, с HF)
5. **Нет правила: разложение солей аммония** (NH4Cl, NH4HCO3, (NH4)2CO3, (NH4)2Cr2O7)
6. **Нет правила: окисление Fe²⁺ → Fe³⁺** (FeCl2 + Cl2 → FeCl3, Fe(OH)2 → Fe(OH)3)
7. **Нет общего правила для электролиза по таблице** (сейчас только hardcoded)

---

## ЧАСТЬ 3: ПРИОРИТЕТ ДОБАВЛЕНИЯ

По важности для ЕГЭ/ОГЭ:

**Высокий приоритет (часто в заданиях):**
1. Неметалл + неметалл (H2+Cl2, H2+S, N2+H2)
2. Металл + неметалл (Fe+S, Na+S, Ca+N2)
3. Восстановление H2 (CuO+H2, Fe2O3+H2)
4. SiO2 + NaOH(сплавл), SiO2 + HF
5. Разложение солей аммония
6. Окисление Fe²⁺ → Fe³⁺ (Cl2, O2)
7. Ca(OH)2 + CO2 (качественная!)
8. Получение HCl/HNO3 (H2SO4конц + NaCl/NaNO3)
9. Fe(OH)2 + O2 + H2O → Fe(OH)3
10. N2 + H2 → NH3

**Средний приоритет:**
11. Электролиз расширенный
12. Химия фосфора (P+Cl2, PCl+H2O)
13. SO2 + H2S → S + H2O
14. CO2 + C → 2CO
15. CO2 + Mg → MgO + C
16. Качественные ОВР (FeCl3+KSCN, берлинская лазурь)

**Низкий приоритет (редко):**
17. Пирит FeS2 + O2
18. CO + NaOH → HCOONa
19. Водяной газ C + H2O → CO + H2
20. Экзотические комплексы


============================================================
ФАЙЛ: .\README.md
============================================================

# 🧪 Химический Ассистент — Интерактивная таблица Менделеева

> Интерактивный справочник по химии с расширенными данными об элементах, аллотропах, таблицей растворимости, уравнивателем реакций, LaTeX-экспортом и умным поиском. Полностью адаптирован для мобильных устройств и больших экранов. Работает оффлайн как PWA, есть десктопные сборки для Windows и Linux (режим обоев — только Windows).

**🔗 GitHub:** https://github.com/layfhaker/mendeleevtable  
**🌐 Демо:** https://layfhaker.github.io/mendeleevtable/

---

## 📁 Структура проекта

```
mendeleevtable/
├── index.html           # Основная HTML-разметка
├── manifest.json        # PWA манифест
├── sw.js                # Service Worker для оффлайн-режима
│
├── electron-app/        # 🖥️ Electron приложение (отдельная папка)
│   ├── electron/        # Код Electron
│   │   ├── main.js      # Главный процесс
│   │   ├── preload.js   # Безопасный API
│   │   └── wallpaper-api.js # Windows API для обоев
│   ├── package.json     # NPM конфигурация
│   ├── node_modules/    # Зависимости (после npm install)
│   ├── dist/            # Готовые сборки (.exe/.AppImage/.deb/.snap)
│   └── README.md        # Инструкция по Electron
│
├── latex/               # 📄 LaTeX шаблоны экспорта
│   ├── element-template.tex
│   └── preamble.tex
│
├── css/                 # Стили (модульная система)
│   ├── style.css        # Главный файл (импорты)
│   ├── base.css         # Базовые стили и canvas
│   ├── table.css        # Периодическая таблица Менделеева
│   ├── modal.css        # Модальное окно элемента
│   ├── theme.css        # Тёмная тема + волновая анимация
│   ├── fab.css          # FAB-меню (плавающая кнопка)
│   ├── calculator.css   # Калькулятор молярной массы
│   ├── filters.css      # Панель фильтров и поиска
│   ├── solubility.css   # Таблица растворимости
│   ├── advanced-modal.css # Продвинутая модалка веществ
│   ├── nodemap.css      # NodeMap (визуализация архитектуры)
│   └── scroll-collapse.css # Scroll-collapse система (NEW!)
│
├── js/                  # JavaScript (модульная система)
│   ├── scrypt.js        # 🚀 Модульный загрузчик (entry point)
│   ├── icons.js         # SVG-спрайт иконок
│   ├── elements.js      # База данных 118 элементов
│   ├── particles.js     # Canvas: анимация фона + 3D атомы
│   ├── scroll-collapse.js # Виртуальный скролл и сжатие (NEW!)
│   ├── wallpaper-handler.js # Обработчик установки обоев (NEW!)
│   │
│   ├── modules/         # 📦 Основные модули
│   │   ├── modal.js     # Модальное окно элемента
│   │   ├── theme.js     # Тёмная тема
│   │   ├── calculator.js # Калькулятор молярной массы
│   │   ├── balancer.js  # Уравниватель реакций
│   │   ├── latex-export.js # Экспорт в LaTeX
│   │   ├── search-filters.js # Поиск и фильтры
│   │   ├── ui.js        # FAB-меню и UI
│   │   └── mobile-layout.js # Мобильная адаптация
│   │
│   ├── solubility/      # 🧪 Таблица растворимости
│   │   ├── data.js      # Данные: катионы, анионы, матрица
│   │   ├── colors.js    # 100+ цветов веществ
│   │   ├── solubility-table.js # Рендеринг таблицы
│   │   ├── filters.js   # Фильтрация и выделение
│   │   ├── search.js    # Поиск веществ
│   │   ├── modal.js     # Открытие/закрытие основной модалки
│   │   ├── advanced-modal.js # Продвинутая модалка с детальной информацией
│   │
│   └── nodemap/         # 🗺️ Визуализация архитектуры
│       ├── nodemap-init.js # Инициализация
│       ├── nodemap-parser.js # Парсер функций
│       ├── nodemap-layout.js # Алгоритм размещения
│       ├── nodemap-canvas.js # Canvas рендеринг
│       ├── nodemap-modal.js # Интерфейс модального окна
│       ├── nodemap-flow-data.js # Анализ потока данных
│       ├── nodemap-flow-layout.js # Layout для flow-диаграмм
│       └── nodemap-flow-canvas.js # Рендеринг flow-диаграмм
│
└── img/
    ├── favicon.png      # Фавикон
    ├── png1.png         # PWA иконка 192x192
    └── png2.png         # PWA иконка 512x512
```

---

## ✅ Реализованные функции

### 🖥️ Electron приложение (NEW!)
- ✅ **Scroll-Collapse система** — таблица плавно сжимается при скролле
- ✅ **Виртуальный скролл** — до порога 300px страница не прокручивается
- ✅ **Установка обоев** — кнопка в FAB-меню (только Windows)
- ✅ **Windows API** — автоматическая установка через PowerShell
- ✅ **Portable версия** — не требует установки
- ✅ **Инсталлятор NSIS** — профессиональная установка
- ✅ **Linux сборки** — AppImage / deb / snap

### 🔬 Основной интерфейс
- ✅ Интерактивная таблица Менделеева (118 элементов)
- ✅ Цветовая кодировка по 10 категориям
- ✅ Лантаноиды и актиноиды вынесены отдельно
- ✅ **FAB-меню** для быстрого доступа к функциям
- ✅ **SVG иконки** с автоматической сменой цвета
- ✅ **Полная мобильная адаптация** (PWA-готово)

### 📖 Модальное окно элемента
- ✅ Анимация открытия из точки клика
- ✅ Эффект "разлёта" элементов таблицы
- ✅ Полупрозрачный фон (видны 3D атомы)
- ✅ **4 информационные секции:**
  - Базовая информация (номер, масса, период, группа, блок)
  - Физические свойства (плотность, температуры, цвет, структура)
  - История и практика (открытие, происхождение, применение)
  - Интересные факты

### ⚗️ Система аллотропов
- ✅ Табы для переключения между формами
- ✅ Кнопка "+ Ещё" для редких аллотропов
- ✅ Индивидуальные данные для каждой формы

### 🔍 Поиск и фильтрация
- ✅ **Умный поиск** по названию, символу, фактам, применению
- ✅ **Панель фильтров** по 10 категориям элементов
- ✅ **Химический парсер** — распознаёт формулы:
  - "BaSO4" → открывает таблицу растворимости
  - "хлорид натрия" → NaCl → таблица растворимости
  - Подсветка найденного вещества крестовиной

### 🧪 Таблица растворимости
- ✅ **Полноэкранная модалка** 24×16 (384 соединения)
- ✅ **Sticky Headers** — фиксированные заголовки
- ✅ **Подсветка крестовиной** — выделение строки + столбца
- ✅ **Toggle-логика** — повторный клик снимает выделение
- ✅ **🎨 Режим "Реальные цвета":**
  - Чёрные осадки (сульфиды Ag, Pb, Cu, Fe, Ni, Co, Hg)
  - Жёлтые осадки (AgI, PbI₂, хроматы)
  - Голубые растворы (Cu²⁺)
  - Розовые растворы (Co²⁺, Mn²⁺)
  - Зелёные растворы (Ni²⁺, Fe²⁺, Cr³⁺)
  - Фиолетовые растворы (KMnO₄)
  - Белые осадки с градиентом
  - Бесцветные растворы с "водяным" оттенком

### 🧮 Калькулятор молекулярной массы
- ✅ Drag & Drop элементов из таблицы
- ✅ Тап для добавления (мобильные)
- ✅ Редактирование индексов
- ✅ Адаптивное позиционирование

### ⚖️ Уравниватель реакций
- ✅ Ввод уравнения и автоматическая балансировка
- ✅ Встроенные примеры для быстрого старта
- ✅ Адаптивное позиционирование на больших экранах

### 📄 Экспорт в LaTeX
- ✅ Экспорт данных элемента в `.tex`
- ✅ Форматирование формул через `mhchem`
- ✅ Таблицы свойств и соединений из таблицы растворимости

### 🎨 Визуальные эффекты
- ✅ **3D модель атома** — вращающиеся электроны
- ✅ **Тёмная тема** с волновой анимацией
- ✅ **Частицы на фоне** — летающие точки с соединениями
- ✅ Плавные переходы и анимации

### 📱 PWA и оффлайн
- ✅ **manifest.json** — установка на устройство
- ✅ **Service Worker** — работа без интернета
- ✅ Иконки 192×192 и 512×512
- ✅ iOS-совместимость (apple-touch-icon)
- ✅ Splash screen для Android

### 🗺️ NodeMap — Визуализация архитектуры (NEW!)
- ✅ **Автоматический анализ кода** — сканирование всех функций
- ✅ **Интерактивный граф** — визуализация зависимостей
- ✅ **Тепловая карта** — частота вызовов (Cold/Normal/Warm/Hot)
- ✅ **Типизация функций** (Entry/Hub/Leaf/Island)
- ✅ **Метрики сложности** — Lines, Complexity, Parameters
- ✅ **Поиск и фильтры** — быстрое нахождение функций
- ✅ **Панель предупреждений** — Dead Code, Circular Dependencies, High Complexity
- ✅ Открытие по клавише `.` (точка)

### 📱 Мобильная оптимизация (v0.6.5)
- ✅ **Полноэкранный режим** таблицы растворимости
- ✅ **Safe-area** — учёт "челки" и кнопки Home
- ✅ **Скрытые скроллбары** — чистый интерфейс
- ✅ **Вертикальная шапка** — заголовок сверху, кнопки снизу
- ✅ **Bounce эффекты** — естественное поведение скролла
- ✅ **0px bottom padding** в PWA-режиме
- ✅ **Правильные рамки** выделенных ячеек

### 🖥️ Оптимизация для больших экранов
- ✅ Адаптивные размеры модальных окон и таблиц
- ✅ Корректная геометрия панелей (калькулятор/уравниватель)

---

## 🎨 Цветовая схема категорий

| Категория | Светлая тема | Тёмная тема |
|-----------|-------------|-------------|
| Щелочные металлы | 🔴 #ff9999 | 🔴 #8b3a3a |
| Щёлочноземельные | 🟠 #ffcc99 | 🟠 #8b6914 |
| Переходные металлы | 🟡 #ffff99 | 🟡 #7a7a2e |
| Постпереходные металлы | 🟢 #ccff99 | 🟢 #4a7a2e |
| Металлоиды | 🩵 #99ffcc | 🩵 #2e7a5c |
| Неметаллы | 🔵 #99ffff | 🔵 #2e6a7a |
| Галогены | 💙 #99ccff | 💙 #2e4a7a |
| Благородные газы | 🟣 #cc99ff | 🟣 #5c2e7a |
| Лантаноиды | 💗 #ff99cc | 💗 #7a2e5c |
| Актиноиды | 💜 #ff99ff | 💜 #7a2e7a |

---

## 🛠 Технологии

- **HTML5** — семантическая разметка
- **CSS3** — Grid, Flexbox, CSS Variables, анимации, sticky positioning
- **JavaScript (ES6+)** — Drag & Drop API, модульная загрузка
- **Canvas API** — анимация частиц, 3D атомы, NodeMap визуализация
- **SVG** — векторные иконки
- **PWA** — Service Worker, Web App Manifest
- **Electron** — десктопное приложение с нативными API
- **Node.js** — PowerShell интеграция, установка обоев
- **Без фреймворков** — чистый код, максимальная производительность

---

## 📊 Статистика проекта

| Параметр | Значение |
|----------|----------|
| Элементов в базе | 118 / 118 |
| Аллотропов | 40+ |
| Полей на элемент | 20+ |
| Соединений в таблице растворимости | 384 (24×16) |
| Веществ с реальными цветами | 100+ |
| Веществ с детальной информацией | 118 / 118 |
| JavaScript-функций | 200+ |
| Строк кода | ~6000+ |
| Размер проекта | ~150 КБ |
| CSS файлов | 11 |
| JS модулей | 24 |

---

## 📝 История версий

### v1.0.0 (текущая) — январь 2026
- 🖥️ **Electron приложение** — полноценное десктопное приложение
- ✨ **Scroll-Collapse система** — таблица сжимается при виртуальном скролле
- 🖼️ **Установка обоев Windows** — интеграция с Windows API
- 📦 **Portable версия** — запуск без установки
- 🪟 **NSIS инсталлятор** — профессиональная установка
- 🐧 **Linux сборки** — AppImage / deb / snap
- 📄 **LaTeX экспорт** — генерация `.tex` файлов для элемента
- 🧪 **118 элементов** — полностью заполненные данные по таблице
- 🖥️ **Оптимизация больших экранов** — масштаб и отступы UI

### v0.6.5 — январь 2026
- 🗺️ **NodeMap** — визуализация архитектуры проекта
- 📱 **Мобильная оптимизация** — полноэкранный режим таблицы растворимости
- 🔧 **Safe-area** — поддержка "челок" и кнопок Home
- 🎨 **Bounce эффекты** — естественное поведение скролла
- 📦 **Продвинутая модалка** — детальная информация о веществах
- 🗃️ **substances-data.js** — база данных о веществах
- 📱 **Улучшения для iPhone** — оптимизированы размеры иконок и кнопок
- 📱 **Улучшения для Android** — уменьшены размеры иконок FAB меню
- 🎨 **Единообразие цветов** — синие кнопки на всех устройствах

### v0.6 — декабрь 2025
- **Поиск и фильтрация** — панель фильтров, умный поиск
- **Таблица растворимости** — 24×16, sticky headers, крестовина
- **🎨 Режим реальных цветов** — 100+ веществ
- **PWA** — полный оффлайн-режим

### v0.5
- SVG иконки, FAB-меню
- Калькулятор массы (Drag & Drop)
- Тёмная тема с волновой анимацией
- 3D атомы, полупрозрачные модалки

### v0.4
- FAB-меню, калькулятор
- Элементы 11-40 в базе

### v0.3
- Система аллотропов

### v0.2
- Модальное окно с 4 секциями

### v0.1
- Базовая таблица Менделеева

---

## 🎯 Roadmap v0.7

### 📊 Аналитика и статистика
- 📈 **Графики растворимости** — зависимость от температуры
- 📊 **Режим сравнения** — сопоставление двух веществ
- 🔬 **Изотопы** — информация о периодах полураспада

### 🔬 Лабораторный режим
- ⚗️ **Симулятор реакций** — визуализация химических процессов
- ⚖️ **Уравниватель реакций** — автоматическая балансировка
- 🧪 **База реакций** — типичные реакции с анимацией

### 📤 Экспорт и шаринг
- 💾 **Экспорт данных** — PNG, PDF, JSON
- 🔗 **Поделиться** — ссылки на вещества и элементы
- 📋 **Копирование** — формул, данных, графиков

### 🧠 Образовательный режим
- 📝 **Тесты по элементам** — проверка знаний
- 🃏 **Flashcards** — карточки для запоминания
- 🏆 **Режим викторины** — соревновательный элемент
- 📊 **Достижения** — прогресс обучения

### 🌐 Дополнительно
- 🌍 **Мультиязычность** (EN/RU/KZ)
- 🎨 **Режим для дальтоников**
- 🔌 **Интеграция с PubChem API**
- 🥽 **AR-режим** (WebXR)

---

## 🚀 Установка и запуск

### Локальный запуск (веб-версия):
```bash
# 1. Клонировать репозиторий
git clone https://github.com/layfhaker/mendeleevtable.git

# 2. Перейти в папку
cd mendeleevtable

# 3. Открыть в браузере
# Просто откройте index.html двойным кликом
# или используйте Live Server в VS Code
```

### 🖥️ Electron приложение (NEW!)

Проект можно запустить как десктопное приложение с функцией установки обоев!

**📖 Подробная инструкция:** см. [`electron-app/README.md`](electron-app/README.md)

#### Быстрый старт:
```bash
# 1. Перейти в папку Electron
cd electron-app

# 2. Установить зависимости
npm install

# 3. Запустить приложение
npm start

# 4. Собрать .exe файл (опционально)
npm run build
```

#### Уникальные возможности:
- 🖼️ **Установка обоев Windows** — текущий вид таблицы как обои рабочего стола
- ✨ **Scroll-Collapse система** — таблица плавно сжимается при скролле
- 📦 **Portable версия** — не требует установки
- 🪟 **NSIS инсталлятор** — профессиональная установка

### Как PWA:
1. Откройте сайт в Chrome/Safari: https://layfhaker.github.io/mendeleevtable/
2. Нажмите "Установить" / "Добавить на главный экран"
3. Приложение будет работать оффлайн

### GitHub Pages:
Проект автоматически деплоится на GitHub Pages при каждом пуше в ветку `main`.

---

## 📱 Совместимость

- ✅ **Chrome/Edge** (рекомендуется) — полная поддержка
- ✅ **Firefox** — полная поддержка
- ✅ **Safari** (iOS/macOS) — полная поддержка
- ✅ **Mobile browsers** — оптимизировано
- ✅ **PWA** — работает на Android и iOS
- ⚠️ **Internet Explorer** — не поддерживается

### Минимальные требования:
- ECMAScript 6+ (ES2015)
- Canvas API
- CSS Grid/Flexbox
- Service Workers (для PWA)

---

## 🤖 Для разработчиков

### Документация:
- [`md/AI_CONTEXT.md`](md/AI_CONTEXT.md) — технические ограничения и структура
- [`md/TODO.md`](md/TODO.md) — список задач и баги
- [`md/NODEMAP_GUIDE.md`](md/NODEMAP_GUIDE.md) — руководство по NodeMap
- [`js/nodemap/README.md`](js/nodemap/README.md) — техническая документация NodeMap
- [`js/solubility/README.md`](js/solubility/README.md) — описание модуля растворимости
- [`js/solubility/MODULES_STRUCTURE.md`](js/solubility/MODULES_STRUCTURE.md) — структура модулей
- [`latex/README.md`](latex/README.md) — экспорт в LaTeX
- [`electron-app/README.md`](electron-app/README.md) — десктопная версия

### Ключевые особенности кода:
- ✅ **Модульная система** — файлы загружаются динамически через `scrypt.js`
- ✅ **Нет import/export** — совместимость с `file://` протоколом
- ✅ **Чистый JavaScript** — без фреймворков и сборщиков
- ✅ **CSS Variables** — легкая кастомизация
- ✅ **Адаптивный дизайн** — mobile-first подход

### Добавление нового элемента:
```javascript
// В файле js/elements.js
"Nn": {
    atomicNumber: "119",
    name: "Новый элемент",
    atomicMass: "300",
    // ... остальные поля
}
```

### Добавление информации о веществе:
```javascript
// В файле js/solubility/substances-data.js
"Ba2+-SO42-": {
    name: "Сульфат бария",
    formula: "BaSO₄",
    molarMass: 233.43,
    // ... остальные поля (см. README.md в папке)
}
```

---

## 🤝 Вклад в проект

Мы приветствуем любой вклад в развитие проекта! Вот как вы можете помочь:

### Способы участия:
1. 🐛 **Сообщить о баге** — создайте Issue
2. 💡 **Предложить идею** — опишите в Issues
3. 📝 **Добавить данные** — элементы, вещества, реакции
4. 🎨 **Улучшить дизайн** — UI/UX предложения
5. 🌍 **Перевод** — добавить новый язык
6. 📖 **Документация** — улучшить README, комментарии

### Правила оформления Pull Request:
- Четкое описание изменений
- Соблюдение структуры кода
- Тестирование на десктопе и мобильных
- Проверка в обеих темах (светлая/темная)

---

## 📄 Лицензия

MIT License — можно использовать в любых целях с указанием авторства.

---

## 👨‍💻 Автор

**Авари (layfhaker)**  
GitHub: [@layfhaker](https://github.com/layfhaker)

---

## 🌟 Поддержка проекта

Если проект вам помог — поставьте ⭐ на GitHub!

---

*Проект создан для школьной олимпиады по химии/информатике*  
*Последнее обновление: январь 2026*


============================================================
ФАЙЛ: .\solubility-colors.json
============================================================

[
  {
    "key": "Ag+-Cl-",
    "value": "white"
  },
  {
    "key": "Pb2+-Cl-",
    "value": "white"
  },
  {
    "key": "Pb2+-Br-",
    "value": "white"
  },
  {
    "key": "Ba2+-SO42-",
    "value": "white"
  },
  {
    "key": "Pb2+-SO42-",
    "value": "white"
  },
  {
    "key": "Ca2+-SO42-",
    "value": "white"
  },
  {
    "key": "Sr2+-SO42-",
    "value": "white"
  },
  {
    "key": "Ag+-SO42-",
    "value": "white"
  },
  {
    "key": "Ca2+-CO32-",
    "value": "white"
  },
  {
    "key": "Ba2+-CO32-",
    "value": "white"
  },
  {
    "key": "Mg2+-CO32-",
    "value": "white"
  },
  {
    "key": "Sr2+-CO32-",
    "value": "white"
  },
  {
    "key": "Pb2+-CO32-",
    "value": "white"
  },
  {
    "key": "Zn2+-CO32-",
    "value": "white"
  },
  {
    "key": "Ca2+-PO43-",
    "value": "white"
  },
  {
    "key": "Ba2+-PO43-",
    "value": "white"
  },
  {
    "key": "Mg2+-PO43-",
    "value": "white"
  },
  {
    "key": "Zn2+-PO43-",
    "value": "white"
  },
  {
    "key": "Pb2+-PO43-",
    "value": "white"
  },
  {
    "key": "Al3+-PO43-",
    "value": "white"
  },
  {
    "key": "Ca2+-SiO32-",
    "value": "white"
  },
  {
    "key": "Ba2+-SiO32-",
    "value": "white"
  },
  {
    "key": "Mg2+-SiO32-",
    "value": "white"
  },
  {
    "key": "Zn2+-SiO32-",
    "value": "white"
  },
  {
    "key": "Ca2+-SO32-",
    "value": "white"
  },
  {
    "key": "Ba2+-SO32-",
    "value": "white"
  },
  {
    "key": "Pb2+-SO32-",
    "value": "white"
  },
  {
    "key": "Al3+-OH-",
    "value": "white"
  },
  {
    "key": "Zn2+-OH-",
    "value": "white"
  },
  {
    "key": "Mg2+-OH-",
    "value": "white"
  },
  {
    "key": "Ca2+-OH-",
    "value": "white"
  },
  {
    "key": "Ba2+-OH-",
    "value": "white"
  },
  {
    "key": "Sn2+-OH-",
    "value": "white"
  },
  {
    "key": "Zn2+-S2-",
    "value": "white"
  },
  {
    "key": "Ca2+-F-",
    "value": "white"
  },
  {
    "key": "Ba2+-F-",
    "value": "white"
  },
  {
    "key": "Mg2+-F-",
    "value": "white"
  },
  {
    "key": "Sr2+-F-",
    "value": "white"
  },
  {
    "key": "Pb2+-F-",
    "value": "white"
  },
  {
    "key": "Na+-NO3-",
    "value": "colorless"
  },
  {
    "key": "K+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Ca2+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Ba2+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Mg2+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Zn2+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Pb2+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Al3+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Ag+-NO3-",
    "value": "colorless"
  },
  {
    "key": "Na+-Cl-",
    "value": "colorless"
  },
  {
    "key": "K+-Cl-",
    "value": "colorless"
  },
  {
    "key": "Ca2+-Cl-",
    "value": "colorless"
  },
  {
    "key": "Ba2+-Cl-",
    "value": "colorless"
  },
  {
    "key": "Mg2+-Cl-",
    "value": "colorless"
  },
  {
    "key": "Zn2+-Cl-",
    "value": "colorless"
  },
  {
    "key": "Al3+-Cl-",
    "value": "colorless"
  },
  {
    "key": "Na+-SO42-",
    "value": "colorless"
  },
  {
    "key": "K+-SO42-",
    "value": "colorless"
  },
  {
    "key": "Mg2+-SO42-",
    "value": "colorless"
  },
  {
    "key": "Zn2+-SO42-",
    "value": "colorless"
  },
  {
    "key": "Al3+-SO42-",
    "value": "colorless"
  },
  {
    "key": "Na+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "K+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "Ca2+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "Ba2+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "Mg2+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "Zn2+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "Pb2+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "Al3+-CH3COO-",
    "value": "colorless"
  },
  {
    "key": "Ag+-Br-",
    "value": "#fffdd0"
  },
  {
    "key": "Ag+-I-",
    "value": "#fff9b0"
  },
  {
    "key": "Pb2+-I-",
    "value": "#ffd700"
  },
  {
    "key": "Hg2+-I-",
    "value": "#ff4500"
  },
  {
    "key": "Ag+-PO43-",
    "value": "#ffff00"
  },
  {
    "key": "Cd2+-S2-",
    "value": "#ffff00"
  },
  {
    "key": "Ba2+-CrO42-",
    "value": "#ffff00"
  },
  {
    "key": "Pb2+-CrO42-",
    "value": "#ffff00"
  },
  {
    "key": "Sr2+-CrO42-",
    "value": "#fff9b0"
  },
  {
    "key": "Ca2+-CrO42-",
    "value": "#ffff00"
  },
  {
    "key": "Ag+-CrO42-",
    "value": "#8b0000"
  },
  {
    "key": "K+-Cr2O72-",
    "value": "#ff8c00"
  },
  {
    "key": "Na+-Cr2O72-",
    "value": "#ff8c00"
  },
  {
    "key": "NH4+-Cr2O72-",
    "value": "#ff8c00"
  },
  {
    "key": "Ag+-Cr2O72-",
    "value": "#dc143c"
  },
  {
    "key": "Pb2+-Cr2O72-",
    "value": "#ff4500"
  },
  {
    "key": "Fe3+-Cl-",
    "value": "#cd853f"
  },
  {
    "key": "Fe3+-SO42-",
    "value": "#cd853f"
  },
  {
    "key": "Fe3+-NO3-",
    "value": "#cd853f"
  },
  {
    "key": "Cu2+-OH-",
    "value": "#87ceeb"
  },
  {
    "key": "Cu2+-SO42-",
    "value": "#87ceeb"
  },
  {
    "key": "Cu2+-NO3-",
    "value": "#87ceeb"
  },
  {
    "key": "Cu2+-Cl-",
    "value": "#48d1cc"
  },
  {
    "key": "Cu2+-CO32-",
    "value": "#228b22"
  },
  {
    "key": "Fe2+-OH-",
    "value": "#90ee90"
  },
  {
    "key": "Ni2+-OH-",
    "value": "#90ee90"
  },
  {
    "key": "Ni2+-SO42-",
    "value": "#48d1cc"
  },
  {
    "key": "Ni2+-Cl-",
    "value": "#90ee90"
  },
  {
    "key": "Ni2+-NO3-",
    "value": "#50c878"
  },
  {
    "key": "Cr3+-OH-",
    "value": "#7fbf7f"
  },
  {
    "key": "Cr3+-Cl-",
    "value": "#228b22"
  },
  {
    "key": "Fe3+-OH-",
    "value": "#8b4513"
  },
  {
    "key": "Sn2+-S2-",
    "value": "#8b4513"
  },
  {
    "key": "Co2+-OH-",
    "value": "#6aa9ff"
  },
  {
    "key": "Co2+-Cl-",
    "value": "#ff69b4"
  },
  {
    "key": "Co2+-NO3-",
    "value": "#ff69b4"
  },
  {
    "key": "Co2+-SO42-",
    "value": "#ff69b4"
  },
  {
    "key": "Mn2+-SO42-",
    "value": "#ffb6c1"
  },
  {
    "key": "Mn2+-S2-",
    "value": "#8b4513"
  },
  {
    "key": "K+-MnO4-",
    "value": "#8b008b"
  },
  {
    "key": "Na+-MnO4-",
    "value": "#8b008b"
  },
  {
    "key": "Cr3+-SO42-",
    "value": "#228b22"
  },
  {
    "key": "Ag+-S2-",
    "value": "#000000"
  },
  {
    "key": "Pb2+-S2-",
    "value": "#000000"
  },
  {
    "key": "Cu2+-S2-",
    "value": "#000000"
  },
  {
    "key": "Fe2+-S2-",
    "value": "#000000"
  },
  {
    "key": "Ni2+-S2-",
    "value": "#000000"
  },
  {
    "key": "Co2+-S2-",
    "value": "#000000"
  },
  {
    "key": "Hg2+-S2-",
    "value": "#000000"
  },
  {
    "key": "Cu2+-CH3COO-",
    "value": "#48d1cc"
  },
  {
    "key": "Cu2+-PO43-",
    "value": "#87ceeb"
  },
  {
    "key": "Ni2+-CO32-",
    "value": "#90ee90"
  },
  {
    "key": "Ni2+-PO43-",
    "value": "#90ee90"
  },
  {
    "key": "Ni2+-CH3COO-",
    "value": "#90ee90"
  },
  {
    "key": "Co2+-CO32-",
    "value": "#ff69b4"
  },
  {
    "key": "Co2+-PO43-",
    "value": "#8a2be2"
  },
  {
    "key": "Co2+-CH3COO-",
    "value": "#ff69b4"
  },
  {
    "key": "Cr3+-NO3-",
    "value": "#228b22"
  },
  {
    "key": "Cr3+-CH3COO-",
    "value": "#228b22"
  },
  {
    "key": "Fe2+-SO42-",
    "value": "#98fb98"
  },
  {
    "key": "Fe2+-Cl-",
    "value": "#98fb98"
  },
  {
    "key": "Fe2+-NO3-",
    "value": "#98fb98"
  },
  {
    "key": "Fe2+-CO32-",
    "value": "#778899"
  },
  {
    "key": "Mn2+-Cl-",
    "value": "#ffb6c1"
  },
  {
    "key": "Mn2+-NO3-",
    "value": "#ffb6c1"
  },
  {
    "key": "Mn2+-CH3COO-",
    "value": "#ffb6c1"
  }
]


============================================================
ФАЙЛ: .\sw.js
============================================================

// =========================================
// SERVICE WORKER v11 - Complete Caching
// =========================================

const CACHE_NAME = 'chem-assistant-v11';

// === CRITICAL FILES (cached on install) ===
const PRECACHE_ASSETS = [
    './',
    './index.html',
    './manifest.json',

    // CSS - Loader (must be first)
    './css/loader.css',

    // CSS - Core
    './css/style.css',
    './css/base.css',
    './css/table.css',
    './css/theme.css',
    './css/modal.css',
    './css/fab.css',
    './css/footer.css',

    // CSS - Features
    './css/calculator.css',
    './css/filters.css',
    './css/solubility.css',
    './css/balancer.css',
    './css/nodemap.css',
    './css/scroll-collapse.css',
    './css/advanced-modal.css',

    // JS - Loader (must be first)
    './js/loader.js',

    // JS - Core
    './js/scrypt.js',
    './js/elements.js',
    './js/icons.js',
    './js/particles.js',
    './js/utils.js',
    './js/download-link-updater.js',

    // JS - Modules
    './js/modules/mobile-layout.js',
    './js/modules/modal.js',
    './js/modules/theme.js',
    './js/modules/search-filters.js',
    './js/modules/ui.js',
    './js/modules/calculator.js',
    './js/modules/balancer.js',

    // JS - Solubility
    './js/solubility/data.js',
    './js/solubility/colors.js',
    './js/solubility/solubility-table.js',
    './js/solubility/filters.js',
    './js/solubility/search.js',
    './js/solubility/modal.js',
    './js/solubility/advanced-modal.js',

    // JS - Nodemap
    './js/nodemap/nodemap-parser.js',
    './js/nodemap/nodemap-layout.js',
    './js/nodemap/nodemap-canvas.js',
    './js/nodemap/nodemap-flow-data.js',
    './js/nodemap/nodemap-flow-layout.js',
    './js/nodemap/nodemap-flow-canvas.js',
    './js/nodemap/nodemap-modal.js',
    './js/nodemap/nodemap-init.js',

    // Images
    './img/icon-192.png',
    './img/icon-512.png',
    './img/favicon.png'
];

// === RUNTIME CACHE PATTERNS ===
const RUNTIME_CACHE_PATTERNS = [
    /\/img\/.+\.(png|jpg|svg|webp)$/,
    /\/js\/wallpaper-handler\.js$/,
    /\/js\/scroll-collapse\.js$/
];

// === INSTALL ===
self.addEventListener('install', (event) => {
    console.log('[SW] Installing Service Worker v11...');
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then((cache) => {
                console.log('[SW] Caching critical files');
                return cache.addAll(PRECACHE_ASSETS);
            })
            .then(() => self.skipWaiting())
            .catch((error) => {
                console.error('[SW] Cache failed:', error);
            })
    );
});

// === ACTIVATE ===
self.addEventListener('activate', (event) => {
    console.log('[SW] Activating Service Worker v11');
    event.waitUntil(
        caches.keys().then((keys) => {
            return Promise.all(
                keys.filter((key) => key !== CACHE_NAME)
                    .map((key) => {
                        console.log('[SW] Deleting old cache:', key);
                        return caches.delete(key);
                    })
            );
        }).then(() => self.clients.claim())
    );
});

// === FETCH ===
self.addEventListener('fetch', (event) => {
    const { request } = event;

    // Skip non-GET requests
    if (request.method !== 'GET') return;

    // Skip chrome-extension and other protocols
    if (!request.url.startsWith('http')) return;

    event.respondWith(
        caches.match(request)
            .then((cached) => {
                // Strategy: Stale-While-Revalidate

                if (cached) {
                    // Return from cache immediately
                    // Update in background for next time
                    fetch(request).then((response) => {
                        if (response && response.ok) {
                            caches.open(CACHE_NAME).then((cache) => {
                                cache.put(request, response);
                            });
                        }
                    }).catch(() => {
                        // Offline - do nothing, already returned cache
                    });

                    return cached;
                }

                // Not in cache - fetch from network
                return fetch(request).then((response) => {
                    // Check if should cache this resource
                    if (response && response.ok) {
                        const shouldCache = RUNTIME_CACHE_PATTERNS.some(pattern =>
                            pattern.test(request.url)
                        );

                        if (shouldCache) {
                            const clone = response.clone();
                            caches.open(CACHE_NAME).then((cache) => {
                                cache.put(request, clone);
                            });
                        }
                    }

                    return response;
                }).catch(() => {
                    // Offline and not in cache - return fallback for HTML
                    if (request.headers.get('Accept')?.includes('text/html')) {
                        return caches.match('./index.html');
                    }

                    // For other resources return error
                    return new Response('Offline', {
                        status: 503,
                        statusText: 'Service Unavailable'
                    });
                });
            })
    );
});

// === MESSAGE HANDLER ===
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }

    if (event.data && event.data.type === 'CACHE_STATS') {
        caches.open(CACHE_NAME).then((cache) => {
            cache.keys().then((keys) => {
                event.ports[0].postMessage({
                    cacheSize: keys.length,
                    cacheNames: keys.map(k => k.url)
                });
            });
        });
    }
});

console.log('[SW] Service Worker v11 loaded');


============================================================
ФАЙЛ: .\css\advanced-modal.css
============================================================

/* =========================================
   ADVANCED-MODAL.CSS — Стили продвинутого режима (v2.0)
   ========================================= */

/* Модальное окно */
#advanced-substance-modal {
    display: none;
    position: fixed;
    z-index: 70000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(3px);
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
    overscroll-behavior: contain;
}

/* Кнопка закрытия */
.close-advanced-modal {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255, 255, 255, 0.85);
    border: none;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    font-size: 28px;
    color: #222;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    z-index: 20;
}

.close-advanced-modal:hover {
    background: rgba(255, 255, 255, 1);
}

/* Контент модального окна */
.advanced-modal-content {
    background: var(--bg-color, #fff);
    --advanced-text-primary: #1f2937;
    --advanced-text-secondary: #334155;
    --advanced-text-muted: #475569;
    --advanced-label: #2f3f72;
    --advanced-heading-secondary: #233667;
    --advanced-caption: #2f3f72;
    /* Увеличили радиус для большей плавности */
    border-radius: 24px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    width: min(1100px, 95vw);
    max-height: 90vh;
    height: auto;
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
    /* Важно: обрезает контент по закругленным углам */
    animation: slideInModal 0.3s ease-out;
}

#advanced-substance-content {
    display: flex;
    flex-direction: column;
    width: 100%;
    flex: 1;
    min-height: 0;
    overflow: hidden;
}

@keyframes slideInModal {
    from {
        opacity: 0;
        transform: translateY(-50px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Заголовок */
.advanced-header {
    padding: 20px 25px;
    padding-right: 60px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    flex-shrink: 0;
}

.advanced-title-group h2 {
    margin: 0 0 5px 0;
    font-size: 28px;
    font-weight: bold;
}

.substance-name {
    margin: 0;
    font-size: 16px;
    opacity: 1;
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Вкладки */
.advanced-tabs {
    display: flex;
    background: #f5f5f5;
    border-bottom: 1px solid #ddd;
    overflow-x: auto;
    flex-shrink: 0;
    -ms-overflow-style: none;
    /* IE and Edge */
    scrollbar-width: none;
    /* Firefox */
}

.advanced-tabs::-webkit-scrollbar {
    display: none;
}

.tab-btn {
    padding: 12px 20px;
    background: none;
    border: none;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    color: var(--advanced-text-muted);
    transition: all 0.2s;
    white-space: nowrap;
    position: relative;
}

.tab-btn:hover {
    color: #667eea;
    background: rgba(102, 126, 234, 0.05);
}

.tab-btn.active {
    color: #667eea;
    background: var(--bg-color, #fff);
}

.tab-btn.active::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 3px;
    background: #667eea;
}

/* Контент вкладок */
.advanced-content {
    flex: 1;
    overflow-y: auto;
    padding: 25px;
    min-height: 0;
    -webkit-overflow-scrolling: touch;
    -ms-overflow-style: auto;
    /* IE and Edge */
    scrollbar-width: thin;
    /* Firefox */
}

.advanced-content.no-decomposition {
    display: flex;
    align-items: center;
    justify-content: center;
}

.advanced-content.no-decomposition .tab-pane {
    width: 100%;
    max-width: 960px;
    margin: 0 auto;
    padding-bottom: 0;
}

/* Кастомные скроллбары для контента продвинутого режима */
.advanced-content::-webkit-scrollbar {
    width: 6px;
}

.advanced-content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.03);
    border-radius: 3px;
}

.advanced-content::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #667eea, #764ba2);
    border-radius: 3px;
}

.advanced-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #5a67d8, #6b46c1);
}

/* Тёмная тема */
body.dark-theme .advanced-content::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.03);
}

body.dark-theme .advanced-content::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #818cf8, #a78bfa);
}

body.dark-theme .advanced-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
}

.tab-pane {
    display: none;
    padding-bottom: 20px;
}

.tab-pane.active {
    display: block;
    animation: fadeInTab 0.3s ease;
}

@keyframes fadeInTab {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}

.tab-pane h3 {
    margin: 0 0 15px 0;
    color: #667eea;
    font-size: 20px;
    font-weight: 700;
    border-bottom: 2px solid #667eea;
    padding-bottom: 8px;
}

.tab-pane h4 {
    margin: 20px 0 10px 0;
    color: var(--advanced-heading-secondary);
    font-size: 16px;
    font-weight: 700;
    text-align: center;
}

/* Сетка информации */
.info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.info-item {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.info-item .label {
    font-size: 13px;
    color: var(--advanced-label);
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.04em;
}

.info-item .value {
    font-size: 16px;
    color: var(--advanced-text-primary);
    font-weight: 600;
    line-height: 1.35;
}

/* Бейджи растворимости */
.solubility-badge {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: bold;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
}

.solubility-R,
.solubility-Р {
    background: #4caf50;
}

.solubility-N,
.solubility-Н {
    background: #f44336;
}

.solubility-M,
.solubility-М {
    background: #ff9800;
}

.solubility-D,
.solubility-— {
    background: #9e9e9e;
}

.solubility-O {
    background: #2196f3;
}

/* Секция разложения */
.decomposition-section {
    background: #fff3e0;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid #ff9800;
    margin-top: 15px;
}

.reaction-equation {
    font-size: 16px;
    font-weight: bold;
    color: #e65100;
    margin-bottom: 10px;
    font-family: 'Courier New', monospace;
}

.reaction-description {
    font-size: 15px;
    color: var(--advanced-text-secondary);
    font-weight: 500;
    margin: 0;
}

/* Уведомление о разложении */
.decomposition-notice {
    text-align: center;
    padding: 40px 20px;
}

.decomposition-notice h3 {
    color: #d97706;
    margin-bottom: 15px;
}

.decomposition-notice p {
    margin: 0;
    font-size: 16px;
    color: var(--advanced-text-secondary);
    font-weight: 500;
}

.decomposition-info {
    background: #fff3e0;
    padding: 15px;
    border-radius: 8px;
    margin-top: 20px;
    text-align: left;
    border-left: 4px solid #ff9800;
    color: var(--advanced-text-secondary);
    font-size: 15px;
    font-weight: 500;
}

.decomposition-info strong {
    color: #a84300;
    font-weight: 700;
}

/* Контейнер внешнего вида */
.appearance-container {
    display: flex;
    justify-content: space-around;
    align-items: flex-start;
    gap: 30px;
    flex-wrap: wrap;
    padding: 20px 0;
}

.visual-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    min-width: 150px;
}

.visual-item-transparent {
    position: relative;
    padding: 14px 18px;
    border-radius: 16px;
    border: 1px solid #cfd6df;
    background: linear-gradient(145deg,
            rgba(248, 250, 252, 0.94) 0%,
            rgba(228, 233, 239, 0.88) 100%);
    box-shadow:
        0 10px 26px rgba(148, 163, 184, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.75);
    overflow: hidden;
    animation: transparent-visual-pulse 3.5s ease-in-out infinite;
}

.visual-item-transparent::before {
    content: "";
    position: absolute;
    top: -40%;
    left: -20%;
    width: 60%;
    height: 180%;
    background: linear-gradient(110deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.55) 50%,
            rgba(255, 255, 255, 0) 100%);
    pointer-events: none;
}

.visual-item-transparent svg {
    filter: drop-shadow(0 4px 10px rgba(100, 116, 139, 0.28));
}

@keyframes transparent-visual-pulse {
    0%,
    100% {
        transform: translateY(0);
    }

    50% {
        transform: translateY(-2px);
    }
}

.visual-caption {
    font-size: 15px;
    color: var(--advanced-caption);
    font-weight: 600;
    text-align: center;
    margin: 0;
}

/* Тёмная тема */
body.dark-theme .advanced-modal-content {
    background: #2d2d44;
    --advanced-text-primary: #f4f7ff;
    --advanced-text-secondary: #dbe3ff;
    --advanced-text-muted: #c4d1f8;
    --advanced-label: #b9c7ff;
    --advanced-heading-secondary: #dfe6ff;
    --advanced-caption: #d4dcff;
}

body.dark-theme .advanced-tabs {
    background: #252535;
    border-bottom-color: #444;
}

body.dark-theme .visual-item-transparent {
    border-color: #5f6b7a;
    background: linear-gradient(145deg,
            rgba(74, 82, 96, 0.45) 0%,
            rgba(56, 64, 76, 0.55) 100%);
    box-shadow:
        0 10px 24px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(196, 209, 248, 0.22);
}

body.dark-theme .visual-item-transparent::before {
    background: linear-gradient(110deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(196, 209, 248, 0.3) 50%,
            rgba(255, 255, 255, 0) 100%);
}

body.dark-theme .tab-btn {
    color: var(--advanced-text-muted);
}

body.dark-theme .tab-btn:hover {
    color: #88a4f7;
    background: rgba(136, 164, 247, 0.1);
}

body.dark-theme .tab-btn.active {
    color: #88a4f7;
    background: #2d2d44;
}

body.dark-theme .info-item .value {
    color: var(--advanced-text-primary);
}

body.dark-theme .info-item .label {
    color: var(--advanced-label);
}

body.dark-theme .decomposition-section {
    background: rgba(255, 152, 0, 0.15);
}

body.dark-theme .decomposition-info {
    background: rgba(255, 152, 0, 0.15);
}

body.dark-theme .decomposition-info strong {
    color: #ffd7a6;
}

body.dark-theme .reaction-description,
body.dark-theme .decomposition-notice p,
body.dark-theme .visual-caption {
    color: var(--advanced-text-secondary);
}

/* Мобильная адаптация */
@media (max-width: 768px) {
    #advanced-substance-modal {
        padding: 10px;
    }

    .advanced-modal-content {
        width: 100%;
        max-height: 100%;
        border-radius: 18px;
    }

    .advanced-header {
        padding: 15px 20px;
        padding-right: 50px;
    }

    .advanced-title-group h2 {
        font-size: 22px;
    }

    .tab-btn {
        padding: 10px 15px;
        font-size: 13px;
    }

    .advanced-content {
        padding: 20px 15px;
    }

    .info-grid {
        grid-template-columns: 1fr;
    }

    .appearance-container {
        flex-direction: column;
        align-items: center;
    }
}

/* =========================================
   БОЛЬШИЕ ЭКРАНЫ
   ========================================= */
@media (min-width: 1400px) {
    .advanced-modal-content {
        width: min(1100px, 95vw);
        max-height: 90vh;
        height: auto;
    }

    .advanced-header {
        padding: 30px 40px;
        padding-right: 80px;
    }

    .advanced-title-group h2 {
        font-size: 38px;
    }

    .substance-name {
        font-size: 22px;
    }

    .tab-btn {
        padding: 16px 30px;
        font-size: 17px;
    }

    .advanced-content {
        padding: 40px;
    }

    .tab-pane h3 {
        font-size: 28px;
        margin-bottom: 20px;
    }

    .tab-pane h4 {
        font-size: 20px;
        margin: 25px 0 15px;
    }

    .info-grid {
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 25px;
    }

    .info-item .label {
        font-size: 15px;
    }

    .info-item .value {
        font-size: 20px;
    }

    .solubility-badge {
        padding: 10px 18px;
        font-size: 18px;
    }

    .decomposition-section {
        padding: 20px;
    }

    .reaction-equation {
        font-size: 20px;
    }

    .reaction-description {
        font-size: 16px;
    }

    .visual-item {
        min-width: 200px;
        gap: 20px;
    }

    .visual-caption {
        font-size: 16px;
    }

    .close-advanced-modal {
        width: 45px;
        height: 45px;
        font-size: 36px;
        top: 18px;
        right: 18px;
    }
}

@media (min-width: 1900px) {
    .advanced-modal-content {
        width: min(1100px, 95vw);
        max-height: 90vh;
        height: auto;
    }

    .advanced-header {
        padding: 35px 50px;
        padding-right: 90px;
    }

    .advanced-title-group h2 {
        font-size: 44px;
    }

    .substance-name {
        font-size: 26px;
    }

    .tab-btn {
        padding: 18px 36px;
        font-size: 18px;
    }

    .advanced-content {
        padding: 50px;
    }

    .tab-pane h3 {
        font-size: 32px;
        margin-bottom: 25px;
    }

    .tab-pane h4 {
        font-size: 24px;
        margin: 30px 0 18px;
    }

    .info-grid {
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 30px;
    }

    .info-item .label {
        font-size: 17px;
    }

    .info-item .value {
        font-size: 24px;
    }

    .solubility-badge {
        padding: 12px 22px;
        font-size: 20px;
    }

    .decomposition-section {
        padding: 25px;
    }

    .reaction-equation {
        font-size: 24px;
    }

    .reaction-description {
        font-size: 18px;
    }

    .visual-item {
        min-width: 250px;
        gap: 25px;
    }

    .visual-caption {
        font-size: 18px;
    }

    .close-advanced-modal {
        width: 50px;
        height: 50px;
        font-size: 40px;
        top: 20px;
        right: 20px;
    }
}


============================================================
ФАЙЛ: .\css\balancer.css
============================================================

/* =========================================
   BALANCER.CSS — Extended Upwards
   ========================================= */

/* Базовые стили панели */
.balancer-panel {
    position: fixed;
    bottom: 12px;
    right: 12px;
    width: 320px;
    min-height: 180px;
    max-height: 400px;
    max-height: 400px;
    background: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 2px solid rgba(33, 150, 243, 0.5);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    display: none;
    flex-direction: column;
    z-index: 1000;
    opacity: 0;
    transform: translateY(16px) scale(0.985);
    will-change: transform, opacity;
    pointer-events: none;
    /* Fixes zombie hitbox issue */
}

.balancer-panel.active {
    display: flex;
    animation: balancerOpen var(--flip-move-ms) var(--flip-ease) forwards;
    pointer-events: auto;
    /* Enable pointer events when active */
}

.balancer-panel.active.closing {
    animation: balancerClose var(--flip-move-ms) var(--flip-ease) forwards;
}

@keyframes balancerOpen {
    from {
        opacity: 0;
        transform: translateY(16px) scale(0.985);
    }

    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

@keyframes balancerClose {
    from {
        opacity: 1;
        transform: translateY(0) scale(1);
    }

    to {
        opacity: 0;
        transform: translateY(16px) scale(0.985);
    }
}


/* Скроллбары (Chrome/Safari/Webkit) — ОБЯЗАТЕЛЬНО */
/* Используем общий стиль скроллбара, но с меньшей шириной для компактности */
.balancer-content::-webkit-scrollbar {
    width: 6px;
}

.balancer-content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.03);
    border-radius: 3px;
}

.balancer-content::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #2196F3, #64B5F6);
    border-radius: 3px;
}

.balancer-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #1976D2, #2196F3);
}

/* Тёмная тема */
body.dark-theme .balancer-content::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.03);
}

body.dark-theme .balancer-content::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #64B5F6, #90CAF9);
}

body.dark-theme .balancer-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #42A5F5, #64B5F6);
}

/* 1. Контейнер */
.balancer-content {
    flex: 1 1 auto;
    /* Занимает всё место, которое даст JS */
    display: flex;
    flex-direction: column;
    padding: 10px 12px;
    gap: 10px;

    /* Ограничиваем высоту и добавляем скролл */
    max-height: 200px;
    overflow-y: auto;
    overflow-x: hidden;

    -ms-overflow-style: auto;
    /* IE and Edge */
    scrollbar-width: thin;
    /* Firefox */
}

/* 2. Поле ввода */
.balancer-input-row {
    flex: 0 0 auto;
    display: flex;
    gap: 6px;
    position: relative;
}

#balancer-input {
    flex: 1;
    padding: 10px 12px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 15px;
    /* Чуть крупнее для удобства */
    background: #fff;
    color: #333;
    outline: none;
}

#balancer-input:focus {
    border-color: #2196F3;
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.15);
}

#balance-btn {
    padding: 0;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #2196F3;
    color: white;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    flex-shrink: 0;
}

#balance-btn svg {
    width: 24px;
    height: 24px;
    display: block;
}

#balance-btn:hover {
    background: #1976D2;
    transform: scale(1.05);
}

#balance-btn:active {
    transform: scale(0.95);
}

/* 3. Результат */
.balancer-result {
    flex: 0 0 auto;
    min-height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f5f7fa;
    border: 1px dashed #cfd8dc;
    border-radius: 6px;
    padding: 12px;
    text-align: center;
    font-size: 18px;
    /* Крупный шрифт результата */
    line-height: 1.4;
    color: #37474f;
    word-break: break-word;
}

.balancer-result .coeff {
    color: #d32f2f;
    font-weight: bold;
    font-size: 1.1em;
    margin: 0 2px;
}

/* Исправление отображения индексов (маленьких цифр) */
.balancer-result sub {
    font-size: 0.6em;
    /* Уменьшаем размер шрифта до 60% */
    vertical-align: sub;
    /* Стандартное выравнивание */
    line-height: 0;
    /* Чтобы индекс не раздвигал высоту строки */
    position: relative;
    bottom: -0.1em;
    /* Небольшая корректировка позиции, если нужно */
}

.placeholder-text {
    color: #b0bec5;
    font-size: 14px;
    font-style: italic;
}

/* Ошибки */
.balancer-error {
    display: none;
    flex: 0 0 auto;
    color: #c62828;
    background: #ffebee;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 13px;
    text-align: center;
    border: 1px solid #ffcdd2;
}

/* 4. Примеры */
.balancer-examples {
    flex: 0 0 auto;
    margin-top: 5px;
    padding-top: 10px;
    border-top: 1px solid #eee;
    max-height: 80px;
    /* Ограничиваем высоту примеров */
    overflow-y: auto;
    /* Добавляем скролл при необходимости */
}

.balancer-examples span {
    display: block;
    font-size: 11px;
    font-weight: 700;
    color: #90a4ae;
    text-transform: uppercase;
    margin-bottom: 6px;
}

.ex-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.ex-chips button {
    background: white;
    border: 1px solid #e3f2fd;
    border-radius: 14px;
    padding: 5px 12px;
    font-size: 12px;
    color: #1976D2;
    cursor: pointer;
    transition: all 0.2s;
}

.ex-chips button:hover {
    background: #e3f2fd;
}

/* --- ТЕМНАЯ ТЕМА --- */
body.dark-theme #balancer-panel {
    background: rgba(45, 45, 68, 0.85);
    border-color: rgba(68, 68, 68, 0.5);
}

body.dark-theme #balancer-input {
    background: #393952;
    border-color: #4a4a6a;
    color: #fff;
}

body.dark-theme .balancer-result {
    background: #252535;
    border-color: #4a4a6a;
    color: #eceff1;
}

body.dark-theme .balancer-result .coeff {
    color: #ff8a80;
}

body.dark-theme .placeholder-text {
    color: #607d8b;
}

body.dark-theme .balancer-examples {
    border-top-color: #444;
}

body.dark-theme .ex-chips button {
    background: #32324a;
    border-color: #4a4a6a;
    color: #9fa8da;
}

body.dark-theme .ex-chips button:hover {
    background: #3f3f5c;
    color: #fff;
}

/* Для темного режима используем общий стиль скроллбара */

/* Стили для активного уравнивателя */
@media (max-width: 1024px) {

    body.balancer-active #theme-toggle,
    body.balancer-active .fab-container {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
    }

    /* ИСПРАВЛЕНИЕ СКРОЛЛА: Разрешаем горизонтальную прокрутку, блокируем вертикальную */
    body.balancer-active {
        overflow-y: hidden !important;
        /* Блокируем вертикальный скролл страницы */
        overflow-x: auto !important;
        /* Разрешаем горизонтальный */
        position: fixed !important;
        /* Фиксируем позицию body при открытии панели */
        height: 100% !important;
        width: 100% !important;
        touch-action: pan-x;
        /* Подсказка браузеру, что можно свайпать влево-вправо */
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
    }
}

/* =========================================
   МОБИЛЬНАЯ ВЕРСИЯ УРАВНИВАТЕЛЯ
   ========================================= */
@media (max-width: 1024px) {
    .balancer-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100% !important;
        box-sizing: border-box !important;
        margin: 0;

        min-height: 180px;
        height: 25vh !important;
        max-height: 40vh !important;

        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 2px solid #2196F3;
        border-bottom: none;
        border-radius: 20px 20px 0 0;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);

        display: none;
        flex-direction: column;
        opacity: 0;
        pointer-events: none;

        padding: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));

        z-index: 60000;
        transform: translateY(100%);
        will-change: transform, opacity;
    }

    .balancer-panel.active {
        display: flex;
        animation: balancerSheetOpen var(--flip-move-ms) var(--flip-ease) forwards;
        pointer-events: auto;
    }

    .balancer-panel.active.closing {
        animation: balancerSheetClose var(--flip-move-ms) var(--flip-ease) forwards;
    }
}

@keyframes balancerSheetOpen {
    from {
        opacity: 0;
        transform: translateY(100%);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes balancerSheetClose {
    from {
        opacity: 1;
        transform: translateY(0);
    }

    to {
        opacity: 0;
        transform: translateY(100%);
    }
}

============================================================
ФАЙЛ: .\css\base.css
============================================================

/* =========================================
   BASE.CSS — Базовые стили страницы (ИСПРАВЛЕНО)
   ========================================= */

/* --- Safe Area переменные для iPhone notch --- */
/* =========================================
   BASE.CSS — Базовые стили страницы
   ========================================= */

/* --- Safe Area переменные --- */
:root {
    --sat: env(safe-area-inset-top, 0px);
    --sab: env(safe-area-inset-bottom, 0px);
    --sal: env(safe-area-inset-left, 0px);
    --sar: env(safe-area-inset-right, 0px);

    /* Light theme scrollbar */
    --scrollbar-width: 8px;
    --scrollbar-thumb: #2196F3;
    --scrollbar-thumb-hover: #1976D2;
    --scrollbar-track: rgba(0, 0, 0, 0.05);
    --scrollbar-radius: 4px;

    /* FlipModalAnimator timings */
    --flip-move-ms: 360ms;
    --flip-radius-ms: 360ms;
    --flip-backdrop-ms: 260ms;
    --flip-ease: cubic-bezier(0.2, 0.0, 0.0, 1);
    --flip-backdrop-ease: cubic-bezier(0.2, 0.0, 0.0, 1);
}

body.dark-theme {
    /* Dark theme scrollbar */
    --scrollbar-thumb: #64B5F6;
    --scrollbar-thumb-hover: #90CAF9;
    --scrollbar-track: rgba(255, 255, 255, 0.05);
}

/* 1. ПЕРЕНОСИМ ФОН СЮДА */
html {
    background-color: #f0f0f0;
    /* Красим "подложку" всего браузера */
    height: 100%;
}

/* --- Основные стили body --- */
body {
    font-family: 'Inter', sans-serif;
    /* background-color: #f0f0f0;  <-- УБИРАЕМ ОТСЮДА или оставляем (не мешает) */
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    min-height: 100vh;
    height: auto;
    margin: 0;
    padding: 20px;
    overflow-y: auto;
    overflow-x: hidden;
    /* Лучше hidden для десктопа, если нет таблицы */
    box-sizing: border-box;
}

/* =========================================
   АДАПТИВ
   ========================================= */
@media (max-width: 1024px) {

    html,
    body {
        width: 100%;
        margin: 0;
        padding: 0;
        overflow-x: auto;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        /* Гарантируем, что фон на мобильных тоже серый */
        background-color: #f0f0f0;
    }

    body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;

        /* ВАЖНО: Добавляем var(--sab) к нижнему отступу */
        /* Убираем боковые отступы на мобилках, оставляем safe-area */
        padding: 10px calc(0px + var(--sal)) calc(20px + var(--sab)) calc(0px + var(--sar)) !important;

        box-sizing: border-box;
    }

}

/* --- Canvas для частиц --- */
#particles-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
}



/* =========================================
   АДАПТИВ
   ========================================= */
@media (max-width: 1024px) {

    /* Скрываем полосу прокрутки */
    body::-webkit-scrollbar {
        display: none;
    }

    body {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
}

/* Кастомный скроллбар для десктопной версии */
@media (min-width: 1025px) {
    body::-webkit-scrollbar {
        width: 12px;
    }

    body::-webkit-scrollbar-track {
        background: #f0f0f0;
    }

    body::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #2196F3, #21CBF3);
        border-radius: 10px;
        border: 2px solid #f0f0f0;
    }

    body::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #1976D2, #0BB3F3);
    }

    body {
        scrollbar-width: thin;
        scrollbar-color: #2196F3 #f0f0f0;
    }
}

/* Универсальные стили скроллбара */
/* Firefox */
* {
    scrollbar-width: thin;
    scrollbar-color: #2196F3 rgba(0, 0, 0, 0.05);
}

/* Chrome/Safari/Edge - используем прямые значения вместо переменных */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.05);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #2196F3, #64B5F6);
    border-radius: 4px;
    border: 2px solid transparent;
    background-clip: padding-box;
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #1976D2, #2196F3);
    background-clip: padding-box;
}

::-webkit-scrollbar-corner {
    background: transparent;
}

/* Тёмная тема - глобальные скроллбары */
body.dark-theme * {
    scrollbar-color: #64B5F6 rgba(255, 255, 255, 0.05);
}

body.dark-theme ::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
}

body.dark-theme ::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #64B5F6, #90CAF9);
}

body.dark-theme ::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #42A5F5, #64B5F6);
}

/* =========================================
   Панорамные подсказки (градиенты)
   ========================================= */
.pan-hints {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 5;
}

.pan-hint {
    position: absolute;
    opacity: 0;
    transition: opacity 200ms ease;
}

.pan-hint.is-visible {
    opacity: 1;
}

.pan-hint--left,
.pan-hint--right {
    top: 0;
    bottom: 0;
    width: 36px;
}

.pan-hint--top,
.pan-hint--bottom {
    left: 0;
    right: 0;
    height: 28px;
}

.pan-hint--left {
    left: 0;
    background: linear-gradient(90deg, rgba(240, 240, 240, 0.9), rgba(240, 240, 240, 0));
}

.pan-hint--right {
    right: 0;
    background: linear-gradient(270deg, rgba(240, 240, 240, 0.9), rgba(240, 240, 240, 0));
}

.pan-hint--top {
    top: 0;
    background: linear-gradient(180deg, rgba(240, 240, 240, 0.9), rgba(240, 240, 240, 0));
}

.pan-hint--bottom {
    bottom: 0;
    background: linear-gradient(0deg, rgba(240, 240, 240, 0.9), rgba(240, 240, 240, 0));
}

body.dark-theme .pan-hint--left {
    background: linear-gradient(90deg, rgba(15, 15, 15, 0.9), rgba(15, 15, 15, 0));
}

body.dark-theme .pan-hint--right {
    background: linear-gradient(270deg, rgba(15, 15, 15, 0.9), rgba(15, 15, 15, 0));
}

body.dark-theme .pan-hint--top {
    background: linear-gradient(180deg, rgba(15, 15, 15, 0.9), rgba(15, 15, 15, 0));
}

body.dark-theme .pan-hint--bottom {
    background: linear-gradient(0deg, rgba(15, 15, 15, 0.9), rgba(15, 15, 15, 0));
}

/* Запрет выделения и grab курсор только на ДЕСКТОПЕ */
@media (min-width: 1025px) {

    html,
    body {
        user-select: none;
        -webkit-user-select: none;
        cursor: grab;
    }

    body.grabbing {
        cursor: grabbing;
    }
}

/* Разрешаем выделение ТОЛЬКО в текстовых блоках */
#element-info,
#element-title,
.group-content,
.search-results {
    user-select: text;
    -webkit-user-select: text;
    cursor: auto;
}

/* Скролл-контейнеры должны явно менять курсор */
.solubility-wrapper {
    cursor: grab;
    overflow: auto;
}

/* Мобильные устройства - скрываем скроллбары для более чистого UX */
@media (max-width: 768px),
(pointer: coarse) {

    .solubility-wrapper,
    .periodic-table-container {
        scrollbar-width: none;
    }

    .solubility-wrapper::-webkit-scrollbar,
    .periodic-table-container::-webkit-scrollbar {
        display: none;
    }
}

.solubility-wrapper:active {
    cursor: grabbing;
}

@media (max-width: 1024px) {
    .periodic-table-container {
        justify-content: center !important;
        align-items: center !important;
        transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1),
            height 0.3s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
        height: 100vh !important;
        overflow-y: auto !important;
    }

    #mobile-table-wrapper {
        align-items: flex-start !important;
        transition: transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
        margin-top: 0 !important;
        margin-bottom: 0 !important;
    }

    body.scroll-locked .periodic-table-container {
        transition: none !important;
    }
}

@media (max-width: 1024px) {
    body {
        overflow-y: hidden !important;
    }

    .periodic-table-container {
        overflow-y: hidden !important;
    }

    body.calc-active .periodic-table-container,
    body.balancer-active .periodic-table-container {
        overflow: visible !important;
    }
}

@media (max-width: 1024px) {

    html,
    body {
        overflow-y: hidden !important;
        overflow-x: auto !important;
        height: 100% !important;
        touch-action: pan-x !important;
        /* Разрешаем только горизонтальный скролл */
    }

    /* Для контейнеров с горизонтальным скроллом */
    .periodic-table-container,
    .solubility-wrapper {
        touch-action: pan-x !important;
        -webkit-overflow-scrolling: touch !important;
    }
}

/* === ГОРИЗОНТАЛЬНАЯ ОРИЕНТАЦИЯ (LANDSCAPE) === */
@media (max-width: 768px) and (orientation: landscape) {

    /* Основной контейнер - оптимизация под широкий экран */
    .periodic-table-container {
        justify-content: flex-start !important;
        padding-left: 10px !important;
        padding-right: 10px !important;
    }

    /* Таблица растворимости - адаптация под горизонтальную ориентацию */
    #solubility-modal .modal-content {
        max-height: 90vh !important;
        height: 90vh !important;
    }

    /* Модалка "Реакции" - размер как у таблицы растворимости */
    #reactions-modal .modal-content {
        max-height: 90vh !important;
        height: 90vh !important;
    }

    /* Панель уравнителя - оптимальное расположение */
    .balancer-panel {
        width: 90% !important;
        left: 5% !important;
        right: 5% !important;
        bottom: env(safe-area-inset-bottom, 10px) !important;
        max-height: 35vh !important;
        border-radius: 15px 15px 0 0 !important;
    }

    /* FAB-меню - перемещение для лучшего доступа */
    .fab-container {
        bottom: env(safe-area-inset-bottom, 15px) !important;
        right: 15px !important;
        left: auto !important;
        flex-direction: column !important;
    }

    /* Калькулятор - полная ширина */
    .calc-panel {
        width: 95% !important;
        left: 2.5% !important;
        right: 2.5% !important;
        bottom: calc(env(safe-area-inset-bottom, 10px) + 10px) !important;
        max-height: 35vh !important;
        border-radius: 15px 15px 0 0 !important;
    }

    /* Отступы для безопасной области */
    body {
        padding-bottom: env(safe-area-inset-bottom, 0px) !important;
    }
}

/* Добавить после существующих медиа-запросов */
@media (max-width: 768px) and (orientation: landscape) {
    #mobile-table-wrapper {
        transform: scale(0.85) !important;
        transform-origin: top left !important;
        margin-top: -20px !important;
    }

    .periodic-table-container {
        transform: none !important;
    }

    /* Уменьшить отступы для экономии места */
    .table-wrapper {
        margin-bottom: 5px !important;
    }

    /* Скрыть не критичные элементы в горизонтальном режиме */
    .below-table-content {
        display: none !important;
    }
}

============================================================
ФАЙЛ: .\css\calculator.css
============================================================

/* =========================================
   CALCULATOR.CSS — Оригинальный компактный стиль
   ========================================= */

/* =========================================
   ДЕСКТОП ВЕРСИЯ
   ========================================= */
@media (min-width: 1025px) {
    .calc-panel {
        position: fixed !important;
        z-index: 60000;
        display: none;
        flex-direction: column;
        padding: 10px;
        box-sizing: border-box;
        background: #ffffff;
        border: 2px solid #2196F3;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        opacity: 0;
        transform: translateY(12px) scale(0.985);
        will-change: transform, opacity;
    }

    .calc-panel.active {
        display: flex;
        animation: calcPanelOpen var(--flip-move-ms) var(--flip-ease) forwards;
    }

    .calc-panel.active.closing {
        animation: calcPanelClose var(--flip-move-ms) var(--flip-ease) forwards;
    }
}

@keyframes calcPanelOpen {
    from {
        opacity: 0;
        transform: translateY(12px) scale(0.985);
    }

    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

@keyframes calcPanelClose {
    from {
        opacity: 1;
        transform: translateY(0) scale(1);
    }

    to {
        opacity: 0;
        transform: translateY(12px) scale(0.985);
    }
}


/* =========================================
   ОБЩИЕ СТИЛИ
   ========================================= */
.calc-header {
    flex: 0 0 28px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 10px;
    background: #f7f7f7;
    border-bottom: 1px solid #e0e0e0;
}

.calc-header h3 {
    margin: 0;
    font-size: 12px;
    font-weight: bold;
    text-transform: uppercase;
    color: #666;
}

.close-calc-panel {
    font-size: 16px;
    cursor: pointer;
    color: #999;
    line-height: 1;
}

.close-calc-panel:hover {
    color: #d32f2f;
}

.drop-zone {
    flex: 1;
    position: relative;
    background: #ffffff;
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    gap: 4px;
    padding: 4px;
    overflow-y: auto;
    scrollbar-width: thin;
}

.drop-zone.drag-over {
    background: #e3f2fd;
    box-shadow: inset 0 0 0 2px #2196F3;
}

.drop-placeholder {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #aaa;
    font-size: 11px;
    text-align: center;
    pointer-events: none;
}

.calc-atom {
    height: 20px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 3px;
    padding: 0 4px;
    display: flex;
    align-items: center;
    gap: 2px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.calc-atom-symbol {
    font-size: 11px;
    font-weight: bold;
    color: #333;
}

.calc-controls {
    display: flex;
    align-items: center;
    gap: 1px;
}

.calc-atom-count {
    width: 20px;
    font-size: 11px;
    border: none;
    border-bottom: 1px solid #2196F3;
    text-align: center;
    background: transparent;
    color: #333;
    padding: 0;
    -moz-appearance: textfield;
}

.calc-atom-count:focus {
    outline: none;
    border-bottom-color: #1976D2;
}

.calc-btn-minus,
.calc-btn-plus {
    width: 14px;
    height: 14px;
    padding: 0;
    background: #e3f2fd;
    border: none;
    border-radius: 2px;
    font-size: 10px;
    font-weight: bold;
    color: #1976D2;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
}

.calc-atom-remove {
    font-size: 14px;
    color: #999;
    cursor: pointer;
    line-height: 1;
    margin-left: 2px;
}


#calc-result {
    flex: 0 0 32px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 10px;
    background: #f0f0f0;
    border-top: 1px solid #e0e0e0;
}


.mass-value {
    font-size: 14px;
    font-weight: bold;
    color: #2e7d32;
}

.unit {
    font-size: 11px;
    font-weight: normal;
    color: #666;
}

.clear-btn {
    padding: 4px 8px;
    background: #ff5252;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: 11px;
}

/* Тёмная тема */
body.dark-theme .calc-panel {
    background: #2d2d44;
    border-color: #444;
}

body.dark-theme .calc-header {
    background: #252535;
    border-bottom-color: #444;
}

body.dark-theme .drop-zone {
    background: #2d2d44;
}

body.dark-theme .calc-atom {
    background: #3d3d5c;
    border-color: #555;
    color: #fff;
}

body.dark-theme .calc-atom-symbol {
    color: #fff;
}

body.dark-theme .calc-atom-count {
    color: #fff;
}

body.dark-theme #calc-result {
    background: #252535;
    border-top-color: #444;
}

/* =========================================
   ДЕСКТОП — Увеличенный интерфейс (vw единицы)
   ========================================= */
@media (min-width: 1025px) {
    .calc-header {
        flex: 0 0 2.5vw;
        padding: 0 0.8vw;
    }

    .calc-header h3 {
        font-size: 1vw;
    }

    .close-calc-panel {
        font-size: 1.3vw;
    }

    .drop-zone {
        gap: 0.4vw;
        padding: 0.4vw;
    }

    .drop-placeholder {
        font-size: 0.9vw;
    }

    .calc-atom {
        height: 1.8vw;
        padding: 0 0.4vw;
        gap: 0.25vw;
        border-radius: 0.25vw;
    }

    .calc-atom-symbol {
        font-size: 1vw;
    }

    .calc-controls {
        gap: 0.15vw;
    }

    .calc-atom-count {
        width: 1.8vw;
        font-size: 1vw;
    }

    .calc-btn-minus,
    .calc-btn-plus {
        width: 1.3vw;
        height: 1.3vw;
        font-size: 0.9vw;
        border-radius: 0.2vw;
    }

    .calc-atom-remove {
        font-size: 1.2vw;
    }

    #calc-result {
        flex: 0 0 2.8vw;
        padding: 0 0.8vw;
    }

    .mass-value {
        font-size: 1.2vw;
    }

    .unit {
        font-size: 0.9vw;
    }

    .clear-btn {
        padding: 0.4vw 0.8vw;
        font-size: 0.9vw;
        border-radius: 0.25vw;
    }
}

/* =========================================
   МОБИЛЬНАЯ ВЕРСИЯ
   ========================================= */
@media (max-width: 1024px) {

    .calc-panel {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100% !important;
        box-sizing: border-box !important;
        margin: 0;

        min-height: 180px;
        height: calc(25vh + env(safe-area-inset-bottom, 0px)) !important;

        background: #ffffff;
        border: 2px solid #2196F3;
        border-bottom: none;
        border-radius: 20px 20px 0 0;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);

        display: none;
        flex-direction: column;

        padding: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));

        z-index: 60000;
        transform: translateY(100%);
        opacity: 0;
        will-change: transform, opacity;
    }

    .calc-panel.active {
        display: flex;
        animation: calcSheetOpen var(--flip-move-ms) var(--flip-ease) forwards;
    }

    .calc-panel.active.closing {
        animation: calcSheetClose var(--flip-move-ms) var(--flip-ease) forwards;
    }

    .calc-atom {
        height: 26px;
        padding: 0 6px;
    }

    /* --- WRAPPER ДЛЯ ТАБЛИЦЫ --- */
    #mobile-table-wrapper {
        display: flex;
        flex-direction: column;
        /* ВАЖНО: Выравнивание влево, чтобы был доступен правый скролл */
        align-items: flex-start !important;
        width: 100%;
        will-change: transform;
        backface-visibility: hidden;
    }

    #mobile-table-wrapper>.container,
    #mobile-table-wrapper>.lanthanides,
    #mobile-table-wrapper>.actinides {
        transform: none !important;
    }

    /* ИСПРАВЛЕНИЕ СКРОЛЛА: Разрешаем горизонтальную прокрутку, блокируем вертикальную */
    body.calc-active {
        overflow-y: hidden !important;
        /* Блокируем вертикальный скролл страницы */
        overflow-x: auto !important;
        /* Разрешаем горизонтальный */
        position: relative !important;
        /* Убираем fixed, чтобы скролл работал */
        height: 100% !important;
        width: 100% !important;
        touch-action: pan-x;
        /* Подсказка браузеру, что можно свайпать влево-вправо */
    }

    /* ИСПРАВЛЕНИЕ СКРОЛЛА: Разрешаем горизонтальную прокрутку, блокируем вертикальную */
    body.balancer-active {
        overflow-y: hidden !important;
        /* Блокируем вертикальный скролл страницы */
        overflow-x: auto !important;
        /* Разрешаем горизонтальный */
        position: relative !important;
        /* Убираем fixed, чтобы скролл работал */
        height: 100% !important;
        width: 100% !important;
        touch-action: pan-x;
        /* Подсказка браузеру, что можно свайпать влево-вправо */
    }
}

@keyframes calcSheetOpen {
    from {
        opacity: 0;
        transform: translateY(100%);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes calcSheetClose {
    from {
        opacity: 1;
        transform: translateY(0);
    }

    to {
        opacity: 0;
        transform: translateY(100%);
    }
}


============================================================
ФАЙЛ: .\css\electron-config.css
============================================================

/* =========================================
   ELECTRON-CONFIG.CSS — Строение атома (v2.0 — unified with advanced-modal)
   ========================================= */

/* Модальное окно (оверлей) */
#electron-config-modal {
    display: none;
    position: fixed;
    z-index: 120000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(3px);
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
    overscroll-behavior: contain;
}

/* Контент модального окна */
.electron-config-content {
    position: relative;
    background: var(--bg-color, #fff);

    /* Дизайн-токены (единые с advanced-modal) */
    --ec-text-primary: #1f2937;
    --ec-text-secondary: #334155;
    --ec-text-muted: #475569;
    --ec-label: #2f3f72;
    --ec-accent: #667eea;

    width: min(1100px, 95vw);
    max-height: 90vh;
    border-radius: 24px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    animation: electronConfigOpen 0.3s ease-out;
}

@keyframes electronConfigOpen {
    from {
        opacity: 0;
        transform: translateY(-50px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Кнопка закрытия */
.electron-config-close {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: rgba(255, 255, 255, 0.85);
    color: #222;
    font-size: 28px;
    line-height: 44px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2;
    transition: background 0.2s;
}

.electron-config-close:hover {
    background: rgba(255, 255, 255, 1);
}

/* Заголовок — градиент как у advanced-modal */
.electron-config-header {
    padding: 20px 25px;
    padding-right: 60px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    flex-shrink: 0;
}

.electron-config-title {
    display: flex;
    align-items: center;
    font-size: 28px;
    font-weight: 700;
}

.electron-config-subtitle {
    font-size: 16px;
    opacity: 0.85;
    margin-top: 4px;
    text-align: center;
    color: rgba(255, 255, 255, 0.85);
    font-weight: 600;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Компактный заголовок */
.electron-config-content.compact-header .electron-config-header {
    padding: 12px 22px;
    padding-right: 58px;
}

.electron-config-content.compact-header .electron-config-title {
    font-size: 22px;
    gap: 8px;
}

.electron-config-content.compact-header .electron-config-subtitle {
    font-size: 13px;
}

/* Основной контент (скроллируемая зона) */
.electron-config-main {
    flex: 1;
    overflow-y: auto;
    padding: 25px;
    display: flex;
    flex-direction: column;
    gap: 22px;
    min-height: 0;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
}

/* Кастомные скроллбары */
.electron-config-main::-webkit-scrollbar {
    width: 6px;
}

.electron-config-main::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.03);
    border-radius: 3px;
}

.electron-config-main::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #667eea, #764ba2);
    border-radius: 3px;
}

.electron-config-main::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #5a67d8, #6b46c1);
}

/* Сетка: левая панель + орбитали */
.electron-config-body {
    display: grid;
    grid-template-columns: 220px 1fr;
    gap: 24px;
    align-items: start;
}

/* Левая панель — символ, заряд, оболочки */
.electron-config-left {
    background: rgba(102, 126, 234, 0.08);
    border-radius: 16px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.electron-config-symbol {
    display: flex;
    align-items: baseline;
    gap: 10px;
}

.electron-config-symbol .symbol {
    font-size: 56px;
    font-weight: 700;
    color: var(--ec-accent);
    text-shadow: none;
}

.electron-config-symbol .number {
    font-size: 16px;
    font-weight: 700;
    color: var(--ec-text-primary);
    padding: 4px 10px;
    border-radius: 999px;
    background: rgba(102, 126, 234, 0.12);
}

.electron-config-meta {
    display: flex;
    gap: 12px;
    align-items: center;
    font-weight: 600;
    color: var(--ec-text-muted);
}

.electron-config-meta .charge {
    font-size: 15px;
}

.electron-config-meta .mass {
    font-size: 15px;
}

.electron-shells {
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-weight: 700;
    color: var(--ec-text-primary);
}

.shell-level {
    display: flex;
    align-items: center;
    gap: 8px;
}

.shell-number {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: rgba(102, 126, 234, 0.12);
    color: var(--ec-text-muted);
    font-size: 11px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.shell-electrons {
    padding: 2px 8px;
    border-radius: 8px;
    background: rgba(102, 126, 234, 0.1);
    font-size: 13px;
}

/* Правая панель — орбитали */
.electron-config-right {
    background: #f8f9fc;
    border-radius: 16px;
    border: 1px solid rgba(102, 126, 234, 0.12);
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.orbital-row {
    display: grid;
    grid-template-columns: 70px 1fr;
    gap: 12px;
    align-items: center;
    margin-left: calc(var(--step-index) * 18px);
}

.orbital-label {
    font-weight: 700;
    color: var(--ec-text-primary);
    font-size: 13px;
}

.orbital-label sup {
    font-size: 10px;
}

.orbital-boxes {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}

.orbital-box {
    width: 26px;
    height: 18px;
    border: 1px solid rgba(102, 126, 234, 0.4);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 2px;
    background: #ffffff;
    box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.5);
}

.orbital-box.filled {
    border-color: rgba(102, 126, 234, 0.6);
    background: rgba(102, 126, 234, 0.06);
}

.orbital-arrow {
    font-size: 12px;
    line-height: 1;
    color: var(--ec-accent);
}

.orbital-arrow.down {
    color: #764ba2;
}

/* Футер — формулы, валентность */
.electron-config-footer {
    background: #f5f6fa;
    border-radius: 16px;
    padding: 16px 18px;
    display: flex;
    flex-direction: column;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.electron-config-section-title {
    margin: 0 0 5px 0;
    font-size: 14px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--ec-text-primary);
    opacity: 0.9;
}

.electron-config-footer-divider {
    height: 1px;
    background: rgba(0, 0, 0, 0.1);
    margin: 2px 0;
}

.electron-meta-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: baseline;
}

.electron-meta-row .label {
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    color: var(--ec-label);
    font-weight: 700;
}

.electron-meta-row .value {
    font-size: 16px;
    font-weight: 600;
    color: var(--ec-text-primary);
    line-height: 1.35;
}

.electron-config-empty {
    padding: 14px 16px;
    border-radius: 12px;
    background: rgba(102, 126, 234, 0.08);
    color: var(--ec-text-secondary);
    font-weight: 600;
}

/* =========================================
   ТЁМНАЯ ТЕМА (единая палитра с advanced-modal)
   ========================================= */
body.dark-theme #electron-config-modal {
    background-color: rgba(0, 0, 0, 0.75);
}

body.dark-theme .electron-config-content {
    background: #2d2d44;
    --ec-text-primary: #f4f7ff;
    --ec-text-secondary: #dbe3ff;
    --ec-text-muted: #c4d1f8;
    --ec-label: #b9c7ff;
    --ec-accent: #88a4f7;
}

body.dark-theme .electron-config-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

body.dark-theme .electron-config-left {
    background: rgba(102, 126, 234, 0.12);
}

body.dark-theme .electron-config-meta {
    color: var(--ec-text-muted);
}

body.dark-theme .electron-config-symbol .symbol {
    color: var(--ec-accent);
}

body.dark-theme .electron-config-symbol .number {
    color: var(--ec-text-primary);
    background: rgba(136, 164, 247, 0.15);
}

body.dark-theme .electron-shells {
    color: var(--ec-text-primary);
}

body.dark-theme .shell-number {
    background: rgba(136, 164, 247, 0.15);
    color: var(--ec-text-muted);
}

body.dark-theme .shell-electrons {
    background: rgba(136, 164, 247, 0.15);
}

body.dark-theme .electron-config-right {
    background: rgba(45, 45, 68, 0.6);
    border-color: rgba(255, 255, 255, 0.08);
}

body.dark-theme .orbital-label {
    color: var(--ec-text-primary);
}

body.dark-theme .orbital-box {
    background: rgba(12, 14, 18, 0.6);
    border-color: rgba(136, 164, 247, 0.4);
}

body.dark-theme .orbital-box.filled {
    background: rgba(102, 126, 234, 0.18);
}

body.dark-theme .orbital-arrow {
    color: var(--ec-accent);
}

body.dark-theme .orbital-arrow.down {
    color: #a78bfa;
}

body.dark-theme .electron-config-footer {
    background: rgba(255, 255, 255, 0.05);
}

body.dark-theme .electron-config-footer-divider {
    background: rgba(255, 255, 255, 0.1);
}

body.dark-theme .electron-meta-row .label {
    color: var(--ec-label);
}

body.dark-theme .electron-meta-row .value {
    color: var(--ec-text-primary);
}

body.dark-theme .electron-config-empty {
    background: rgba(136, 164, 247, 0.1);
    color: var(--ec-text-secondary);
}

/* Скроллбары — тёмная тема */
body.dark-theme .electron-config-main::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.03);
}

body.dark-theme .electron-config-main::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #818cf8, #a78bfa);
}

body.dark-theme .electron-config-main::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
}

/* =========================================
   АДАПТИВ
   ========================================= */
@media (max-width: 900px) {
    .electron-config-body {
        grid-template-columns: 1fr;
    }

    .electron-config-left {
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
    }

    .electron-shells {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 6px;
    }

    .orbital-row {
        margin-left: 0;
    }
}

@media (max-width: 768px) {
    #electron-config-modal {
        padding: 10px;
    }

    .electron-config-content {
        width: 100%;
        max-height: 100%;
        border-radius: 18px;
    }

    .electron-config-header {
        padding: 15px 20px;
        padding-right: 50px;
    }

    .electron-config-title {
        font-size: 22px;
    }

    .electron-config-main {
        padding: 20px 15px;
    }
}

@media (max-width: 520px) {
    .electron-config-symbol .symbol {
        font-size: 40px;
    }

    .electron-config-right {
        padding: 12px;
    }

    .orbital-row {
        grid-template-columns: 60px 1fr;
    }

    .orbital-box {
        width: 22px;
        height: 16px;
    }
}

/* =========================================
   БОЛЬШИЕ ЭКРАНЫ
   ========================================= */
@media (min-width: 1400px) {
    .electron-config-content {
        width: min(1100px, 95vw);
        max-height: 90vh;
    }

    .electron-config-header {
        padding: 30px 40px;
        padding-right: 80px;
    }

    .electron-config-title {
        font-size: 38px;
    }

    .electron-config-subtitle {
        font-size: 22px;
    }

    .electron-config-main {
        padding: 40px;
    }

    .electron-config-symbol .symbol {
        font-size: 72px;
    }

    .electron-config-symbol .number {
        font-size: 20px;
    }

    .electron-config-meta .charge,
    .electron-config-meta .mass {
        font-size: 18px;
    }

    .electron-shells span {
        font-size: 16px;
        padding: 6px 10px;
    }

    .orbital-label {
        font-size: 16px;
    }

    .orbital-box {
        width: 32px;
        height: 22px;
    }

    .orbital-arrow {
        font-size: 14px;
    }

    .electron-meta-row .label {
        font-size: 15px;
    }

    .electron-meta-row .value {
        font-size: 20px;
    }

    .electron-config-close {
        width: 45px;
        height: 45px;
        font-size: 36px;
        top: 18px;
        right: 18px;
    }
}

@media (min-width: 1900px) {
    .electron-config-content {
        width: min(1100px, 95vw);
        max-height: 90vh;
    }

    .electron-config-header {
        padding: 35px 50px;
        padding-right: 90px;
    }

    .electron-config-title {
        font-size: 44px;
    }

    .electron-config-subtitle {
        font-size: 26px;
    }

    .electron-config-main {
        padding: 50px;
    }

    .electron-config-symbol .symbol {
        font-size: 84px;
    }

    .electron-config-symbol .number {
        font-size: 24px;
    }

    .electron-config-meta .charge,
    .electron-config-meta .mass {
        font-size: 20px;
    }

    .electron-shells span {
        font-size: 18px;
        padding: 8px 12px;
    }

    .orbital-label {
        font-size: 18px;
    }

    .orbital-box {
        width: 36px;
        height: 24px;
    }

    .orbital-arrow {
        font-size: 16px;
    }

    .electron-meta-row .label {
        font-size: 17px;
    }

    .electron-meta-row .value {
        font-size: 24px;
    }

    .electron-config-close {
        width: 50px;
        height: 50px;
        font-size: 40px;
        top: 20px;
        right: 20px;
    }
}

============================================================
ФАЙЛ: .\css\fab.css
============================================================

/* =========================================
   FAB.CSS — Плавающее меню (FAB)
   ========================================= */

/* --- Контейнер FAB --- */
.fab-container {
    position: fixed;
    bottom: 30px;
    right: 30px;
    z-index: 50000;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 15px;
    pointer-events: none;
}

/* --- Главная кнопка --- */
.fab-main {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: #2196F3;
    color: white;
    border: none;
    font-size: 24px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    transition: transform 0.3s, background 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
}

.fab-main:hover {
    transform: scale(1.1);
    background: #1976D2;
}

.fab-container.active .fab-main {
    transform: rotate(90deg);
    background: #f44336;
}

/* --- Иконки главной кнопки (Desktop/Base) --- */
.icon-close {
    display: none;
}

.fab-container.active .icon-menu {
    display: none;
}

.fab-container.active .icon-close {
    display: block;
}

/* --- Опции меню --- */
.fab-options {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: flex-end;
    pointer-events: none;
}

.fab-container.active .fab-options {
    pointer-events: auto;
}

/* --- Строка опции --- */
.fab-option {
    display: flex;
    align-items: center;
    gap: 10px;
    opacity: 0;
    transform: translateY(-20px) scale(0.8);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    width: fit-content;
    margin-left: auto;
    pointer-events: none;
}

.fab-container.active .fab-option {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
}

.fab-container.active .fab-option:nth-child(1) { transition-delay: 0.05s; }
.fab-container.active .fab-option:nth-child(2) { transition-delay: 0.1s; }
.fab-container.active .fab-option:nth-child(3) { transition-delay: 0.15s; }
.fab-container.active .fab-option:nth-child(4) { transition-delay: 0.2s; }

/* --- Кнопка опции --- */
.fab-btn {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: none;
    background: #fff;
    color: #333;
    font-size: 22px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    cursor: pointer;
    transition: background 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.fab-option:hover .fab-btn {
    background: #eee;
}

/* --- Лейбл опции --- */
.fab-label {
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 14px;
    white-space: nowrap;
    opacity: 0;
    transform: translateX(10px);
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
    position: absolute;
    right: 60px;
    top: 50%;
    transform: translateY(-50%) translateX(10px);
}

.fab-btn:hover + .fab-label,
.fab-option:hover .fab-label {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
}

/* Тёмная тема */
body.dark-theme .fab-main {
    background: #64B5F6;
    color: #1a1a2e;
}
body.dark-theme .fab-main:hover {
    background: #90CAF9;
}
body.dark-theme .fab-container.active .fab-main {
    background: #ef5350;
}
body.dark-theme .fab-btn {
    background: #2d2d44;
    color: #fff;
    box-shadow: 0 2px 10px rgba(0,0,0,0.4);
}
body.dark-theme .fab-option:hover .fab-btn {
    background: #3d3d5c;
}
body.dark-theme .fab-label {
    background: rgba(255,255,255,0.9);
    color: #1a1a2e;
}

.fab-btn svg,
.fab-main svg {
    width: 24px;
    height: 24px;
    display: block;
}

/* Переключение иконок темы */
.fab-theme-btn .icon-sun { display: none; }
body.dark-theme .fab-theme-btn .icon-moon { display: none; }
body.dark-theme .fab-theme-btn .icon-sun { display: block; }


/* =========================================
   АДАПТИВ (MOBILE)
   ========================================= */
@media (max-width: 1024px) {
   .fab-container {
       position: fixed;
       bottom: 20px;
       left: 20px;
       right: auto;
       top: auto;
       flex-direction: row-reverse;
       align-items: center;
       gap: 1.5vh;
       z-index: 50000 !important;
   }

   /* Скрываем кнопку темы */
   .fab-options .fab-option:first-child {
       display: none !important;
   }

   .fab-options {
       flex-direction: row-reverse;
       align-items: center;
       gap: 1.5vh;
   }

   .fab-option {
       flex-direction: column;
       transform: translateX(-20px) scale(0.8);
       width: fit-content;
       margin-left: 0;
   }

   .fab-container.active .fab-option {
       transform: translateX(0) scale(1);
   }

   .fab-label {
       display: none;
   }

   /* --- РАЗМЕРЫ КНОПОК --- */
   .fab-main {
       width: 14vmin;
       height: 14vmin;
       min-width: 45px;
       min-height: 45px;
       max-width: 65px;
       max-height: 65px;
       font-size: 22px;
   }

   .fab-btn {
       width: 12vmin;
       height: 12vmin;
       min-width: 40px;
       min-height: 40px;
       max-width: 55px;
       max-height: 55px;
       font-size: 20px;
   }

   /* --- ИСПРАВЛЕНИЕ ИКОНОК (РАЗМЕР И ЦЕНТРОВКА) --- */
   
   /* 1. Делаем контейнеры (span) внутри главной кнопки гибкими */
   /* Это важно, чтобы SVG встал ровно по центру */
   .fab-main .icon-menu,
   .fab-main .icon-close {
       width: 100%;
       height: 100%;
       align-items: center;
       justify-content: center;
       /* display будет переключаться ниже */
   }

   /* 2. Переопределяем логику скрытия/показа для использования FLEX вместо BLOCK */
   /* По умолчанию (меню закрыто) */
   .fab-main .icon-menu { display: flex; }
   .fab-main .icon-close { display: none; }

   /* Когда меню открыто */
   .fab-container.active .icon-menu { display: none; }
   .fab-container.active .icon-close { display: flex; }

   /* 3. Увеличиваем размер SVG и гарантируем блочность */
   .fab-main svg,
   .fab-btn svg {
       width: 85%;  /* Увеличили до 85% для лучшей видимости на iPhone */
       height: 85%;
       display: block;
       margin: auto; /* На всякий случай */
       min-width: 24px; /* Минимальный размер для обеспечения видимости на iPhone */
       min-height: 24px; /* Минимальный размер для обеспечения видимости на iPhone */
   }

   /* Уменьшаем размер иконок на Android устройствах */
   @media screen and (-webkit-device-pixel-ratio: 1.5),
          screen and (-webkit-device-pixel-ratio: 2),
          screen and (-webkit-device-pixel-ratio: 3) {
       /* Проверяем, является ли устройство Android */
       body:not(.device-iphone):not(.device-ipad) .fab-main svg,
       body:not(.device-iphone):not(.device-ipad) .fab-btn svg {
           width: 75% !important;  /* Уменьшаем до 75% на Android */
           height: 75% !important;
           min-width: 20px !important; /* Уменьшаем минимальный размер */
           min-height: 20px !important;
       }
   }

    /* Дополнительные стили для iPhone - увеличиваем размер иконок */
    body.device-iphone .fab-main svg,
    body.device-iphone .fab-btn svg {
        width: 90% !important;  /* Увеличиваем до 90% на iPhone */
        height: 90% !important;
        min-width: 28px !important;
        min-height: 28px !important;
    }
}

@media (min-width: 1025px) {
    .fab-container {
        bottom: 30px !important;
        right: 30px !important;
        left: auto !important;
    }
}


============================================================
ФАЙЛ: .\css\filters.css
============================================================

/* =========================================
   FILTERS.CSS — Панель фильтров
   ========================================= */

.filters-panel {
    position: fixed;
    bottom: 100px;
    right: 100px;

    /* УВЕЛИЧИЛИ ШИРИНУ, чтобы кнопки влезали даже со скроллом */
    width: 340px;

    max-height: 70vh;
    overflow-y: auto;

    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
    z-index: 51000;
    display: none;
    flex-direction: column;

    opacity: 0;
    transform: translateY(16px) scale(0.985);
    will-change: transform, opacity;

    -ms-overflow-style: auto;
    /* IE and Edge */
    scrollbar-width: thin;
    /* Firefox */
}

/* Скроллбары (Chrome/Safari/Webkit) — для содержимого панели фильтров */
/* Используем общий стиль скроллбара, но с меньшей шириной для компактности */
.filters-panel::-webkit-scrollbar {
    width: 6px;
}

.filters-panel::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.03);
    border-radius: 3px;
}

.filters-panel::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #2196F3, #64B5F6);
    border-radius: 3px;
}

.filters-panel::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #1976D2, #2196F3);
}

/* Тёмная тема скроллбара */
body.dark-theme .filters-panel::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.03);
}

body.dark-theme .filters-panel::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #64B5F6, #90CAF9);
}

body.dark-theme .filters-panel::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #42A5F5, #64B5F6);
}

.filters-panel.active {
    display: flex;
    animation: filtersOpen var(--flip-move-ms) var(--flip-ease) forwards;
}

.filters-panel.active.closing {
    animation: filtersClose var(--flip-move-ms) var(--flip-ease) forwards;
}

@keyframes filtersOpen {
    from {
        opacity: 0;
        transform: translateY(16px) scale(0.985);
    }

    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

@keyframes filtersClose {
    from {
        opacity: 1;
        transform: translateY(0) scale(1);
    }

    to {
        opacity: 0;
        transform: translateY(16px) scale(0.985);
    }
}

/* Шапка */
.filters-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    background: #f5f5f5;
    border-bottom: 1px solid #e0e0e0;
}

.filters-header h3 {
    margin: 0;
    font-size: 16px;
    color: #333;
}

.close-filters {
    font-size: 18px;
    cursor: pointer;
    color: #999;
    line-height: 1;
}

.close-filters:hover {
    color: #333;
}

/* Секция */
.filters-section {
    padding: 15px;
}

.filters-section h4 {
    margin: 0 0 10px 0;
    font-size: 13px;
    color: #666;
    text-transform: uppercase;
}

/* Кнопки фильтров */
.filter-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.filter-btn {
    padding: 6px 12px;
    font-size: 12px;
    border: 2px solid #ddd;
    border-radius: 20px;
    background: #fff;
    color: #555;
    cursor: pointer;
    transition: all 0.2s;
}

.filter-btn:hover {
    border-color: #2196F3;
    color: #2196F3;
}

.filter-btn.active {
    background: #2196F3;
    border-color: #2196F3;
    color: #fff;
}

/* Цвета кнопок по категориям */
.filter-btn[data-filter="alkali-metal"].active {
    background: #ff9999;
    border-color: #ff9999;
    color: #333;
}

.filter-btn[data-filter="alkaline-earth-metal"].active {
    background: #ffcc99;
    border-color: #ffcc99;
    color: #333;
}

.filter-btn[data-filter="transition-metal"].active {
    background: #ffff99;
    border-color: #ffff99;
    color: #333;
}

.filter-btn[data-filter="post-transition-metal"].active {
    background: #ccff99;
    border-color: #ccff99;
    color: #333;
}

.filter-btn[data-filter="metalloid"].active {
    background: #99ffcc;
    border-color: #99ffcc;
    color: #333;
}

.filter-btn[data-filter="nonmetal"].active {
    background: #99ffff;
    border-color: #99ffff;
    color: #333;
}

.filter-btn[data-filter="halogen"].active {
    background: #99ccff;
    border-color: #99ccff;
    color: #333;
}

.filter-btn[data-filter="noble-gas"].active {
    background: #cc99ff;
    border-color: #cc99ff;
    color: #333;
}

.filter-btn[data-filter="lanthanide"].active {
    background: #ff99cc;
    border-color: #ff99cc;
    color: #333;
}

.filter-btn[data-filter="actinide"].active {
    background: #ff99ff;
    border-color: #ff99ff;
    color: #333;
}

.filter-btn[data-filter="unknown"].active {
    background: #e0e0e0;
    border-color: #e0e0e0;
    color: #333;
}

/* Цвета кнопок для фильтров растворимости */
.filter-btn[data-solubility="Р"].active {
    background: #4CAF50;
    border-color: #4CAF50;
    color: #fff;
}

.filter-btn[data-solubility="М"].active {
    background: #FFC107;
    border-color: #FFC107;
    color: #333;
}

.filter-btn[data-solubility="Н"].active {
    background: #F44336;
    border-color: #F44336;
    color: #fff;
}

.filter-btn[data-solubility="-"].active {
    background: #9E9E9E;
    border-color: #9E9E9E;
    color: #fff;
}

/* Цвета кнопок для фильтров по цветам */
.filter-btn[data-color-name="Бесцветный"]:active,
.filter-btn[data-color-name="Бесцветный"].active {
    background: #f0f9ff;
    border-color: #90caf9;
    color: #000;
}

.filter-btn[data-color-name="Белый"]:active,
.filter-btn[data-color-name="Белый"].active {
    background: #ffffff;
    border-color: #cccccc;
    color: #000;
}


/* Кнопка сброса */
.filters-actions {
    padding: 10px 15px 15px;
}

.filter-reset {
    width: 100%;
    padding: 8px;
    font-size: 14px;
    border: none;
    border-radius: 6px;
    background: #f44336;
    color: #fff;
    cursor: pointer;
    transition: background 0.2s;
}

.filter-reset:hover {
    background: #d32f2f;
}

/* =========================================
   ТЁМНАЯ ТЕМА
   ========================================= */
body.dark-theme .filters-panel {
    background: #2d2d44;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

/* Для темного режима используем общий стиль скроллбара */

body.dark-theme .filters-header {
    background: #252535;
    border-bottom-color: #444;
}

body.dark-theme .filters-header h3 {
    color: #eee;
}

body.dark-theme .close-filters {
    color: #666;
}

body.dark-theme .close-filters:hover {
    color: #fff;
}

body.dark-theme .filters-section h4 {
    color: #aaa;
}

body.dark-theme .filter-btn {
    background: #1f1f2e;
    border-color: #444;
    color: #ccc;
}

body.dark-theme .filter-btn:hover {
    border-color: #64B5F6;
    color: #64B5F6;
}

/* Тёмная тема — активные кнопки с тёмными цветами категорий */
body.dark-theme .filter-btn[data-filter="alkali-metal"].active {
    background: #8b3a3a;
    border-color: #8b3a3a;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="alkaline-earth-metal"].active {
    background: #8b6914;
    border-color: #8b6914;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="transition-metal"].active {
    background: #7a7a2e;
    border-color: #7a7a2e;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="post-transition-metal"].active {
    background: #4a7a2e;
    border-color: #4a7a2e;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="metalloid"].active {
    background: #2e7a5c;
    border-color: #2e7a5c;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="nonmetal"].active {
    background: #2e6a7a;
    border-color: #2e6a7a;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="halogen"].active {
    background: #2e4a7a;
    border-color: #2e4a7a;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="noble-gas"].active {
    background: #5c2e7a;
    border-color: #5c2e7a;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="lanthanide"].active {
    background: #7a2e5c;
    border-color: #7a2e5c;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="actinide"].active {
    background: #7a2e7a;
    border-color: #7a2e7a;
    color: #fff;
}

body.dark-theme .filter-btn[data-filter="unknown"].active {
    background: #4a4a4a;
    border-color: #4a4a4a;
    color: #fff;
}

/* Тёмная тема — активные кнопки для фильтров растворимости */
body.dark-theme .filter-btn[data-solubility="Р"].active {
    background: #81c784;
    border-color: #81c784;
    color: #000;
}

body.dark-theme .filter-btn[data-solubility="М"].active {
    background: #ffd54f;
    border-color: #ffd54f;
    color: #000;
}

body.dark-theme .filter-btn[data-solubility="Н"].active {
    background: #e57373;
    border-color: #e57373;
    color: #000;
}

body.dark-theme .filter-btn[data-solubility="-"].active {
    background: #b0b0b0;
    border-color: #b0b0b0;
    color: #000;
}

/* Тёмная тема — активные кнопки для фильтров по цветам */
body.dark-theme .filter-btn[data-color-name="Бесцветный"].active {
    background: #1a2a3a;
    border-color: #4a6a8a;
    color: #fff;
}

body.dark-theme .filter-btn[data-color-name="Белый"].active {
    background: #e8e8e8;
    border-color: #666666;
    color: #000;
}


/* =========================================
   ПОИСК
   ========================================= */
.search-section {
    border-bottom: 1px solid #e0e0e0;
    padding-bottom: 15px;
    margin-bottom: 0;
}

.search-wrapper {
    position: relative;
    display: flex;
    align-items: center;
}

#element-search {
    width: 100%;
    padding: 10px 35px 10px 12px;
    font-size: 14px;
    border: 2px solid #ddd;
    border-radius: 8px;
    outline: none;
    transition: border-color 0.2s;
}

#element-search:focus {
    border-color: #2196F3;
}

.search-clear {
    position: absolute;
    right: 8px;
    background: none;
    border: none;
    font-size: 16px;
    color: #999;
    cursor: pointer;
    padding: 5px;
    display: none;
}

.search-clear.visible {
    display: block;
}

.search-clear:hover {
    color: #333;
}

/* Результаты поиска */
.search-results {
    max-height: 30vh;
    /* Сделаем резиновую высоту вместо 150px */
    overflow-y: auto;
    margin-top: 10px;
}

.search-results:empty {
    display: none;
}

.search-result-item {
    padding: 8px 10px;
    margin-bottom: 5px;
    background: #f5f5f5;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s;
}

.search-result-item:hover {
    background: #e3f2fd;
}

.search-result-item .result-symbol {
    font-weight: bold;
    color: #2196F3;
    margin-right: 8px;
}

.search-result-item .result-context {
    font-size: 12px;
    color: #666;
    display: block;
    margin-top: 3px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Подсветка найденного текста */
.highlight {
    background: #ffeb3b;
    padding: 1px 3px;
    border-radius: 3px;
}

/* =========================================
   ПОИСК — ТЁМНАЯ ТЕМА
   ========================================= */
body.dark-theme .search-section {
    border-bottom-color: #444;
}

body.dark-theme #element-search {
    background: #1f1f2e;
    border-color: #444;
    color: #eee;
}

body.dark-theme #element-search:focus {
    border-color: #64B5F6;
}

body.dark-theme #element-search::placeholder {
    color: #666;
}

body.dark-theme .search-clear {
    color: #666;
}

body.dark-theme .search-clear:hover {
    color: #fff;
}

body.dark-theme .search-result-item {
    background: #1f1f2e;
}

body.dark-theme .search-result-item:hover {
    background: #2a3a4a;
}

body.dark-theme .search-result-item .result-symbol {
    color: #64B5F6;
}

body.dark-theme .search-result-item .result-context {
    color: #aaa;
}

body.dark-theme .highlight {
    background: #f9a825;
    color: #000;
}

.search-no-results {
    padding: 10px;
    text-align: center;
    color: #999;
    font-size: 13px;
}

body.dark-theme .search-no-results {
    color: #666;
}

.search-btn {
    position: absolute;
    right: 8px;
    width: 32px;
    height: 32px;
    background: #2196F3;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.search-btn:hover {
    background: #1976D2;
}

.search-btn svg {
    width: 18px;
    height: 18px;
    color: #fff;
}

/* Сдвигаем крестик левее */
.search-clear {
    right: 45px;
}

/* Увеличиваем отступ в инпуте */
#element-search {
    padding-right: 80px;
}

/* Тёмная тема */
body.dark-theme .search-btn {
    background: #64B5F6;
}

body.dark-theme .search-btn:hover {
    background: #90CAF9;
}



/* =========================================
   ПОДСВЕТКА НАЙДЕННОГО ЭЛЕМЕНТА
   ========================================= */
.element.search-highlight {
    position: relative !important;
    z-index: 10000 !important;
    animation: elementPulse 2s ease-in-out infinite !important;
    box-shadow: 0 0 0 4px #2196F3,
        0 0 20px rgba(33, 150, 243, 0.6),
        0 0 40px rgba(33, 150, 243, 0.4) !important;
    transform: scale(1.15) !important;
    border: 3px solid #2196F3 !important;
    transition: none !important;
}

/* Отменяем hover для подсвеченного элемента */
.element.search-highlight:hover {
    transform: scale(1.15) !important;
    box-shadow: 0 0 0 4px #2196F3,
        0 0 20px rgba(33, 150, 243, 0.6),
        0 0 40px rgba(33, 150, 243, 0.4) !important;
}

@keyframes elementPulse {

    0%,
    100% {
        box-shadow: 0 0 0 4px #2196F3,
            0 0 20px rgba(33, 150, 243, 0.6),
            0 0 40px rgba(33, 150, 243, 0.4);
        transform: scale(1.15);
    }

    50% {
        box-shadow: 0 0 0 6px #1976D2,
            0 0 30px rgba(25, 118, 210, 0.8),
            0 0 60px rgba(25, 118, 210, 0.5);
        transform: scale(1.2);
    }
}

/* Тёмная тема */
body.dark-theme .element.search-highlight {
    box-shadow: 0 0 0 4px #64B5F6,
        0 0 20px rgba(100, 181, 246, 0.6),
        0 0 40px rgba(100, 181, 246, 0.4) !important;
    border-color: #64B5F6 !important;
    animation: elementPulseDark 2s ease-in-out infinite !important;
}

body.dark-theme .element.search-highlight:hover {
    box-shadow: 0 0 0 4px #64B5F6,
        0 0 20px rgba(100, 181, 246, 0.6),
        0 0 40px rgba(100, 181, 246, 0.4) !important;
    transform: scale(1.15) !important;
}

@keyframes elementPulseDark {

    0%,
    100% {
        box-shadow: 0 0 0 4px #64B5F6,
            0 0 20px rgba(100, 181, 246, 0.6),
            0 0 40px rgba(100, 181, 246, 0.4);
        transform: scale(1.15);
    }

    50% {
        box-shadow: 0 0 0 6px #90CAF9,
            0 0 30px rgba(144, 202, 249, 0.8),
            0 0 60px rgba(144, 202, 249, 0.5);
        transform: scale(1.2);
    }
}

/* =========================================
   БОЛЬШИЕ ЭКРАНЫ (4K и подобные)
   ========================================= */
@media (min-width: 1920px) {

    /* Увеличенная ширина модалки, высота по контенту */
    .filters-panel {
        width: 28vw;
        border-radius: 1vw;
        bottom: 5vw;
        right: 5vw;
        max-height: none;
        overflow: hidden;
    }

    /* Шапка модалки */
    .filters-header {
        padding: 1.2vw 1.4vw;
    }

    .filters-header h3 {
        font-size: 1.4vw;
    }

    .close-filters {
        font-size: 1.5vw;
    }

    /* Секции */
    .filters-section {
        padding: 1.3vw 1.4vw;
    }

    .filters-section h4 {
        font-size: 1.1vw;
        margin-bottom: 0.9vw;
    }

    /* Кнопки фильтров */
    .filter-buttons {
        gap: 0.7vw;
    }

    .filter-btn {
        padding: 0.6vw 1.1vw;
        font-size: 1vw;
        border-radius: 1.5vw;
        border-width: 0.15vw;
    }

    /* Кнопка сброса */
    .filters-actions {
        padding: 0.9vw 1.4vw 1.4vw;
    }

    .filter-reset {
        padding: 0.8vw;
        font-size: 1.1vw;
        border-radius: 0.5vw;
    }

    /* Поиск */
    #element-search {
        padding: 0.9vw 5vw 0.9vw 1vw;
        font-size: 1.1vw;
        border-radius: 0.6vw;
    }

    .search-btn {
        width: 2.5vw;
        height: 2.5vw;
        border-radius: 0.5vw;
    }

    .search-btn svg {
        width: 1.4vw;
        height: 1.4vw;
    }

    .search-clear {
        font-size: 1.3vw;
        right: 3vw;
    }

    /* Результаты поиска */
    .search-result-item {
        padding: 0.7vw 0.9vw;
        margin-bottom: 0.5vw;
        border-radius: 0.5vw;
    }

    .search-result-item .result-symbol {
        font-size: 1vw;
    }

    .search-result-item .result-context {
        font-size: 0.9vw;
        margin-top: 0.3vw;
    }

    .search-no-results {
        font-size: 1vw;
        padding: 0.9vw;
    }
}

/* =========================================
   МОБИЛЬНАЯ ВЕРСИЯ
   ========================================= */
@media (max-width: 1024px) {
    .filters-panel {
        top: auto;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100% !important;
        max-width: 100% !important;
        height: auto;
        max-height: 85vh;
        border-radius: 20px 20px 0 0;
        transform: translateY(100%);
        margin: 0;
        border: none;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
        padding-bottom: env(safe-area-inset-bottom, 20px);
    }

    .filters-panel.active {
        animation: bottomSheetSlideUp 0.3s cubic-bezier(0.2, 0.0, 0.0, 1.0) forwards;
        display: flex;
        transform: translateY(0);
    }

    .filters-panel.active.closing {
        animation: bottomSheetSlideDown 0.25s cubic-bezier(0.2, 0.0, 0.0, 1.0) forwards;
    }

    @keyframes bottomSheetSlideUp {
        from {
            transform: translateY(100%);
            opacity: 1;
        }

        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    @keyframes bottomSheetSlideDown {
        from {
            transform: translateY(0);
            opacity: 1;
        }

        to {
            transform: translateY(100%);
            opacity: 1;
        }
    }

    /* Увеличиваем элементы для пальца */
    .filters-header {
        padding: 16px 20px;
    }

    .close-filters {
        font-size: 24px;
        padding: 5px;
    }

    .filter-btn {
        padding: 10px 16px;
        font-size: 14px;
        flex-grow: 1;
        /* Растягиваем кнопки */
        text-align: center;
    }

    .filter-buttons {
        gap: 10px;
    }

    .search-clear {
        padding: 10px;
    }
}

============================================================
ФАЙЛ: .\css\flip-modal.css
============================================================

/* =========================================
   FLIP-MODAL.CSS — Улучшенные анимации модалок
   с backdrop-blur эффектом
   ========================================= */

/* =========================================
   ОСНОВНАЯ МОДАЛКА ЭЛЕМЕНТА (#modal)
   ========================================= */

/* Backdrop blur для основной модалки */
#modal {
    backdrop-filter: blur(0px);
    -webkit-backdrop-filter: blur(0px);
    transition:
        backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease),
        -webkit-backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease);
}

#modal[style*="display: flex"],
#modal[style*="display:flex"] {
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

/* Улучшенная анимация открытия модалки */
#modal .modal-content {
    animation: modalOpenEnhanced var(--flip-move-ms) var(--flip-ease) forwards;
}

#modal.closing .modal-content {
    animation: modalCloseEnhanced var(--flip-move-ms) var(--flip-ease) forwards;
}

@keyframes modalOpenEnhanced {
    0% {
        opacity: 0;
        transform: translate(var(--start-x, 0), var(--start-y, 0)) scale(0.3);
        border-radius: 24px;
    }
    60% {
        opacity: 1;
        border-radius: 16px;
    }
    100% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
        border-radius: 12px;
    }
}

@keyframes modalCloseEnhanced {
    0% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(var(--start-x, 0), var(--start-y, 0)) scale(0.3);
    }
}

/* =========================================
   ТАБЛИЦА РАСТВОРИМОСТИ (#solubility-modal)
   ========================================= */

#solubility-modal {
    backdrop-filter: blur(0px);
    -webkit-backdrop-filter: blur(0px);
    transition:
        backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease),
        -webkit-backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease);
}

#solubility-modal[style*="display: flex"],
#solubility-modal[style*="display:flex"] {
    backdrop-filter: blur(9px);
    -webkit-backdrop-filter: blur(9px);
}

#solubility-modal .modal-content.solubility-content {
    animation: slideUpModal var(--flip-move-ms) var(--flip-ease) forwards;
}

#solubility-modal.closing .modal-content.solubility-content {
    animation: slideDownModal var(--flip-move-ms) var(--flip-ease) forwards;
}

/* =========================================
   РЕАКЦИИ (#reactions-modal)
   ========================================= */

#reactions-modal {
    backdrop-filter: blur(0px);
    -webkit-backdrop-filter: blur(0px);
    transition:
        backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease),
        -webkit-backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease);
}

#reactions-modal[style*="display: flex"],
#reactions-modal[style*="display:flex"] {
    backdrop-filter: blur(9px);
    -webkit-backdrop-filter: blur(9px);
}

#reactions-modal .modal-content.solubility-content {
    animation: slideUpModal var(--flip-move-ms) var(--flip-ease) forwards;
}

#reactions-modal.closing .modal-content.solubility-content {
    animation: slideDownModal var(--flip-move-ms) var(--flip-ease) forwards;
}
/* =========================================
   ПРОДВИНУТЫЙ РЕЖИМ (#advanced-substance-modal)
   ========================================= */

#advanced-substance-modal {
    backdrop-filter: blur(0px);
    -webkit-backdrop-filter: blur(0px);
    transition:
        backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease),
        -webkit-backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease);
}

#advanced-substance-modal[style*="display: flex"],
#advanced-substance-modal[style*="display:flex"] {
    backdrop-filter: blur(7px);
    -webkit-backdrop-filter: blur(7px);
}

#advanced-substance-modal .advanced-modal-content {
    animation: scaleInModal var(--flip-move-ms) var(--flip-ease) forwards;
    transform-origin: center center;
}

#advanced-substance-modal.closing .advanced-modal-content {
    animation: scaleOutModal var(--flip-move-ms) var(--flip-ease) forwards;
}

/* =========================================
   ЭЛЕКТРОННАЯ КОНФИГУРАЦИЯ (#electron-config-modal)
   ========================================= */

#electron-config-modal {
    backdrop-filter: blur(0px);
    -webkit-backdrop-filter: blur(0px);
    transition:
        backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease),
        -webkit-backdrop-filter var(--flip-backdrop-ms) var(--flip-backdrop-ease);
}

#electron-config-modal[style*="display: flex"],
#electron-config-modal[style*="display:flex"] {
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

#electron-config-modal .electron-config-content {
    animation: expandModal var(--flip-move-ms) var(--flip-ease) forwards;
}

#electron-config-modal.closing .electron-config-content {
    animation: collapseModal var(--flip-move-ms) var(--flip-ease) forwards;
}

/* =========================================
   ОБЩИЕ АНИМАЦИИ
   ========================================= */

@keyframes slideUpModal {
    0% {
        opacity: 0;
        transform: translateY(40px) scale(0.95);
    }
    100% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

@keyframes slideDownModal {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(30px) scale(0.96);
    }
}

@keyframes scaleInModal {
    0% {
        opacity: 0;
        transform: scale(0.85);
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes scaleOutModal {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    100% {
        opacity: 0;
        transform: scale(0.88);
    }
}

@keyframes expandModal {
    0% {
        opacity: 0;
        transform: scale(0.9) translateY(15px);
    }
    50% {
        opacity: 1;
    }
    100% {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

@keyframes collapseModal {
    0% {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
    100% {
        opacity: 0;
        transform: scale(0.96) translateY(12px);
    }
}

/* =========================================
   МОБИЛЬНЫЕ УСТРОЙСТВА
   ========================================= */

@media (max-width: 1024px) {
    /* На мобильных модалка выезжает снизу */
    #solubility-modal .modal-content.solubility-content {
        animation: slideUpMobile var(--flip-move-ms) var(--flip-ease) forwards;
    }

    #solubility-modal.closing .modal-content.solubility-content {
        animation: slideDownMobile var(--flip-move-ms) var(--flip-ease) forwards;
    }

    /* Основная модалка тоже выезжает снизу */
    #modal .modal-content {
        animation: slideUpMobile var(--flip-move-ms) var(--flip-ease) forwards;
    }

    #modal.closing .modal-content {
        animation: slideDownMobile var(--flip-move-ms) var(--flip-ease) forwards;
    }

    @keyframes slideUpMobile {
        0% {
            opacity: 0;
            transform: translateY(100%);
        }
        100% {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes slideDownMobile {
        0% {
            opacity: 1;
            transform: translateY(0);
        }
        100% {
            opacity: 0;
            transform: translateY(100%);
        }
    }
}

/* =========================================
   ТЁМНАЯ ТЕМА
   ========================================= */

.dark-theme #modal,
.dark-theme #solubility-modal,
.dark-theme #advanced-substance-modal,
.dark-theme #electron-config-modal {
    background-color: rgba(0, 0, 0, 0.65);
}

/* =========================================
   ОТКЛЮЧЕНИЕ АНИМАЦИЙ
   ========================================= */

/* Режим обоев — убираем всё для производительности */
body.wallpaper-optimized #modal,
body.wallpaper-optimized #solubility-modal,
body.wallpaper-optimized #advanced-substance-modal,
body.wallpaper-optimized #electron-config-modal {
    animation: none !important;
    transition: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
}

body.wallpaper-optimized #modal .modal-content,
body.wallpaper-optimized #solubility-modal .modal-content,
body.wallpaper-optimized #advanced-substance-modal .advanced-modal-content,
body.wallpaper-optimized #electron-config-modal .electron-config-content {
    animation: none !important;
}

/* Пользователи с настройкой reduced-motion */
@media (prefers-reduced-motion: reduce) {
    #modal,
    #solubility-modal,
    #advanced-substance-modal,
    #electron-config-modal {
        transition-duration: 0.01ms !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }

    #modal .modal-content,
    #solubility-modal .modal-content,
    #advanced-substance-modal .advanced-modal-content,
    #electron-config-modal .electron-config-content {
        animation: none !important;
    }
}


============================================================
ФАЙЛ: .\css\footer.css
============================================================

/* =========================================
   FOOTER.CSS — Download section styling
   ========================================= */

.download-app-section {
    margin: 80px auto 60px;
    padding: 0 20px;
    max-width: 800px;
}

.download-card {
    background: linear-gradient(135deg,
        rgba(102, 126, 234, 0.08) 0%,
        rgba(118, 75, 162, 0.08) 100%);
    border: 2px solid rgba(102, 126, 234, 0.2);
    border-radius: 24px;
    padding: 48px 40px;
    text-align: center;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
}

.download-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg,
        rgba(102, 126, 234, 0.05) 0%,
        rgba(118, 75, 162, 0.05) 100%);
    opacity: 0;
    transition: opacity 0.4s ease;
}

.download-card:hover {
    transform: translateY(-8px);
    border-color: rgba(102, 126, 234, 0.4);
    box-shadow: 0 20px 60px rgba(102, 126, 234, 0.15);
}

.download-card:hover::before {
    opacity: 1;
}

.download-icon {
    width: 80px;
    height: 80px;
    margin: 0 auto 24px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
    transition: all 0.3s ease;
}

.download-card:hover .download-icon {
    transform: scale(1.05) rotate(5deg);
    box-shadow: 0 12px 32px rgba(102, 126, 234, 0.4);
}

.download-icon svg {
    width: 40px;
    height: 40px;
    color: white;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

.download-card h3 {
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    position: relative;
}

.download-card > p {
    color: var(--text-secondary);
    font-size: 16px;
    line-height: 1.7;
    margin-bottom: 32px;
    max-width: 500px;
    margin-left: auto;
    margin-right: auto;
}

.download-btn-large {
    display: inline-flex;
    align-items: center;
    gap: 12px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 18px 48px;
    border-radius: 14px;
    text-decoration: none;
    font-size: 18px;
    font-weight: 600;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
    position: relative;
    overflow: hidden;
}

.download-btn-large::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg,
        transparent,
        rgba(255, 255, 255, 0.2),
        transparent);
    transition: left 0.5s ease;
}

.download-btn-large:hover::before {
    left: 100%;
}

.download-btn-large:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 12px 36px rgba(102, 126, 234, 0.5);
}

.download-btn-large:active {
    transform: translateY(0) scale(0.98);
}

.download-btn-large svg {
    width: 24px;
    height: 24px;
    transition: transform 0.3s ease;
}

.download-btn-large:hover svg {
    transform: translateY(2px);
}

.download-details {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
    margin-top: 24px;
    font-size: 14px;
    color: var(--text-secondary);
    flex-wrap: wrap;
}

.download-details span {
    opacity: 0.9;
    transition: opacity 0.3s ease;
}

.download-details span:nth-child(even) {
    opacity: 0.4;
}

.download-links {
    margin-top: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
}

.download-links a {
    color: #667eea;
    text-decoration: none;
    font-size: 14px;
    font-weight: 500;
    padding: 8px 16px;
    border-radius: 8px;
    transition: all 0.3s ease;
}

.download-links a:hover {
    background: rgba(102, 126, 234, 0.1);
    color: #764ba2;
}

.download-links span {
    color: var(--text-secondary);
    opacity: 0.3;
}

/* Dark theme */
body.dark-theme .download-card {
    background: linear-gradient(135deg,
        rgba(102, 126, 234, 0.12) 0%,
        rgba(118, 75, 162, 0.12) 100%);
    border-color: rgba(102, 126, 234, 0.3);
}

body.dark-theme .download-card:hover {
    border-color: rgba(102, 126, 234, 0.5);
    box-shadow: 0 20px 60px rgba(102, 126, 234, 0.2);
}

/* Mobile responsive */
@media (max-width: 768px) {
    .download-app-section {
        margin: 60px auto 40px;
        padding: 0 16px;
    }

    .download-card {
        padding: 40px 24px;
        border-radius: 20px;
    }

    .download-icon {
        width: 70px;
        height: 70px;
    }

    .download-icon svg {
        width: 35px;
        height: 35px;
    }

    .download-card h3 {
        font-size: 24px;
    }

    .download-card > p {
        font-size: 15px;
    }

    .download-btn-large {
        width: 100%;
        justify-content: center;
        padding: 16px 32px;
        font-size: 17px;
    }

    .download-details {
        flex-direction: column;
        gap: 8px;
    }

    .download-details span:nth-child(even) {
        display: none;
    }

    .download-links {
        flex-direction: column;
        gap: 4px;
    }

    .download-links span {
        display: none;
    }
}

/* Hide in Electron app */
body.electron-app .download-app-section {
    display: none;
}


============================================================
ФАЙЛ: .\css\illustrated-toggle.css
============================================================

/* =========================================
   ILLUSTRATED TOGGLE — Chemistry theme switch
   ========================================= */

#theme-toggle.chem-toggle {
    --chem-toggle-width: clamp(96px, 12vw, 120px);
    --chem-toggle-height: clamp(48px, 6vw, 60px);
    --chem-toggle-base-width: 200px;
    --chem-toggle-base-height: 100px;
    --chem-toggle-scene-scale: min(
        calc(var(--chem-toggle-width) / var(--chem-toggle-base-width)),
        calc(var(--chem-toggle-height) / var(--chem-toggle-base-height))
    );
    --chem-toggle-thumb: calc(var(--chem-toggle-height) * 0.72);
    --chem-toggle-pad: calc(var(--chem-toggle-height) * 0.11);
    --chem-toggle-thumb-offset: calc(var(--chem-toggle-height) * 0.15);
    --chem-toggle-thumb-shift: calc(var(--chem-toggle-width) - var(--chem-toggle-thumb) - (var(--chem-toggle-thumb-offset) * 2));

    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 5000;
    width: var(--chem-toggle-width);
    height: var(--chem-toggle-height);
    background: transparent;
    border: none;
    padding: 0;
    margin: 0;
    cursor: pointer;
    display: block;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    filter: drop-shadow(0 10px 30px rgba(33, 150, 243, 0.2));
    transition: transform 0.3s ease, filter 0.3s ease;
    transform-origin: top right;
}

#theme-toggle.chem-toggle:hover {
    filter: drop-shadow(0 15px 40px rgba(33, 150, 243, 0.3));
    transform: translateY(-2px);
}

#theme-toggle.chem-toggle:active {
    transform: translateY(0);
}

#theme-toggle.chem-toggle:focus-visible {
    outline: 3px solid #64B5F6;
    outline-offset: 8px;
    border-radius: 90px;
}

#theme-toggle.chem-toggle.spin {
    animation: none;
}

body.dark-theme #theme-toggle.chem-toggle {
    background: transparent;
    color: inherit;
}

.chem-toggle-track {
    width: 100%;
    height: 100%;
    border-radius: 999px;
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    border: 4px solid #ffffff;
    position: relative;
    overflow: hidden;
    box-shadow:
        0 8px 24px rgba(0, 0, 0, 0.12),
        inset 0 2px 8px rgba(255, 255, 255, 0.8),
        inset 0 -2px 8px rgba(0, 0, 0, 0.05);
    transition: box-shadow 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.chem-toggle-scene {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.chem-toggle-scene-content {
    width: var(--chem-toggle-base-width);
    height: var(--chem-toggle-base-height);
    position: relative;
    transform: scale(var(--chem-toggle-scene-scale));
    transform-origin: center;
}

.chem-toggle-thumb {
    width: var(--chem-toggle-thumb);
    height: var(--chem-toggle-thumb);
    border-radius: 50%;
    position: absolute;
    top: var(--chem-toggle-pad);
    left: var(--chem-toggle-thumb-offset);
    background: transparent;
    box-shadow: none;
    transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 100;
}

.chem-toggle.checked .chem-toggle-thumb {
    transform: translateX(var(--chem-toggle-thumb-shift));
}

.chem-toggle-thumb.chem-toggle-thumb-atom {
    display: grid;
    place-items: center;
}

/* ============ PERIODIC TABLE SCENE ============ */
.chem-toggle-scene-periodic {
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 40%, #90caf9 70%, #64b5f6 100%);
    position: relative;
    overflow: visible;
    transition: background 0.6s ease;
}

.chem-toggle.checked .chem-toggle-scene-periodic {
    background: linear-gradient(135deg, #0a0e27 0%, #1a237e 40%, #283593 70%, #3949ab 100%);
}

.chem-toggle-periodic-bg {
    position: absolute;
    width: 100%;
    height: 100%;
}

.chem-toggle-energy-wave {
    position: absolute;
    width: 100%;
    height: 30px;
    background: radial-gradient(ellipse at center, rgba(255, 193, 7, 0.1), transparent 70%);
    border-radius: 50%;
    opacity: 0;
    animation: chemEnergyPulse 4s infinite ease-in-out;
}

.chem-toggle.checked .chem-toggle-energy-wave {
    background: radial-gradient(ellipse at center, rgba(255, 193, 7, 0.2), transparent 70%);
}

.ct-wave-1 { top: 20%; animation-delay: 0s; }
.ct-wave-2 { top: 50%; animation-delay: 1.3s; }
.ct-wave-3 { top: 80%; animation-delay: 2.6s; }

@keyframes chemEnergyPulse {
    0% { opacity: 0; transform: scale(0.8); }
    50% { opacity: 0.4; transform: scale(1.2); }
    100% { opacity: 0; transform: scale(1.5); }
}

.chem-toggle-grid {
    position: absolute;
    top: 14%;
    left: 0%;
    right: auto;
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    grid-template-rows: repeat(2, minmax(0, 1fr));
    gap: 6px;
    width: 54%;
    height: 72%;
    z-index: 5;
    transform: translateX(42%);
    transition: transform 0.5s ease;
}

.chem-toggle.checked .chem-toggle-grid {
    transform: translateX(6%);
}

.chem-toggle-element {
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(210, 230, 255, 0.9));
    border: 2px solid rgba(30, 136, 229, 0.9);
    border-radius: 6px;
    position: relative;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
    box-shadow:
        0 6px 12px rgba(0, 0, 0, 0.18),
        inset 0 1px 0 rgba(255, 255, 255, 0.7);
}

.chem-toggle.checked .chem-toggle-element {
    background: linear-gradient(135deg, rgba(33, 52, 175, 0.9), rgba(19, 28, 90, 0.9));
    border: 2px solid rgba(144, 202, 249, 0.85);
    box-shadow:
        0 6px 16px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.15);
}

.chem-toggle-element::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transform: rotate(45deg);
    transition: all 0.5s;
}

.chem-toggle-element:hover::before {
    left: 100%;
}

.chem-toggle.checked .chem-toggle-element:nth-child(3n + 1) {
    background: linear-gradient(135deg, rgba(255, 193, 7, 0.8), rgba(255, 152, 0, 0.7));
    border-color: rgba(255, 193, 7, 1);
    box-shadow:
        0 0 12px rgba(255, 193, 7, 0.8),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

.chem-toggle-element-number {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 8px;
    color: rgba(15, 25, 60, 0.9);
    font-weight: 600;
    transition: color 0.4s ease;
}

.chem-toggle.checked .chem-toggle-element-number {
    color: rgba(255, 255, 255, 0.5);
}

.chem-toggle.checked .chem-toggle-element:nth-child(3n + 1) .chem-toggle-element-number {
    color: rgba(255, 255, 255, 0.9);
}

.chem-toggle-element-symbol {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 14px;
    font-weight: 800;
    color: rgba(10, 20, 60, 0.95);
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.7);
    transition: color 0.4s ease, text-shadow 0.4s ease;
}

.chem-toggle.checked .chem-toggle-element-symbol {
    color: rgba(255, 255, 255, 0.9);
    text-shadow: 0 0 4px rgba(100, 181, 246, 0.5);
}

.chem-toggle.checked .chem-toggle-element:nth-child(3n + 1) .chem-toggle-element-symbol {
    color: #ffffff;
    text-shadow: 0 0 8px rgba(255, 193, 7, 1);
}

.chem-toggle-element-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, rgba(100, 181, 246, 0.3), transparent 60%);
    opacity: 0;
    transition: opacity 0.3s;
}

.chem-toggle-element:hover .chem-toggle-element-glow {
    opacity: 1;
}

.chem-toggle-thumb .chem-toggle-atom {
    position: relative;
    width: calc(var(--chem-toggle-thumb) * 0.5);
    height: calc(var(--chem-toggle-thumb) * 0.5);
}

.chem-toggle-nucleus {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 18px;
    height: 18px;
    z-index: 20;
}

.chem-toggle-proton,
.chem-toggle-neutron {
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    animation: chemNucleusVibrate 2s infinite ease-in-out;
    transition: all 0.4s ease;
}

.chem-toggle-proton {
    background: radial-gradient(circle at 35% 35%, #ff8f00 0%, #ff6f00 100%);
    box-shadow:
        0 0 8px rgba(255, 143, 0, 0.8),
        inset 1px 1px 2px rgba(255, 255, 255, 0.4);
}

.chem-toggle-neutron {
    background: radial-gradient(circle at 35% 35%, #90a4ae 0%, #78909c 100%);
    box-shadow:
        0 0 6px rgba(144, 164, 174, 0.6),
        inset 1px 1px 2px rgba(255, 255, 255, 0.3);
}

.chem-toggle.checked .chem-toggle-proton {
    background: radial-gradient(circle at 35% 35%, #ff6f00 0%, #e65100 100%);
    box-shadow:
        0 0 12px rgba(255, 111, 0, 1),
        inset 1px 1px 2px rgba(255, 255, 255, 0.3);
}

.chem-toggle.checked .chem-toggle-neutron {
    background: radial-gradient(circle at 35% 35%, #78909c 0%, #546e7a 100%);
    box-shadow:
        0 0 8px rgba(120, 144, 156, 0.8),
        inset 1px 1px 2px rgba(255, 255, 255, 0.2);
}

.ct-p1 { top: 2px; left: 2px; animation-delay: 0s; }
.ct-p2 { top: 8px; left: 8px; animation-delay: 0.5s; }
.ct-n1 { top: 2px; left: 8px; animation-delay: 0.25s; }
.ct-n2 { top: 8px; left: 2px; animation-delay: 0.75s; }

@keyframes chemNucleusVibrate {
    0%, 100% { transform: translate(0, 0); }
    25% { transform: translate(0.5px, -0.5px); }
    50% { transform: translate(-0.5px, 0.5px); }
    75% { transform: translate(0.5px, 0.5px); }
}

.chem-toggle-nucleus-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 24px;
    height: 24px;
    background: radial-gradient(circle, rgba(255, 143, 0, 0.3), transparent 70%);
    border-radius: 50%;
    animation: chemNucleusGlow 2s infinite ease-in-out;
    transition: background 0.4s ease;
}

.chem-toggle.checked .chem-toggle-nucleus-glow {
    background: radial-gradient(circle, rgba(255, 111, 0, 0.5), transparent 70%);
}

@keyframes chemNucleusGlow {
    0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.4; }
    50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
}

.chem-toggle-orbit {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 1.5px solid rgba(33, 150, 243, 0.3);
    border-radius: 50%;
    box-shadow: 0 0 4px rgba(33, 150, 243, 0.2);
    transition: all 0.4s ease;
}

.chem-toggle.checked .chem-toggle-orbit {
    border-color: rgba(100, 181, 246, 0.4);
    box-shadow: 0 0 8px rgba(100, 181, 246, 0.3);
}

.ct-orbit-1 {
    width: 35px;
    height: 35px;
    animation: chemRotateOrbit 4s linear infinite;
}

.ct-orbit-2 {
    width: 55px;
    height: 55px;
    animation: chemRotateOrbit 6s linear infinite;
}

.ct-orbit-3 {
    width: 75px;
    height: 75px;
    animation: chemRotateOrbit 8s linear infinite;
}

.chem-toggle.checked .chem-toggle-orbit {
    border-width: 2px;
}

.chem-toggle.checked .chem-toggle-orbit {
    border-color: rgba(100, 181, 246, 0.7);
    box-shadow:
        0 0 12px rgba(100, 181, 246, 0.6),
        inset 0 0 8px rgba(100, 181, 246, 0.1);
}

.chem-toggle.checked .ct-orbit-1 { animation-duration: 2s; }
.chem-toggle.checked .ct-orbit-2 { animation-duration: 3s; }
.chem-toggle.checked .ct-orbit-3 { animation-duration: 4s; }

@keyframes chemRotateOrbit {
    0% { transform: translate(-50%, -50%) rotate(0deg); }
    100% { transform: translate(-50%, -50%) rotate(360deg); }
}

.chem-toggle-electron {
    position: absolute;
    width: 7px;
    height: 7px;
    background: radial-gradient(circle at 35% 35%, #64b5f6 0%, #2196f3 100%);
    border-radius: 50%;
    box-shadow:
        0 0 8px rgba(33, 150, 243, 0.8),
        inset 1px 1px 2px rgba(255, 255, 255, 0.5);
    z-index: 15;
    transition: all 0.4s ease;
}

.chem-toggle.checked .chem-toggle-electron {
    background: radial-gradient(circle at 35% 35%, #64b5f6 0%, #1e88e5 100%);
    box-shadow:
        0 0 12px rgba(100, 181, 246, 1),
        inset 1px 1px 2px rgba(255, 255, 255, 0.5);
}

.chem-toggle-electron-trail {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 12px;
    height: 12px;
    background: radial-gradient(circle, rgba(33, 150, 243, 0.3), transparent 60%);
    border-radius: 50%;
    animation: chemTrailPulse 1s infinite ease-out;
    transition: background 0.4s ease;
}

.chem-toggle.checked .chem-toggle-electron-trail {
    background: radial-gradient(circle, rgba(100, 181, 246, 0.4), transparent 60%);
}

@keyframes chemTrailPulse {
    0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.8; }
    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}

.ct-e1 { top: -3.5px; left: 50%; transform: translateX(-50%); }
.ct-e2 { top: -3.5px; left: 50%; transform: translateX(-50%); }
.ct-e3 { top: auto; bottom: -3.5px; left: 50%; transform: translateX(-50%); }
.ct-e4 { top: -3.5px; left: 50%; transform: translateX(-50%); }
.ct-e5 { top: 50%; right: -3.5px; transform: translateY(-50%); }

.chem-toggle.checked .chem-toggle-electron {
    animation: chemElectronGlow 1s infinite ease-in-out;
}

@keyframes chemElectronGlow {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}

.chem-toggle-quantum-field {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90px;
    height: 90px;
    background: radial-gradient(circle, rgba(33, 150, 243, 0.05), transparent 70%);
    border-radius: 50%;
    opacity: 0;
    animation: chemQuantumField 3s infinite ease-in-out;
    transition: background 0.4s ease, opacity 0.4s ease;
}

.chem-toggle.checked .chem-toggle-quantum-field {
    background: radial-gradient(circle, rgba(186, 104, 200, 0.15), transparent 70%);
    opacity: 1;
}

@keyframes chemQuantumField {
    0%, 100% { transform: translate(-50%, -50%) scale(0.9) rotate(0deg); }
    50% { transform: translate(-50%, -50%) scale(1.1) rotate(180deg); }
}

.chem-toggle-shell-info {
    position: absolute;
    left: 0%;
    top: 18%;
    opacity: 0;
    transform: translateX(10px);
    transition: opacity 0.5s ease, transform 0.5s ease;
}

.chem-toggle.checked .chem-toggle-shell-info {
    transform: translateX(6%);
}

.chem-toggle.checked .chem-toggle-shell-info {
    opacity: 1;
    transform: translateX(0);
}

.chem-toggle-shell-label {
    font-size: 7px;
    font-weight: 700;
    color: rgba(255, 152, 0, 0.9);
    margin-bottom: 14px;
    text-shadow: 0 0 4px rgba(255, 152, 0, 0.4);
    padding: 2px 4px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 2px;
    border: 1px solid rgba(255, 152, 0, 0.5);
    transition: all 0.4s ease;
}

.chem-toggle.checked .chem-toggle-shell-label {
    color: rgba(255, 193, 7, 0.9);
    text-shadow: 0 0 6px rgba(255, 193, 7, 0.6);
    background: rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 193, 7, 0.4);
}

.ct-label-1 { animation: chemLabelBlink 2s infinite ease-in-out; animation-delay: 0s; }
.ct-label-2 { animation: chemLabelBlink 2s infinite ease-in-out; animation-delay: 0.3s; }
.ct-label-3 { animation: chemLabelBlink 2s infinite ease-in-out; animation-delay: 0.6s; }

@keyframes chemLabelBlink {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
}

.chem-toggle-atomic-particles {
    position: absolute;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.chem-toggle-particle {
    position: absolute;
    width: 3px;
    height: 3px;
    background: radial-gradient(circle, rgba(255, 152, 0, 0.6), transparent);
    border-radius: 50%;
    animation: chemParticleDrift 6s infinite ease-in-out;
    transition: background 0.4s ease;
}

.chem-toggle.checked .chem-toggle-particle {
    background: radial-gradient(circle, rgba(255, 193, 7, 0.8), transparent);
}

.ct-ap1 { top: 20%; left: 10%; animation-delay: 0s; }
.ct-ap2 { top: 70%; left: 20%; animation-delay: 1.5s; }
.ct-ap3 { top: 40%; right: 15%; animation-delay: 3s; }
.ct-ap4 { bottom: 20%; right: 25%; animation-delay: 4.5s; }

@keyframes chemParticleDrift {
    0%, 100% { transform: translate(0, 0); opacity: 0.3; }
    25% { transform: translate(10px, -10px); opacity: 0.8; }
    50% { transform: translate(5px, -20px); opacity: 1; }
    75% { transform: translate(-5px, -10px); opacity: 0.6; }
}

@media (max-width: 768px) {
    #theme-toggle.chem-toggle {
        transform: scale(1);
    }

    #theme-toggle.chem-toggle:hover {
        transform: translateY(-2px);
    }
}

@media (max-width: 1024px) {
    #theme-toggle.chem-toggle {
        top: 20px;
        right: auto;
        bottom: auto;
        left: 20px;
        transform-origin: top left;
    }
}


============================================================
ФАЙЛ: .\css\live-wallpaper.css
============================================================

﻿/* Live Wallpaper & Settings Styles */
.wallpaper-status-badge {
    font-size: 10px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 10px;
    background: rgba(150, 150, 150, 0.3);
    color: var(--text-secondary, #666);
    margin-left: 4px;
}

.wallpaper-status-badge.active {
    background: rgba(76, 175, 80, 0.3);
    color: #4CAF50;
}

.fab-btn.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

/* App Notification */
.app-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 16px 24px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    z-index: 100000;
    animation: slideInNotif 0.3s ease;
    font-size: 14px;
    max-width: 350px;
}

.app-notification.success {
    background: #4CAF50;
    color: white;
}

.app-notification.error {
    background: #f44336;
    color: white;
}

.app-notification.fade-out {
    animation: slideOutNotif 0.3s ease forwards;
}

@keyframes slideInNotif {
    from {
        transform: translateX(400px);
        opacity: 0;
    }

    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOutNotif {
    from {
        transform: translateX(0);
        opacity: 1;
    }

    to {
        transform: translateX(400px);
        opacity: 0;
    }
}

/* Settings Modal Styles */
.settings-modal-content {
    max-width: 500px;
}

.settings-section {
    margin: 24px 0;
    padding: 16px;
    background: rgba(0, 0, 0, 0.03);
    border-radius: 8px;
}

[data-theme="dark"] .settings-section,
.dark-theme .settings-section {
    background: rgba(255, 255, 255, 0.05);
}

.settings-section h3 {
    margin-top: 0;
    margin-bottom: 16px;
    font-size: 16px;
}

.switch-label {
    display: flex;
    align-items: center;
    cursor: pointer;
    gap: 12px;
}

.switch-input {
    display: none;
}

.switch-slider {
    position: relative;
    width: 50px;
    height: 26px;
    background: #ccc;
    border-radius: 26px;
    transition: 0.3s;
    flex-shrink: 0;
}

.switch-slider::before {
    content: '';
    position: absolute;
    width: 22px;
    height: 22px;
    background: white;
    border-radius: 50%;
    top: 2px;
    left: 2px;
    transition: 0.3s;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.switch-input:checked + .switch-slider {
    background: #667eea;
}

.switch-input:checked + .switch-slider::before {
    transform: translateX(24px);
}

.switch-text {
    font-size: 14px;
}

.setting-description {
    margin-top: 12px;
    font-size: 13px;
    color: var(--text-secondary, #666);
    line-height: 1.5;
}

.info-text {
    font-size: 14px;
    color: var(--text-secondary, #666);
    line-height: 1.6;
    margin: 8px 0;
}

/* Wallpaper mode optimizations (when running as wallpaper) */
body.wallpaper-mode {
    overflow: hidden;
}

body.wallpaper-mode .fab-container,
body.wallpaper-mode .below-table-content,
body.wallpaper-mode .download-app-section,
body.wallpaper-mode #theme-toggle,
body.wallpaper-mode #filters-panel,
body.wallpaper-mode #calc-panel,
body.wallpaper-mode #balancer-panel,
body.wallpaper-mode .modal {
    display: none !important;
}


============================================================
ФАЙЛ: .\css\loader.css
============================================================

/* =========================================
   LOADER.CSS — Анимация загрузки приложения
   Химические формулы с эффектом печати
   ========================================= */

/* === Основной контейнер === */
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    opacity: 1;
    transition: opacity 0.5s ease-out;
    overflow: hidden;
}

#loading-screen.fade-out {
    opacity: 0;
    pointer-events: none;
}

#loading-screen.hidden {
    display: none;
}

/* === Фоновые частицы === */
.loader-particles {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
}

.loader-particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: rgba(33, 150, 243, 0.3);
    border-radius: 50%;
    animation: loader-float 15s infinite ease-in-out;
}

@keyframes loader-float {
    0%, 100% { 
        transform: translateY(100vh) rotate(0deg); 
        opacity: 0; 
    }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { 
        transform: translateY(-100vh) rotate(720deg); 
        opacity: 0; 
    }
}

/* === Контейнер формулы === */
.formula-container {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
}

/* === Орбиты вокруг формулы === */
.loader-orbits {
    position: absolute;
    width: 300px;
    height: 300px;
    pointer-events: none;
}

.orbit-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 1px solid rgba(33, 150, 243, 0.15);
    border-radius: 50%;
    animation: orbit-spin 10s linear infinite;
}

.orbit-ring-1 { width: 200px; height: 200px; }
.orbit-ring-2 { width: 260px; height: 260px; animation-duration: 15s; animation-direction: reverse; }
.orbit-ring-3 { width: 320px; height: 320px; animation-duration: 20s; }

.orbit-dot {
    position: absolute;
    width: 6px;
    height: 6px;
    background: #00d4ff;
    border-radius: 50%;
    top: -3px;
    left: 50%;
    transform: translateX(-50%);
    box-shadow: 0 0 10px #00d4ff;
}

@keyframes orbit-spin {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* === Бокс с формулой === */
.formula-box {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(33, 150, 243, 0.2);
    border-radius: 16px;
    padding: 30px 50px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 
        0 0 40px rgba(33, 150, 243, 0.1),
        inset 0 0 30px rgba(33, 150, 243, 0.05);
    animation: glow-pulse 3s ease-in-out infinite;
}

@keyframes glow-pulse {
    0%, 100% { 
        box-shadow: 
            0 0 40px rgba(33, 150, 243, 0.1), 
            inset 0 0 30px rgba(33, 150, 243, 0.05); 
    }
    50% { 
        box-shadow: 
            0 0 60px rgba(33, 150, 243, 0.2), 
            inset 0 0 40px rgba(33, 150, 243, 0.1); 
    }
}

/* === Текст формулы === */
.formula-text {
    font-family: 'Courier New', 'Consolas', monospace;
    font-size: 42px;
    font-weight: bold;
    color: transparent;
    background: linear-gradient(90deg, #00d4ff, #00ff88, #00d4ff);
    background-size: 200% 100%;
    -webkit-background-clip: text;
    background-clip: text;
    animation: gradient-shift 3s linear infinite;
    letter-spacing: 2px;
    min-width: 200px;
    text-align: center;
}

@keyframes gradient-shift {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
}

/* Эффект печатной машинки */
.formula-typing {
    display: inline-block;
    overflow: hidden;
    white-space: nowrap;
    border-right: 3px solid #00d4ff;
    animation: 
        loader-typing var(--typing-duration, 1.5s) steps(var(--chars, 10), end) forwards,
        loader-blink 0.7s step-end infinite;
}

@keyframes loader-typing {
    from { max-width: 0; }
    to { max-width: 100%; }
}

@keyframes loader-blink {
    50% { border-color: transparent; }
}

/* Подпись вещества */
.formula-name {
    margin-top: 16px;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.5);
    letter-spacing: 3px;
    text-transform: uppercase;
    animation: loader-fade-in 0.5s ease-out 1s forwards;
    opacity: 0;
    font-family: Arial, sans-serif;
}

@keyframes loader-fade-in {
    to { opacity: 1; }
}

/* === Прогресс-бар === */
.loader-progress-section {
    margin-top: 50px;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
}

.loader-progress-bar {
    width: 280px;
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
    position: relative;
}

.loader-progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #00d4ff, #00ff88, #ff00ff, #00d4ff);
    background-size: 300% 100%;
    animation: loader-progress-gradient 2s linear infinite;
    border-radius: 2px;
    transition: width 0.3s ease;
}

@keyframes loader-progress-gradient {
    0% { background-position: 0% 50%; }
    100% { background-position: 300% 50%; }
}

.loader-progress-text {
    margin-top: 12px;
    font-size: 11px;
    color: rgba(255, 255, 255, 0.4);
    letter-spacing: 4px;
    text-transform: uppercase;
    font-family: Arial, sans-serif;
}

.loader-progress-percent {
    margin-top: 6px;
    font-size: 13px;
    color: rgba(0, 212, 255, 0.8);
    font-family: 'Courier New', monospace;
}

/* === Мобильная адаптация === */
@media (max-width: 600px) {
    .formula-text {
        font-size: 28px;
    }
    
    .formula-box {
        padding: 20px 30px;
    }
    
    .loader-progress-bar {
        width: 200px;
    }
    
    .loader-orbits {
        width: 200px;
        height: 200px;
    }
    
    .orbit-ring-1 { width: 140px; height: 140px; }
    .orbit-ring-2 { width: 180px; height: 180px; }
    .orbit-ring-3 { width: 220px; height: 220px; }
    
    .formula-name {
        font-size: 12px;
        letter-spacing: 2px;
    }
}

/* === Тёмная тема (уже тёмный, но на всякий случай) === */
body.dark-theme #loading-screen {
    background: linear-gradient(135deg, #0a0a15 0%, #0d1525 50%, #050510 100%);
}


============================================================
ФАЙЛ: .\css\modal.css
============================================================

﻿/* =========================================
   MODAL.CSS вЂ” РњРѕРґР°Р»СЊРЅРѕРµ РѕРєРЅРѕ СЌР»РµРјРµРЅС‚Р°
   ========================================= */

/* --- Р¤РѕРЅ РјРѕРґР°Р»СЊРЅРѕРіРѕ РѕРєРЅР° --- */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    justify-content: center;
    align-items: center;
    animation: backdropOpen var(--flip-backdrop-ms) var(--flip-backdrop-ease) forwards;
}

.modal.closing {
    animation: backdropClose var(--flip-backdrop-ms) var(--flip-backdrop-ease) forwards;
}

/* --- РљРѕРЅС‚РµРЅС‚ РјРѕРґР°Р»СЊРЅРѕРіРѕ РѕРєРЅР° --- */
.modal-content {
    background-color: #fefefe;
    width: 900px;
    max-width: 95vw;
    height: auto;
    max-height: 80vh;
    padding: 20px 30px;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
    margin: auto;
    animation: modalOpen var(--flip-move-ms) var(--flip-ease) forwards;
}

.modal.closing .modal-content {
    animation: modalClose var(--flip-move-ms) var(--flip-ease) forwards;
}

/* --- Wallpaper mode: disable modal animations to reduce jank --- */
body.wallpaper-optimized .modal,
body.wallpaper-optimized .modal * {
    animation: none !important;
    transition: none !important;
}

/* --- Кнопка закрытия --- */
.close {
    position: absolute;
    right: 15px;
    top: 10px;
    width: 40px;
    height: 40px;
    border: none;
    appearance: none;
    -webkit-appearance: none;
    border-radius: 8px;
    background: rgba(33, 150, 243, 0.15);
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #2196F3;
    z-index: 1001;
    box-shadow: none;
    outline: none;
}

.close svg {
    width: 22px;
    height: 22px;
    stroke: currentColor;
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.close:hover {
    background: rgba(33, 150, 243, 0.3);
    transform: scale(1.1);
}

/* Тёмная тема */
body.dark-theme .close {
    background: rgba(100, 181, 246, 0.2);
    color: #64B5F6;
}

body.dark-theme .close:hover {
    background: rgba(100, 181, 246, 0.4);
}

/* --- Р—Р°РіРѕР»РѕРІРѕРє СЌР»РµРјРµРЅС‚Р° --- */
#element-title {
    text-align: center;
    margin: 10px 0 20px 0;
    font-size: 28px;
    color: #333;
    flex-shrink: 0;
}

/* --- РљРѕРЅС‚РµР№РЅРµСЂ РёРЅС„РѕСЂРјР°С†РёРё --- */
#element-info {
    flex-grow: 1;
    overflow: hidden;
    padding-bottom: 10px;
    display: flex;
    justify-content: center;
    -ms-overflow-style: auto;
    /* IE and Edge */
    scrollbar-width: thin;
    /* Firefox */
}

/* =========================================
   РўРђР‘Р« РђР›Р›РћРўР РћРџРћР’
   ========================================= */
#allotrope-tabs-placeholder {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
    flex-shrink: 0;
    flex-wrap: wrap;
}

.allotrope-tab {
    border: 1px solid #ddd;
    padding: 8px 16px;
    border-radius: 20px;
    background: #f7f7f7;
    cursor: pointer;
    font-weight: 600;
    color: #555;
    transition: all 0.2s;
}

.allotrope-tab:hover {
    background: #eaeaea;
}

.allotrope-tab.active {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
    box-shadow: 0 2px 5px rgba(76, 175, 80, 0.3);
}

/* РљРЅРѕРїРєР° "+ Р•С‰С‘" */
.allotrope-tab.more-btn {
    background: #fff3e0;
    border-color: #FF9800;
    color: #E65100;
}

.allotrope-tab.more-btn:hover {
    background: #ffe0b2;
}

.allotrope-tab.more-btn.expanded {
    background: #FF9800;
    color: white;
}

/* Р”РѕРїРѕР»РЅРёС‚РµР»СЊРЅС‹Рµ С‚Р°Р±С‹ */
.allotrope-tab.extra-tab {
    background: #fce4ec;
    border-color: #E91E63;
    color: #880E4F;
    animation: fadeInTab 0.3s ease-out;
}

.allotrope-tab.extra-tab:hover {
    background: #f8bbd0;
}

.allotrope-tab.extra-tab.active {
    background: #E91E63;
    color: white;
    border-color: #E91E63;
    box-shadow: 0 2px 5px rgba(233, 30, 99, 0.3);
}

/* =========================================
   РЎР•РљР¦РР РРќР¤РћР РњРђР¦РР
   ========================================= */
.groups-container {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    height: 100%;
    justify-content: center;
    max-width: 100%;
}

.info-group {
    display: flex;
    flex-direction: row;
    flex: 1 1 0;
    min-width: 45px;
    max-width: 265px;
    max-height: 350px;
    background: #f9f9f9;
    border-radius: 8px;
    border-left: 5px solid #ddd;
    transition: all 0.3s ease-in-out;
    overflow: hidden;
}

/* Р¦РІРµС‚Р° СЃРµРєС†РёР№ */
.info-group.basic {
    border-left-color: #2196F3;
    background: #E3F2FD;
}

.info-group.physical {
    border-left-color: #4CAF50;
    background: #E8F5E8;
}

.info-group.history {
    border-left-color: #FF9800;
    background: #FFF3E0;
}

.info-group.facts {
    border-left-color: #9C27B0;
    background: #F3E5F5;
}

/* РЎРІС‘СЂРЅСѓС‚Р°СЏ СЃРµРєС†РёСЏ */
.info-group.collapsed {
    flex: 0 0 45px;
    max-width: 45px;
    max-height: 350px;
    transition: all 0.2s ease-out;
}

/* Р—Р°РіРѕР»РѕРІРѕРє СЃРµРєС†РёРё */
.group-title {
    writing-mode: vertical-lr;
    text-orientation: upright;
    width: 45px;
    min-width: 45px;
    flex-shrink: 0;
    margin: 0;
    color: #555;
    font-weight: 700;
    font-size: 13px;
    -webkit-user-select: none;
    user-select: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    padding: 15px 0;
    transition: background 0.2s;
    white-space: nowrap;
}

.group-title:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

/* РљРѕРЅС‚РµРЅС‚ СЃРµРєС†РёРё */
.group-content {
    flex: 1 1 auto;
    min-width: 0;
    padding: 15px;
    overflow-y: auto;
    overflow-x: hidden;
    opacity: 1;
    transition: opacity 0.2s ease-out, padding 0.3s ease-in-out;
    -ms-overflow-style: auto;
    /* IE and Edge */
    scrollbar-width: thin;
    /* Firefox */
}


.group-content.collapsed {
    width: 0 !important;
    padding: 0 !important;
    opacity: 0;
    overflow: hidden;
    transition: opacity 0.15s ease-out, padding 0.3s ease-in-out;
}

.info-group p {
    margin: 8px 0;
    line-height: 1.4;
    font-size: 14px;
}

.electron-config-row {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    padding: 8px 10px;
    border-radius: 10px;
    background: rgba(33, 150, 243, 0.12);
    border: 1px solid rgba(33, 150, 243, 0.2);
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
}

.electron-config-row:hover {
    background: rgba(33, 150, 243, 0.18);
    box-shadow: 0 4px 10px rgba(33, 150, 243, 0.15);
    transform: translateY(-1px);
}

.electron-config-row:focus {
    outline: 2px solid rgba(33, 150, 243, 0.35);
    outline-offset: 2px;
}

.electron-config-value {
    font-weight: 600;
    color: #0d47a1;
}

.electron-config-action {
    margin-left: auto;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 700;
    letter-spacing: 0.02em;
    text-transform: uppercase;
    background: rgba(13, 71, 161, 0.12);
    color: #0d47a1;
}

.electron-config-row strong {
    margin-right: 4px;
}

.electron-config-row .electron-config-action {
    white-space: nowrap;
}

.electron-config-row .electron-config-value sup {
    font-size: 10px;
}

.electron-config-row:focus-visible {
    outline: 2px solid rgba(33, 150, 243, 0.6);
}

.dark-theme .electron-config-row {
    background: rgba(129, 212, 250, 0.12);
    border-color: rgba(129, 212, 250, 0.2);
}

.dark-theme .electron-config-value {
    color: #90caf9;
}

.dark-theme .electron-config-action {
    background: rgba(144, 202, 249, 0.18);
    color: #bbdefb;
}

.allo-specific {
    border: none;
    padding: 0;
    margin: 0;
}

/* =========================================
   РЎРљР РћР›Р›Р‘РђР Р«
   ========================================= */
/* РљР°СЃС‚РѕРјРЅС‹Рµ СЃРєСЂРѕР»Р»Р±Р°СЂС‹ РґР»СЏ РјРѕРґР°Р»СЊРЅРѕРіРѕ РѕРєРЅР° */
#element-info::-webkit-scrollbar,
.group-content::-webkit-scrollbar {
    width: 6px;
    height: 6px;
}

#element-info::-webkit-scrollbar-track,
.group-content::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.03);
    border-radius: 3px;
}

#element-info::-webkit-scrollbar-thumb,
.group-content::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #2196F3, #64B5F6);
    border-radius: 3px;
}

#element-info::-webkit-scrollbar-thumb:hover,
.group-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #1976D2, #2196F3);
}

/* РўС‘РјРЅР°СЏ С‚РµРјР° */
body.dark-theme #element-info::-webkit-scrollbar-track,
body.dark-theme .group-content::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.03);
}

body.dark-theme #element-info::-webkit-scrollbar-thumb,
body.dark-theme .group-content::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #64B5F6, #90CAF9);
}

body.dark-theme #element-info::-webkit-scrollbar-thumb:hover,
body.dark-theme .group-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #42A5F5, #64B5F6);
}

/* =========================================
   РђРќРРњРђР¦РР
   ========================================= */
@keyframes fadeInTab {
    from {
        opacity: 0;
        transform: scale(0.8);
    }

    to {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}

@keyframes modalOpen {
    0% {
        opacity: 0;
        transform: translate(var(--start-x), var(--start-y)) scale(0.1);
    }

    100% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
    }
}

@keyframes modalClose {
    0% {
        opacity: 1;
        transform: translate(0, 0) scale(1);
    }

    100% {
        opacity: 0;
        transform: translate(var(--start-x), var(--start-y)) scale(0.1);
    }
}

@keyframes backdropOpen {
    0% {
        opacity: 0;
    }

    100% {
        opacity: 1;
    }
}

@keyframes backdropClose {
    0% {
        opacity: 1;
    }

    100% {
        opacity: 0;
    }
}

/* =========================================
   РђР”РђРџРўРР’
   ========================================= */
@media (max-width: 1024px) {
    .modal {
        position: fixed !important;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 99999;
        background: rgba(0, 0, 0, 0.4);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 10px;
        box-sizing: border-box;
    }

    .modal-content {
        width: 100%;
        max-width: 100%;
        height: auto;
        max-height: 95vh;
        /* РЈРІРµР»РёС‡РµРЅРѕ СЃ 90vh */
        background: rgba(255, 255, 255, 0.75);
        -webkit-backdrop-filter: blur(6px);
        backdrop-filter: blur(6px);
        border-radius: 20px 20px 0 0;
        padding: 0;
        padding-bottom: env(safe-area-inset-bottom, 20px);
        /* Р”Р»СЏ iPhone СЃ С‡С‘Р»РєРѕР№ */
        position: relative;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-shadow: 0 -5px 30px rgba(0, 0, 0, 0.3);
        border-bottom: 3px solid #2196F3;
    }

    .close {
        position: absolute;
        top: 12px;
        right: 15px;
        width: 40px;
        height: 40px;
        border-radius: 8px;
        background: rgba(33, 150, 243, 0.15);
        color: #2196F3;
        z-index: 20;
    }

    #element-title {
        font-size: 20px;
        font-weight: 600;
        margin: 0;
        padding: 15px 55px 15px 20px;
        text-align: left;
        line-height: 32px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
    }

    #allotrope-tabs-placeholder {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 0 20px 15px 20px;
        margin: 0;
        width: 100%;
        box-sizing: border-box;
    }

    .allotrope-tab {
        flex: 1 1 auto;
        text-align: center;
        font-size: 14px;
        padding: 8px 12px;
        margin: 0;
        max-width: 100%;
    }

    #element-info {
        padding: 0 20px 20px 20px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        flex: 1;
        display: block;
        padding-bottom: 30px;
        /* Р”РѕРїРѕР»РЅРёС‚РµР»СЊРЅС‹Р№ Р·Р°РїР°СЃ РґР»СЏ РїСЂРѕРєСЂСѓС‚РєРё */
    }

    .groups-container {
        display: flex;
        flex-direction: column !important;
        gap: 10px;
        height: auto !important;
        padding-bottom: 20px;
        /* Р—Р°РїР°СЃ РґР»СЏ РїСЂРѕРєСЂСѓС‚РєРё */
    }

    .info-group {
        width: 100% !important;
        max-width: none !important;
        flex: none !important;
        display: flex;
        flex-direction: column !important;
        border-left: 5px solid #ccc;
        min-height: 0 !important;
        background: #f9f9f9;
        border-radius: 8px;
        transition: none;
    }

    .group-title {
        writing-mode: horizontal-tb !important;
        text-orientation: mixed;
        width: 100% !important;
        padding: 12px 15px;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        margin: 0;
        background: transparent;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        box-sizing: border-box;
    }

    .group-content {
        width: 100% !important;
        padding: 15px;
        box-sizing: border-box;
        overflow: visible;
    }

    .info-group.collapsed {
        height: auto !important;
        padding-bottom: 0 !important;
    }

    .info-group.collapsed .group-title {
        border-bottom: none;
        justify-content: center !important;
        text-align: center;
        background-color: rgba(0, 0, 0, 0.02);
    }

    .info-group.collapsed .group-content {
        display: none !important;
    }
}

/* РњР°Р»РµРЅСЊРєРёРµ С‚РµР»РµС„РѕРЅС‹ */
@media (max-width: 480px) {
    .modal-content {
        padding: 55px 10px 10px 10px;
    }

    #element-title {
        font-size: 20px;
    }

    .allotrope-tab {
        padding: 6px 10px;
        font-size: 12px;
    }

    #element-info {
        max-height: calc(100vh - 180px);
    }

    .group-title {
        height: 50px;
        min-height: 50px;
        font-size: 13px;
    }

    .info-group.collapsed {
        min-height: 50px;
        max-height: 50px;
        flex: 0 0 50px;
    }

    .group-content {
        max-height: 250px;
    }

    .info-group p {
        font-size: 13px;
    }

    .close {
        right: 10px;
        top: 10px;
        width: 36px;
        height: 36px;
    }

    .close svg {
        width: 18px;
        height: 18px;
    }
}

/* Р“РѕСЂРёР·РѕРЅС‚Р°Р»СЊРЅР°СЏ РѕСЂРёРµРЅС‚Р°С†РёСЏ */
@media (max-width: 768px) and (orientation: landscape) {
    .modal-content {
        padding: 45px 10px 10px 10px;
    }

    #element-title {
        font-size: 18px;
        margin: 0 0 10px 0;
    }

    #element-info {
        max-height: calc(100vh - 130px);
    }

    .groups-container {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 8px;
    }

    .info-group {
        flex: 1 1 45%;
        max-width: 48%;
    }

    .info-group.collapsed {
        flex: 0 0 48%;
        max-width: 48%;
        min-height: 45px;
        max-height: 45px;
    }

    .group-title {
        height: 45px;
        min-height: 45px;
        font-size: 12px;
    }

    .group-content {
        max-height: 100px;
    }

    .close {
        top: 8px;
        right: 10px;
        width: 36px;
        height: 36px;
    }

    .close svg {
        width: 18px;
        height: 18px;
    }
}

/* =========================================
   Р‘РћР›Р¬РЁРР• Р­РљР РђРќР«
   ========================================= */
@media (min-width: 1400px) {
    .info-group.collapsed {
        flex: 0 0 60px;
        max-width: 60px;
    }

    .modal-content {
        width: 80vw;
        max-width: 1400px;
        max-height: 85vh;
        /* Р Р°Р·СЂРµС€Р°РµРј РјРѕРґР°Р»РєРµ Р±С‹С‚СЊ РІС‹С€Рµ */
    }

    .info-group {
        max-width: none;
        flex: 1 1 200px;
        max-height: 60vh;
        /* РЈРІРµР»РёС‡РёРІР°РµРј РІС‹СЃРѕС‚Сѓ СЃРµРєС†РёР№ (Р±С‹Р»Рѕ 350px) */
    }

    .group-title {
        width: 60px;
        /* Р Р°СЃС€РёСЂСЏРµРј РїРѕР»РѕСЃРєСѓ Р·Р°РіРѕР»РѕРІРєР° */
        min-width: 60px;
        font-size: 16px;
        /* РЈРІРµР»РёС‡РёРІР°РµРј С€СЂРёС„С‚ Р·Р°РіРѕР»РѕРІРєР° */
    }
}

@media (min-width: 1900px) {
    .info-group.collapsed {
        flex: 0 0 70px;
        max-width: 70px;
    }

    /* Р”Р»СЏ РѕС‡РµРЅСЊ Р±РѕР»СЊС€РёС… СЌРєСЂР°РЅРѕРІ */
    .modal-content {
        width: 75vw;
        max-width: 1800px;
        max-height: 90vh;
    }

    .info-group {
        max-height: 70vh;
        /* Р•С‰С‘ РІС‹С€Рµ РґР»СЏ РѕРіСЂРѕРјРЅС‹С… СЌРєСЂР°РЅРѕРІ */
    }

    .group-title {
        width: 70px;
        /* Р•С‰С‘ С€РёСЂРµ */
        min-width: 70px;
        font-size: 18px;
    }

    #element-title {
        font-size: 36px;
    }

    .info-group p {
        font-size: 18px;
        line-height: 1.6;
    }
}

============================================================
ФАЙЛ: .\css\nodemap.css
============================================================

/* 🎨 NodeMap Styles */

.nodemap-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10000;
    display: none;
}

.nodemap-modal.active {
    display: block;
}

.nodemap-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(5px);
}

.nodemap-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 95%;
    height: 90%;
    max-width: 1600px;
    background: #1e2936;
    border-radius: 12px;
    box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Header */
.nodemap-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 24px;
    background: #2c3e50;
    border-bottom: 2px solid #34495e;
}

.nodemap-title {
    display: flex;
    align-items: center;
    gap: 12px;
}

.nodemap-icon {
    font-size: 24px;
}

.nodemap-title h2 {
    margin: 0;
    font-size: 20px;
    color: #ecf0f1;
    font-weight: 600;
}

.nodemap-stats {
    display: flex;
    gap: 20px;
    font-size: 14px;
    color: #95a5a6;
}

.nodemap-stats span {
    padding: 4px 12px;
    background: #34495e;
    border-radius: 4px;
}

/* Mode Toggle */
.nodemap-mode-toggle {
    display: flex;
    gap: 8px;
    background: #34495e;
    padding: 4px;
    border-radius: 6px;
}

.mode-btn {
    padding: 6px 14px;
    background: transparent;
    border: none;
    color: #95a5a6;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 6px;
}

.mode-btn:hover {
    color: #ecf0f1;
    background: rgba(255, 255, 255, 0.05);
}

.mode-btn.active {
    background: #3498db;
    color: #ffffff;
}

.nodemap-close {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    color: #ecf0f1;
    font-size: 28px;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
    line-height: 1;
}

.nodemap-close:hover {
    background: #e74c3c;
}

/* Toolbar */
.nodemap-toolbar {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 12px 24px;
    background: #34495e;
    border-bottom: 1px solid #2c3e50;
}

.nodemap-search {
    position: relative;
    flex: 1;
    max-width: 400px;
}

.nodemap-search input {
    width: 100%;
    padding: 8px 36px 8px 12px;
    background: #2c3e50;
    border: 1px solid #4a5f7f;
    border-radius: 6px;
    color: #ecf0f1;
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s;
}

.nodemap-search input:focus {
    border-color: #3498db;
}

.nodemap-search input::placeholder {
    color: #7f8c8d;
}

#nodemap-clear-search {
    position: absolute;
    right: 8px;
    top: 50%;
    transform: translateY(-50%);
    width: 24px;
    height: 24px;
    border: none;
    background: transparent;
    color: #95a5a6;
    font-size: 20px;
    cursor: pointer;
    border-radius: 4px;
    line-height: 1;
}

#nodemap-clear-search:hover {
    background: #4a5f7f;
    color: #ecf0f1;
}

.nodemap-filters {
    display: flex;
    gap: 8px;
}

.nodemap-filter {
    padding: 6px 12px;
    background: #2c3e50;
    border: 1px solid #4a5f7f;
    border-radius: 6px;
    color: #ecf0f1;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 6px;
}

.nodemap-filter:hover {
    background: #3498db;
    border-color: #3498db;
}

.nodemap-filter .count {
    background: #4a5f7f;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: 600;
}

.nodemap-actions {
    display: flex;
    gap: 8px;
    margin-left: auto;
}

.nodemap-actions button {
    padding: 6px 12px;
    background: #2c3e50;
    border: 1px solid #4a5f7f;
    border-radius: 6px;
    color: #ecf0f1;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.2s;
}

.nodemap-actions button:hover {
    background: #3498db;
    border-color: #3498db;
}

/* Content */
.nodemap-content {
    flex: 1;
    display: flex;
    overflow: hidden;
}

#nodemap-canvas {
    flex: 1;
    background: #2c3e50;
    cursor: grab;
}

#nodemap-canvas:active {
    cursor: grabbing;
}

.nodemap-sidebar {
    width: 300px;
    background: #1e2936;
    border-left: 1px solid #34495e;
    overflow-y: auto;
    padding: 16px;
    -ms-overflow-style: auto;  /* IE and Edge */
    scrollbar-width: thin;  /* Firefox */
}

/* Legend */
.nodemap-legend h3,
.nodemap-info h3,
.nodemap-warnings h3 {
    margin: 0 0 12px 0;
    font-size: 14px;
    color: #ecf0f1;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
    font-size: 13px;
    color: #95a5a6;
}

.legend-color {
    width: 20px;
    height: 20px;
    border-radius: 3px;
    border: 2px solid #34495e;
}

/* Node Info */
.nodemap-info {
    margin-top: 24px;
}

.nodemap-info h4 {
    margin: 16px 0 8px 0;
    font-size: 12px;
    color: #95a5a6;
    font-weight: 600;
    text-transform: uppercase;
}

.info-section {
    margin-bottom: 16px;
}

.info-item {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    font-size: 13px;
    color: #ecf0f1;
    border-bottom: 1px solid #2c3e50;
}

.info-label {
    color: #95a5a6;
    font-weight: 500;
}

.info-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.info-list li {
    padding: 4px 8px;
    margin-bottom: 4px;
    background: #2c3e50;
    border-radius: 4px;
    font-size: 12px;
    color: #ecf0f1;
    font-family: monospace;
}

.info-empty {
    font-size: 13px;
    color: #7f8c8d;
    font-style: italic;
}

.nodemap-info-empty {
    font-size: 13px;
    color: #7f8c8d;
    font-style: italic;
    margin: 20px 0;
}

.info-badge {
    display: inline-block;
    padding: 4px 8px;
    margin: 4px 4px 0 0;
    background: #3498db;
    border-radius: 4px;
    font-size: 11px;
    color: #ecf0f1;
    font-weight: 600;
}

/* Warnings */
.nodemap-warnings {
    margin-top: 24px;
}

.nodemap-warning {
    padding: 12px;
    margin-bottom: 12px;
    border-radius: 6px;
    border-left: 4px solid;
}

.nodemap-warning.error {
    background: rgba(231, 76, 60, 0.1);
    border-left-color: #e74c3c;
}

.nodemap-warning.warning {
    background: rgba(244, 208, 63, 0.1);
    border-left-color: #f4d03f;
}

.nodemap-warning.info {
    background: rgba(52, 152, 219, 0.1);
    border-left-color: #3498db;
}

.warning-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.warning-icon {
    font-size: 16px;
}

.nodemap-warning strong {
    color: #ecf0f1;
    font-size: 13px;
}

.nodemap-warning p {
    margin: 0;
    font-size: 12px;
    color: #95a5a6;
}

.nodemap-warning details {
    margin-top: 8px;
}

.nodemap-warning summary {
    font-size: 11px;
    color: #7f8c8d;
    cursor: pointer;
    user-select: none;
}

.nodemap-warning pre {
    margin: 8px 0 0 0;
    padding: 8px;
    background: #2c3e50;
    border-radius: 4px;
    font-size: 11px;
    color: #ecf0f1;
    overflow-x: auto;
}

/* Footer */
.nodemap-footer {
    padding: 12px 24px;
    background: #2c3e50;
    border-top: 1px solid #34495e;
}

.nodemap-help {
    font-size: 13px;
    color: #7f8c8d;
    text-align: center;
}

/* Удалены дублирующие стили скроллбара, так как теперь используются универсальные стили */

/* Mobile responsiveness */
@media (max-width: 768px) {
    .nodemap-container {
        width: 100%;
        height: 100%;
        max-width: none;
        border-radius: 0;
    }

    .nodemap-toolbar {
        flex-wrap: wrap;
    }

    .nodemap-search {
        flex: 1 1 100%;
        max-width: none;
        margin-bottom: 8px;
    }

    .nodemap-sidebar {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        width: auto;
        max-height: 40%;
        border-left: none;
        border-top: 1px solid #34495e;
    }

    .nodemap-content {
        flex-direction: column;
    }
}


============================================================
ФАЙЛ: .\css\pdf-export.css
============================================================

/* =========================================
   СТИЛИ ДЛЯ КНОПКИ ЭКСПОРТА В PDF (ИКОНКА)
   Соответствует стилю кнопок из solubility.css
   ========================================= */

.pdf-export-icon-btn {
    position: absolute;
    right: 70px;
    /* Отступ слева от крестика (он right: 15px) */
    top: 10px;
    /* На одном уровне с крестиком */
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 8px;
    /* Скругленные углы как у кнопок в таблице растворимости */
    background: rgba(33, 150, 243, 0.15);
    /* Голубой полупрозрачный фон */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #2196F3;
    /* Цвет иконки */
    transition: all 0.2s ease;
    z-index: 1002;
    padding: 0;
}

.pdf-export-icon-btn:hover {
    background: rgba(33, 150, 243, 0.3);
    transform: scale(1.1);
}

.pdf-export-icon-btn svg {
    width: 22px;
    height: 22px;
    stroke: currentColor;
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* Темная тема - используем .dark-theme как в остальном проекте */
body.dark-theme .pdf-export-icon-btn,
body.dark .pdf-export-icon-btn {
    background: rgba(100, 181, 246, 0.2);
    color: #64B5F6;
}

body.dark-theme .pdf-export-icon-btn:hover,
body.dark .pdf-export-icon-btn:hover {
    background: rgba(100, 181, 246, 0.4);
}

/* Анимация загрузки */
.pdf-export-icon-btn.loading {
    pointer-events: none;
    opacity: 0.7;
}

.pdf-export-icon-btn.loading svg {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }

    to {
        transform: rotate(360deg);
    }
}

/* Адаптив для маленьких экранов */
@media (max-width: 480px) {
    .pdf-export-icon-btn {
        right: 60px;
        top: 12px;
        width: 32px;
        height: 32px;
    }

    .pdf-export-icon-btn svg {
        width: 18px;
        height: 18px;
    }
}


============================================================
ФАЙЛ: .\css\radioactive.css
============================================================

/* Radioactive Easter Egg Styles - Pro Shard-Based Disintegration */

/* Global State Activated on Body */
body.radioactive-mode {
    overflow-x: hidden;
}

/* Green Radioactive Atmosphere / Vignette */
body.radioactive-mode::after {
    content: "";
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    background: radial-gradient(circle, transparent 20%, rgba(57, 255, 20, 0.4) 60%, rgba(20, 80, 20, 0.9) 100%);
    box-shadow: inset 0 0 150px rgba(57, 255, 20, 0.6);
    z-index: 9999;
    opacity: 0;
    animation: radioactive-vignette-fade-in 5s ease-in forwards;
    mix-blend-mode: hard-light;
}

@keyframes radioactive-vignette-fade-in {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}

/* Individual Element Decay */
.element.radioactive-decay {
    position: relative;
    /* Original content is hidden by JS styles (transparent) to maintain hover state */
}

/* Radioactive Shards (The falling pieces) */
.radioactive-shard {
    position: fixed;
    pointer-events: none;
    z-index: 10001;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    /* Inherits element styles via cloning */
    background-clip: padding-box;
}

============================================================
ФАЙЛ: .\css\reactions.css
============================================================

/* Стили для модуля реакций */

/* Контейнер для тегов */
.reactions-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
    min-height: 24px;
}

/* Базовый стиль тега */
.reaction-tag {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.85rem;
    font-weight: 500;
    color: #fff;
    background-color: #555;
    /* Default */
    transition: all 0.2s ease;
    cursor: default;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

.reaction-tag:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

/* Цвета категорий */
.tag-special {
    background-color: #FFD700;
    color: #333;
}

/* Gold */
.tag-redox {
    background-color: #e57373;
    color: #fff;
}

/* Red */
.tag-displacement {
    background-color: #ba68c8;
}

/* Purple */
.tag-exchange {
    background-color: #64b5f6;
    color: #fff;
}

/* Blue */
.tag-combination {
    background-color: #81c784;
    color: #333;
}

/* Green */
.tag-decomposition {
    background-color: #ffb74d;
    color: #333;
}

/* Orange */
.tag-neutralization {
    background-color: #4db6ac;
}

/* Teal */
.tag-precipitation {
    background-color: #90a4ae;
}

/* Blue Grey */
.tag-gas_evolution {
    background-color: #4fc3f7;
    color: #333;
}

/* Light Blue */
.tag-complexation {
    background-color: #7986cb;
}

/* Indigo */
.tag-hydrolysis {
    background-color: #a1887f;
}

/* Brown */
.tag-eletrolysis,
.tag-electrolysis {
    background-color: #ff8a65;
}

/* Deep Orange */
.tag-thermal {
    background-color: #ffab91;
    color: #333;
}

/* Light Red */
.tag-qualitative {
    background-color: #f06292;
}

/* Pink */
.tag-specific {
    background-color: #a1887f;
}

/* Brown */
.tag-amphoterism {
    background-color: #ce93d8;
    color: #333;
}

/* Light Purple */
.tag-fusion {
    background-color: #ffcc80;
    color: #333;
}

/* Light Orange */
.tag-oxidizing_acid {
    background-color: #ef5350;
}

/* Red */
.tag-metal_acid {
    background-color: #ba68c8;
}

/* Purple */
.tag-combustion {
    background-color: #ff7043;
}

/* Deep Orange */
.tag-disproportionation {
    background-color: #9575cd;
}

/* Deep Purple */
.tag-exothermic {
    background-color: #ff8a65;
}

/* Особые статусы */
.tag-no_reaction {
    background-color: #b0bec5;
    color: #333;
}

.tag-suggestion {
    background-color: #81d4fa;
    color: #333;
}

.tag-db_match {
    background-color: #4db6ac;
}

/* Reactions modal visual style aligned with solubility modal */
#reactions-modal {
    justify-content: flex-start;
    align-items: center;
}

#reactions-modal .modal-content.solubility-content.reactions-content {
    max-width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter));
    width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter));
    margin-left: var(--solubility-left-gutter);
    margin-right: auto;
    max-height: 95vh;
    height: auto;
    padding: 0;
    overflow: hidden;
    background-color: var(--bg-color);
}

#reactions-modal .modal-header {
    padding: 15px 20px;
    background-color: var(--bg-color);
    border-bottom: 1px solid var(--border-color);
}

#reactions-modal .modal-header h2 {
    margin: 0;
    font-size: 1.5rem;
    letter-spacing: 0;
    color: var(--text-color);
    background: none;
    -webkit-background-clip: border-box;
    background-clip: border-box;
    -webkit-text-fill-color: currentColor;
}

#reactions-modal .reactions-title {
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 0;
}

#reactions-modal .reactions-subtitle {
    margin: 0;
    font-size: 0.9rem;
    color: var(--text-muted, #5c6470);
    font-weight: 500;
}

#reactions-modal .modal-header-controls {
    gap: 0;
}

#reactions-modal .close-reactions {
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 8px;
    background: rgba(33, 150, 243, 0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    transition: all 0.2s ease;
}

#reactions-modal .close-reactions svg {
    width: 20px;
    height: 20px;
    color: #2196f3;
}

@media (hover: hover) {
    #reactions-modal .close-reactions:hover {
        background: rgba(33, 150, 243, 0.3);
        transform: scale(1.1);
    }
}

body.dark-theme #reactions-modal .close-reactions {
    background: rgba(100, 181, 246, 0.2);
}

body.dark-theme #reactions-modal .close-reactions svg {
    color: #64b5f6;
}

@media (hover: hover) {
    body.dark-theme #reactions-modal .close-reactions:hover {
        background: rgba(100, 181, 246, 0.4);
    }
}

#reactions-modal .reactions-body {
    padding: 16px 20px 20px;
    background-color: var(--bg-color);
    gap: 12px;
}

#reactions-modal .reactions-input-block,
#reactions-modal .reactions-output-block {
    background: #f8f9fc;
    border: 1px solid rgba(60, 80, 120, 0.2);
    border-radius: 12px;
    box-shadow: none;
}

#reactions-modal .reactions-output-block {
    background: #f2f6ff;
}

#reactions-modal .reactions-input-block textarea,
#reactions-modal .reactions-output-block textarea {
    background: #ffffff;
    border: 1px solid rgba(60, 80, 120, 0.22);
}

#reactions-modal .reactions-examples {
    margin-top: 8px;
    padding: 12px;
    border-radius: 12px;
    background: #f8f9fc;
    border: 1px solid rgba(60, 80, 120, 0.14);
}

#reactions-modal .reactions-chips button {
    background: #ffffff;
    border: 1px solid rgba(60, 80, 120, 0.22);
}

body.dark-theme #reactions-modal .reactions-subtitle {
    color: rgba(220, 230, 255, 0.65);
}

body.dark-theme #reactions-modal .reactions-input-block,
body.dark-theme #reactions-modal .reactions-output-block {
    background: rgba(20, 24, 46, 0.55);
    border-color: rgba(110, 130, 180, 0.25);
}

body.dark-theme #reactions-modal .reactions-output-block {
    background: rgba(16, 22, 44, 0.9);
}

body.dark-theme #reactions-modal .reactions-input-block textarea,
body.dark-theme #reactions-modal .reactions-output-block textarea {
    background: rgba(12, 16, 34, 0.9);
    border-color: rgba(140, 160, 200, 0.2);
}

body.dark-theme #reactions-modal .reactions-examples {
    background: rgba(255, 255, 255, 0.03);
    border-color: rgba(140, 160, 200, 0.25);
}

body.dark-theme #reactions-modal .reactions-chips button {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(140, 160, 200, 0.25);
}

@media (max-width: 600px) {
    #reactions-modal .modal-content.solubility-content.reactions-content {
        width: 100vw;
        max-width: 100vw;
        margin: 0;
        height: 100dvh;
        max-height: 100dvh;
        border-radius: 0;
        background: var(--bg-color);
    }

    #reactions-modal .modal-header {
        padding: 14px 16px;
        position: sticky;
        top: 0;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        background: var(--bg-color);
        border-bottom: 1px solid var(--border-color);
    }

    #reactions-modal .modal-header h2 {
        font-size: 1.2rem;
    }

    #reactions-modal .reactions-subtitle {
        font-size: 0.84rem;
    }

    #reactions-modal .reactions-body {
        padding: 16px;
    }
}


============================================================
ФАЙЛ: .\css\scroll-collapse.css
============================================================

/* =========================================
   SCROLL-COLLAPSE.CSS — Система сжатия при скролле
   ========================================= */

/* --- Контейнер периодической таблицы --- */
.download-btn-large-icon {
    justify-content:left;
    width:15vw;
    height:15vw;
}
.download-detailes-all{
    margin-left: auto; /* Прижмёт к правому краю */
    align-self: center; /* Выравнивание по вертикали */
    flex-direction: column;
}
.download-card {
    display:flex;
    width:auto;
    flex-direction:row !important;
    align-items:center;
}
.download-detailes {
    flex-direction: column;
}
.periodic-table-container {
    width: 100%;
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: transform 0.1s ease-out;
    transform-origin: center top;
    position: relative;
    z-index: 10;
    background: transparent; /* Прозрачный фон чтобы видеть частицы */
    pointer-events: auto;
    transform: scale(1.0); /* Начальное состояние - полный размер */
    padding: 0 20px; /* Добавляем отступы по бокам */
}

@media (max-width: 1024px) {
    .periodic-table-container {
        padding-left: calc(0px + env(safe-area-inset-left));
        padding-right: calc(0px + env(safe-area-inset-right));
    }
}

/* --- Состояние сжатия --- */
.periodic-table-container.scroll-collapsed {
    height: auto; /* Автоматическая высота вместо фиксированной */
    min-height: auto;
    transform: scale(0.6) !important;
    padding: 20px;
    z-index: 100;
    box-shadow: none; /* Убираем тень */
    background: transparent; /* Прозрачный фон даже в сжатом состоянии */
}


/* --- Body стили для scroll режима --- */
body.scroll-unlocked {
    overflow-y: auto !important;
    height: auto !important;
    min-height: 200vh; /* Позволяем скролл ниже */
}

/* Кастомный скроллбар для разблокированного состояния (десктопная версия) */
/* Удалены дублирующие стили скроллбара, так как теперь используются универсальные стили */

/* --- Изначально body не скроллится --- */
body.scroll-locked {
    overflow-y: hidden !important;
    height: 100vh !important;
    min-height: 100vh !important;
    max-height: 100vh !important;
}

/* --- Контент под таблицей (для тестирования) --- */
.below-table-content {
    width: 100%;
    min-height: 100vh;
    padding: 30px 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    display: none; /* Скрыт по умолчанию */
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    position: relative;
    z-index: 1;
    margin-top: 0;
}

/* Показываем только когда скролл разблокирован */
body.scroll-unlocked .below-table-content {
    display: flex;
}

.below-table-content h2 {
    font-size: 2rem;
    margin-bottom: 15px;
    text-shadow: 0 2px 10px rgba(0,0,0,0.2);
}

.below-table-content p {
    font-size: 1rem;
    max-width: 500px;
    line-height: 1.5;
    text-shadow: 0 1px 5px rgba(0,0,0,0.1);
}

/* --- Обёртка для таблицы (объединяет основную таблицу, лантаноиды и актиноиды) --- */
.table-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0; /* Без промежутков между элементами */
    flex-shrink: 0; /* Не сжимаем */
    border: none !important; /* Убираем любые рамки */
    outline: none !important; /* Убираем outline */
    box-shadow: none !important; /* Убираем тени */
    background: transparent !important; /* Прозрачный фон */
    padding: 0 !important; /* Убираем padding */
    margin: 0 !important; /* Убираем margin */
}

/* --- Специфичные стили для внутренних элементов wrapper'а --- */
.table-wrapper > .container,
.table-wrapper > .lanthanides,
.table-wrapper > .actinides {
    /* Сохраняем оригинальное позиционирование из table.css */
    flex-shrink: 0; /* Не сжимаем */
}

/* --- Темная тема --- */
body.dark-theme .periodic-table-container {
    background: transparent; /* Прозрачный и в темной теме */
}

body.dark-theme .periodic-table-container.scroll-collapsed {
    box-shadow: none; /* Убираем тень и в темной теме */
    background: transparent; /* Прозрачный фон даже в сжатом состоянии */
}

body.dark-theme .below-table-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
}


@media (max-width: 768px) {
    body.scroll-unlocked .below-table-content {
        display: none !important;
    }
}

/* Запрет для Electron-приложений */
@media screen and (-webkit-min-device-pixel-ratio: 1) {
    /* Проверяем, является ли приложение Electron */
    body.electron-app .below-table-content,
    body[data-app-type="electron"] .below-table-content {
        display: none !important;
    }
}

/* Альтернатива: через JS-детект */
body.electron .below-table-content {
    display: none !important;
}

/* =========================================
   ТЁМНАЯ ТЕМА — КАСТОМНЫЙ СКРОЛЛБАР (скролл-коллапс)
   ========================================= */
/* Удалены дублирующие стили скроллбара, так как теперь используются универсальные стили */


============================================================
ФАЙЛ: .\css\solubility.css
============================================================

/* =========================================
   ПЕРЕМЕННЫЕ ДЛЯ ТАБЛИЦЫ РАСТВОРИМОСТИ
   ========================================= */
/* --- МОДАЛЬНОЕ ОКНО --- */

/* === CSS Variables for Solubility Table === */
:root {
    --bg-color: #ffffff;
    --text-color: #333333;
    --border-color: #e0e0e0;
    --solubility-left-gutter: 20px;
    --solubility-right-gutter: 180px;
}

body.dark-theme {
    --bg-color: #1a1a2e;
    --text-color: #eeeeee;
    --border-color: #444444;
}

/* ГЛАВНЫЙ КОНТЕЙНЕР МОДАЛКИ */
#solubility-modal {
    display: none;
    /* ВАЖНО: Скрыто по умолчанию! */
    position: fixed;
    /* Фиксируем поверх экрана */
    z-index: 2000;
    /* Самый высокий слой, чтобы перекрыть всё */
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    /* Затемнение фона */

    /* Выравнивание содержимого — слева с отступом, вертикально по центру */
    justify-content: flex-start;
    align-items: center;
}

/* Если класс .modal уже есть в style.css, этот код всё равно нужен,
   чтобы переопределить специфичные глюки */
/* Растягиваем почти на весь экран, но с отступом справа для FAB кнопок */
.solubility-content {
    max-width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter));
    width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter));
    max-height: 95vh;
    height: auto;
    display: flex;
    flex-direction: column;
    padding: 0;
    margin-right: auto;
    margin-left: var(--solubility-left-gutter);
    /* Прижимаем к левому краю с небольшим отступом */
    background-color: var(--sol-bg);
    /* Добавили фон */
    position: relative;
    overflow: hidden;
    /* Prevent dragging outside nicely */
}

/* Мобильные: разрешаем вертикальный скролл внутри таблицы растворимости */
@media (max-width: 1024px) {
    body.solubility-open .solubility-content {
        touch-action: pan-y !important;
        /* Force full height on mobile to avoid empty space */
        max-height: none !important;
        height: 100dvh !important;
        /* Use dvh for better mobile browser support */
        height: 100% !important;
        /* Fallback */
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        margin-bottom: 0;
    }

    body.solubility-open .solubility-wrapper {
        touch-action: pan-x pan-y !important;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
    }
}

/* --- ШАПКА (Название + Крестик) --- */
.modal-header {
    display: flex;
    justify-content: space-between;
    /* Разносит элементы по краям */
    align-items: center;
    padding: 15px 20px;
    background-color: var(--bg-color);
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
    /* Чтобы шапка не сжималась */
}

.modal-header h2 {
    margin: 0;
    font-size: 1.5rem;
}

/* Крестик - теперь справа и крупный */
.close-solubility {
    margin-left: 10px;
    flex-shrink: 0;
}

/* --- ЛЕГЕНДА --- */
.table-legend {
    padding: 10px 20px;
    background-color: var(--bg-color);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    gap: 15px;
    align-items: center;
    flex-shrink: 0;
    font-size: 0.9em;
}

/* Кнопка рядов активности */
#activity-mode-btn {
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 8px;
    background: rgba(255, 193, 7, 0.15);
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
}

@media (hover: hover) {
    #activity-mode-btn:hover {
        background: rgba(255, 193, 7, 0.3);
        transform: scale(1.1);
    }
}

#activity-mode-btn.active {
    background: #FFC107;
    box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
}

body.dark-theme #activity-mode-btn {
    background: rgba(255, 213, 79, 0.2);
}

@media (hover: hover) {
    body.dark-theme #activity-mode-btn:hover {
        background: rgba(255, 213, 79, 0.4);
    }
}

body.dark-theme #activity-mode-btn.active {
    background: #FFD54F;
}

/* --- ОБЛАСТЬ СКРОЛЛА --- */
.solubility-wrapper {
    overflow: auto;
    /* Убираем flex-grow, чтобы контейнер не растягивался, если таблица маленькая */
    flex-grow: 0;
    flex-shrink: 1;
    /* Разрешаем сжиматься, если не влезает в экран */
    /* Занимает всё оставшееся место */
    position: relative;
    background-color: var(--bg-color);
    cursor: grab;
    /* Курсор для drag-to-scroll */
    -webkit-overflow-scrolling: touch;
    /* Плавный скролл на iOS */
    touch-action: pan-x pan-y;
    /* Разрешаем скролл в обе стороны на touch-устройствах */
    -ms-overflow-style: auto;
    /* IE and Edge */
    scrollbar-width: thin;
    /* Firefox */
}

/* --- SCROLLBAR CUSTOMIZATION --- */
.solubility-wrapper::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.solubility-wrapper::-webkit-scrollbar-track {
    background: transparent;
}

.solubility-wrapper::-webkit-scrollbar-thumb {
    background-color: rgba(128, 128, 128, 0.3);
    border-radius: 4px;
    border: 2px solid transparent;
    background-clip: content-box;
}

.solubility-wrapper::-webkit-scrollbar-thumb:hover {
    background-color: rgba(128, 128, 128, 0.6);
}

body.dark-theme .solubility-wrapper::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.2);
}

body.dark-theme .solubility-wrapper::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.4);
}

.solubility-wrapper:active {
    cursor: grabbing;
}

/* --- ТАБЛИЦА --- */
#solubility-table {
    border-collapse: separate;
    /* Обязательно для sticky */
    border-spacing: 0;
    width: 100%;
}

/* --- СТИЛИ ЯЧЕЕК И ЗАГОЛОВКОВ --- */

#solubility-table th,
#solubility-table td {
    padding: 11px;
    text-align: center;
    border-right: 1px solid rgba(128, 128, 128, 0.4);
    border-bottom: 1px solid rgba(128, 128, 128, 0.4);
    font-size: 15px;
    font-weight: 500;
}

/* 1. Верхняя строка (Катионы) */
#solubility-table thead th {
    position: sticky;
    top: 0;
    z-index: 20;
    background-color: var(--bg-color);
    border-bottom: 2px solid var(--text-color);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    /* Добавляем для гарантии непрозрачности */
    backdrop-filter: none;
}

/* 2. Левый столбец (Анионы) */
#solubility-table tbody th {
    position: sticky;
    left: 0;
    z-index: 15;
    background-color: var(--bg-color);
    border-right: 2px solid var(--text-color);
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
    /* Добавляем для гарантии непрозрачности */
    backdrop-filter: none;
}

/* 3. Угловая ячейка (крестик) */
#solubility-table thead th:first-child {
    z-index: 30;
    position: sticky;
    left: 0;
    top: 0;
    background-color: var(--bg-color);
    border-right: 2px solid var(--text-color);
    border-bottom: 2px solid var(--text-color);
    /* Убираем возможную прозрачность */
    backdrop-filter: none;
}

/* --- АДАПТАЦИЯ ПОД ПК --- */
@media (min-width: 1024px) {
    #solubility-table {
        font-size: 1vw;
    }

    #solubility-table th,
    #solubility-table td {
        padding: 0.5vw;
        min-width: 3.5vw;
    }

    /* Увеличиваем заголовок модалки на ПК */
    .modal-header h2 {
        font-size: 1.8vw;
    }
}

/* --- СТИЛИ ДЛЯ ПОДСВЕТКИ (Интерактив) --- */

/* Когда наводишь мышкой (только для ПК) */
#solubility-table td:hover {
    border: 2px solid var(--text-color);
    cursor: pointer;
    transform: scale(1.1);
    /* Легкое увеличение */
    z-index: 100;
    /* Чтобы вылезти поверх соседей */
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}

/* Активная (выбранная) ячейка */
.focused-cell {
    border: 3px solid #ff4081 !important;
    /* Ярко-розовый бордюр */
    font-weight: bold;
    transform: scale(1.2);
    z-index: 101;
    background-color: var(--bg-color);
    /* Чтобы перекрыть фон */
    color: var(--text-color);
}

/* Подсветка всего столбца и строки (Крестовина) */
/* Используем box-shadow вместо background, чтобы не скрывать реальные цвета */
.active-row,
.active-col {
    box-shadow: inset 0 0 0 2px rgba(33, 150, 243, 0.6) !important;
    position: relative;
}

/* --- ДОПОЛНИТЕЛЬНАЯ ЗАЩИТА ФОНА ЛЕВОГО СТОЛБЦА --- */
/* Убираем цветные фоны с заголовков анионов */
#solubility-table tbody th.type-r,
#solubility-table tbody th.type-m,
#solubility-table tbody th.type-n,
#solubility-table tbody th.type-d {
    background-color: var(--bg-color) !important;
    color: var(--text-color) !important;
}

body.dark-theme #solubility-table tbody th.type-r,
body.dark-theme #solubility-table tbody th.type-m,
body.dark-theme #solubility-table tbody th.type-n,
body.dark-theme #solubility-table tbody th.type-d {
    background-color: var(--bg-color) !important;
    color: var(--text-color) !important;
}

/* Подсветка заголовков, когда выбран их ряд/столбец */
.active-header {
    background-color: #2196F3 !important;
    color: white !important;
    font-weight: bold;
}

/* --- ЦВЕТА ЯЧЕЕК --- */
.type-r {
    background-color: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
}

/* Зеленый */
.type-m {
    background-color: rgba(255, 193, 7, 0.2);
    color: #FFC107;
}

/* Желтый */
.type-n {
    background-color: rgba(244, 67, 54, 0.2);
    color: #F44336;
}

/* Красный */
.type-d {
    background-color: rgba(158, 158, 158, 0.2);
    color: #9E9E9E;
}

/* Серый */

/* Ярче для темной темы */
body.dark-theme .type-r {
    color: #81c784;
    background-color: rgba(129, 199, 132, 0.1);
}

body.dark-theme .type-m {
    color: #ffd54f;
    background-color: rgba(255, 213, 79, 0.1);
}

body.dark-theme .type-n {
    color: #e57373;
    background-color: rgba(229, 115, 115, 0.1);
}

/* === Dark Theme: Sticky Headers Fix === */
body.dark-theme #solubility-table thead th,
body.dark-theme #solubility-table tbody th,
body.dark-theme #solubility-table thead th:first-child {
    background-color: #1a1a2e;
    color: #eeeeee;
}

body.dark-theme .solubility-content {
    background-color: #1a1a2e;
}

body.dark-theme .modal-header,
body.dark-theme .table-legend {
    background-color: #1a1a2e;
    border-color: #444;
}

/* Для темного режима используем общий стиль скроллбара */

/* =========================================
   КНОПКА РЕЖИМА ЦВЕТОВ
   ========================================= */
.modal-header-controls {
    display: flex;
    align-items: center;
    gap: 5px;
    background: rgba(128, 128, 128, 0.1);
    padding: 5px;
    border-radius: 12px;
    border: 1px solid var(--border-color);
}

#color-mode-btn {
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 8px;
    background: rgba(33, 150, 243, 0.15);
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
}

@media (hover: hover) {
    #color-mode-btn:hover {
        background: rgba(33, 150, 243, 0.3);
        transform: scale(1.1);
    }
}

#color-mode-btn.active {
    background: #2196F3;
    box-shadow: 0 0 10px rgba(33, 150, 243, 0.5);
}

body.dark-theme #color-mode-btn {
    background: rgba(100, 181, 246, 0.2) !important;
}

@media (hover: hover) {
    body.dark-theme #color-mode-btn:hover {
        background: rgba(100, 181, 246, 0.4) !important;
    }
}

body.dark-theme #color-mode-btn.active {
    background: #64B5F6 !important;
}

/* Стили для всех кнопок в .modal-header-controls */
.modal-header-controls button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 40px;
    height: 40px;
}

/* SVG иконки внутри кнопок */
.modal-header-controls button svg {
    width: 20px;
    height: 20px;
    display: block;
}

/* Универсальные стили для кнопок, чтобы они были синими на всех устройствах */
#solubility-modal #color-mode-btn {
    background: rgba(33, 150, 243, 0.15) !important;
    border: none !important;
}

#solubility-modal #color-mode-btn:hover {
    background: rgba(33, 150, 243, 0.3) !important;
}

#solubility-modal #color-mode-btn.active {
    background: #2196F3 !important;
}

#solubility-modal #advanced-mode-info-btn {
    background: rgba(33, 150, 243, 0.15) !important;
    /* Изменяем на синий цвет вместо фиолетового */
    border: none !important;
}

#solubility-modal #advanced-mode-info-btn:hover {
    background: rgba(33, 150, 243, 0.3) !important;
    /* Изменяем на синий цвет вместо фиолетового */
}

#solubility-modal #advanced-mode-info-btn.active {
    background: #2196F3 !important;
    /* Изменяем на синий цвет вместо фиолетового */
    color: white !important;
    box-shadow: 0 0 12px #2196F3 !important;
}

/* =========================================
   ЯЧЕЙКИ С РЕАЛЬНЫМИ ЦВЕТАМИ
   ========================================= */
.chem-color-cell {
    text-shadow:
        1px 1px 1px rgba(0, 0, 0, 0.3),
        -1px -1px 1px rgba(255, 255, 255, 0.3);
    font-weight: bold;
    border: 1px solid rgba(128, 128, 128, 0.4) !important;
}

.chem-color-cell.dark-bg {
    color: #ffffff !important;
    text-shadow:
        1px 1px 2px rgba(0, 0, 0, 0.8),
        0 0 5px rgba(0, 0, 0, 0.5);
}

.chem-color-cell.light-bg {
    color: #000000 !important;
    text-shadow:
        1px 1px 1px rgba(255, 255, 255, 0.8),
        -1px -1px 1px rgba(255, 255, 255, 0.5);
}

/* Белые осадки — с заметной рамкой */
.chem-color-cell.white-precipitate {
    background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%) !important;
    border: 2px solid #999 !important;
    box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
}

/* Бесцветные растворы — лёгкий голубой оттенок "воды" */
.chem-color-cell.colorless-solution {
    background: linear-gradient(135deg, #f0f9ff 0%, #e6f4ff 100%) !important;
    border: 1px dashed #90caf9 !important;
    position: relative;
    overflow: hidden;
    box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.85),
        inset 0 -1px 0 rgba(90, 140, 185, 0.2);
}

/* Блик "стекла" для прозрачных растворов */
.chem-color-cell.colorless-solution::before {
    content: '';
    position: absolute;
    top: 8%;
    left: 10%;
    right: 10%;
    height: 42%;
    border-radius: 999px;
    background: linear-gradient(165deg,
            rgba(255, 255, 255, 0.82) 0%,
            rgba(255, 255, 255, 0.35) 55%,
            rgba(255, 255, 255, 0) 100%);
    pointer-events: none;
}

/* Тёмная тема */
body.dark-theme .chem-color-cell.white-precipitate {
    background: linear-gradient(135deg, #e8e8e8 0%, #d0d0d0 100%) !important;
    border-color: #666 !important;
}

body.dark-theme .chem-color-cell.colorless-solution {
    background: linear-gradient(135deg, #d9dce0 0%, #c9ced4 100%) !important;
    border-color: #a3abb4 !important;
    box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.55),
        inset 0 -1px 0 rgba(95, 107, 120, 0.32);
}

body.dark-theme .chem-color-cell.colorless-solution::before {
    background: linear-gradient(165deg,
            rgba(255, 255, 255, 0.58) 0%,
            rgba(255, 255, 255, 0.2) 55%,
            rgba(255, 255, 255, 0) 100%);
}


/* НОВЫЙ БЛОК: Для средних экранов (ноутбуки, мониторы 1920x1080) */
/* НОВЫЙ БЛОК: Для средних экранов (ноутбуки, мониторы 1920x1080) */
@media (min-width: 1025px) and (max-width: 1920px) {
    .solubility-content {
        max-width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter)) !important;
        width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter)) !important;
        max-height: 95vh !important;
        height: auto !important;
    }

    #solubility-table {
        font-size: 1.1vw;
    }

    #solubility-table th,
    #solubility-table td {
        padding: 0.5vw;
        min-width: 4vw;
    }

    /* Левый столбец с анионами */
    #solubility-table tbody th {
        font-size: 1.1vw;
        min-width: 6vw;
        padding: 0.4vw 0.8vw;
    }

    /* Верхняя строка с катионами */
    #solubility-table thead th {
        font-size: 1.1vw;
    }

    /* Ячейки степени растворимости */
    #solubility-table td {
        font-size: 1.3vw;
        font-weight: 600;
    }


    /* Кнопки в шапке - увеличиваем */
    .modal-header-controls button {
        width: 3vw;
        height: 3vw;
        min-width: 40px;
        min-height: 40px;
    }

    .modal-header-controls button svg {
        width: 1.5vw;
        height: 1.5vw;
        min-width: 20px;
        min-height: 20px;
    }

    .modal-header h2 {
        font-size: 1.6vw;
    }

    /* Кнопка рядов активности */
    #activity-mode-btn {
        width: 3vw;
        height: 3vw;
        min-width: 40px;
        min-height: 40px;
        font-size: 1.5vw;
    }
}

/* Для больших экранов (4K и выше) */
@media (min-width: 1921px) {
    .solubility-content {
        max-width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter)) !important;
        width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter)) !important;
        max-height: 95vh !important;
        height: auto !important;
    }

    #solubility-table {
        font-size: 1.2vw;
    }

    #solubility-table th,
    #solubility-table td {
        padding: 0.6vw;
        min-width: 4.5vw;
    }

    /* Левый столбец с анионами */
    #solubility-table tbody th {
        font-size: 1.2vw;
        min-width: 7vw;
        padding: 0.5vw 1vw;
    }

    /* Верхняя строка с катионами */
    #solubility-table thead th {
        font-size: 1.2vw;
    }

    /* Ячейки степени растворимости */
    #solubility-table td {
        font-size: 1.5vw;
        font-weight: 600;
    }

    /* Кнопки в шапке - увеличиваем */
    .modal-header-controls button {
        width: 3.5vw;
        height: 3.5vw;
        min-width: 50px;
        min-height: 50px;
    }

    .modal-header-controls button svg {
        width: 1.8vw;
        height: 1.8vw;
        min-width: 24px;
        min-height: 24px;
    }

    .modal-header h2 {
        font-size: 2vw;
    }

    /* Кнопка рядов активности */
    #activity-mode-btn {
        width: 3.5vw;
        height: 3.5vw;
        min-width: 50px;
        min-height: 50px;
        font-size: 1.8vw;
    }
}



/* =========================================
   КНОПКА ПОИСКА В ШАПКЕ (только мобильные)
   ========================================= */
#solubility-search-btn {
    display: none;
    /* По умолчанию скрыта на ПК */
}

#solubility-close-btn {
    display: flex;
}

#solubility-search-btn,
#solubility-close-btn {
    width: 40px;
    height: 40px;
    border: none;
    appearance: none;
    -webkit-appearance: none;
    border-radius: 8px;
    background: rgba(33, 150, 243, 0.15);
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    align-items: center;
    justify-content: center;
}

#solubility-search-btn svg,
#solubility-close-btn svg {
    width: 22px;
    height: 22px;
    color: #2196F3;
}

#solubility-search-btn:hover,
#solubility-close-btn:hover {
    background: rgba(33, 150, 243, 0.3);
    transform: scale(1.1);
}

#solubility-search-btn.active {
    background: #2196F3;
}

#solubility-search-btn.active svg {
    color: white;
}

body.dark-theme #solubility-search-btn,
body.dark-theme #solubility-close-btn {
    background: rgba(100, 181, 246, 0.2);
}

body.dark-theme #solubility-search-btn svg,
body.dark-theme #solubility-close-btn svg {
    color: #64B5F6;
}

body.dark-theme #solubility-search-btn:hover,
body.dark-theme #solubility-close-btn:hover {
    background: rgba(100, 181, 246, 0.4);
}

body.dark-theme #solubility-search-btn.active {
    background: #64B5F6;
}

body.dark-theme #solubility-search-btn.active svg {
    color: #1a1a2e;
}

/* =========================================
   ПАНЕЛЬ ПОИСКА (только мобильные)
   ========================================= */
.solubility-search-panel {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: calc(100% - 40px);
    max-width: 400px;
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
    z-index: 2100;
    animation: searchPanelSlideIn 0.3s ease-out;
}

.solubility-search-panel.active {
    display: block;
}

@keyframes searchPanelSlideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
    }

    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

.solubility-search-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    background: #f5f5f5;
    border-bottom: 1px solid #e0e0e0;
    border-radius: 12px 12px 0 0;
}

.solubility-search-header h4 {
    margin: 0;
    font-size: 16px;
    color: #333;
}

.close-solubility-search {
    font-size: 18px;
    cursor: pointer;
    color: #999;
    line-height: 1;
    padding: 5px;
}

.close-solubility-search:hover {
    color: #333;
}

.solubility-search-content {
    padding: 15px;
}

.solubility-search-content .search-wrapper {
    position: relative;
    display: flex;
    align-items: center;
}

.solubility-search-content #solubility-search-input {
    width: 100%;
    padding: 12px 80px 12px 12px;
    font-size: 16px;
    border: 2px solid #ddd;
    border-radius: 8px;
    outline: none;
    transition: border-color 0.2s;
}

.solubility-search-content #solubility-search-input:focus {
    border-color: #2196F3;
}

.solubility-search-clear {
    position: absolute;
    right: 45px;
    background: none;
    border: none;
    font-size: 16px;
    color: #999;
    cursor: pointer;
    padding: 5px;
    display: none;
}

.solubility-search-clear.visible {
    display: block;
}

.solubility-search-clear:hover {
    color: #333;
}

.solubility-search-content .search-btn {
    position: absolute;
    right: 8px;
    width: 32px;
    height: 32px;
    background: #2196F3;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.solubility-search-content .search-btn:hover {
    background: #1976D2;
}

.solubility-search-content .search-btn svg {
    width: 18px;
    height: 18px;
    color: #fff;
}

/* Тёмная тема для панели поиска */
body.dark-theme .solubility-search-panel {
    background: #2d2d44;
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
}

body.dark-theme .solubility-search-header {
    background: #252535;
    border-bottom-color: #444;
}

body.dark-theme .solubility-search-header h4 {
    color: #eee;
}

body.dark-theme .close-solubility-search {
    color: #666;
}

body.dark-theme .close-solubility-search:hover {
    color: #fff;
}

body.dark-theme .solubility-search-content #solubility-search-input {
    background: #1f1f2e;
    border-color: #444;
    color: #eee;
}

body.dark-theme .solubility-search-content #solubility-search-input:focus {
    border-color: #64B5F6;
}

body.dark-theme .solubility-search-content #solubility-search-input::placeholder {
    color: #666;
}

body.dark-theme .solubility-search-clear {
    color: #666;
}

body.dark-theme .solubility-search-clear:hover {
    color: #fff;
}

body.dark-theme .solubility-search-content .search-btn {
    background: #64B5F6;
}

body.dark-theme .solubility-search-content .search-btn:hover {
    background: #90CAF9;
}

/* =========================================
   ПАНЕЛЬ РЯДОВ АКТИВНОСТИ
   ========================================= */

@keyframes slideDown {
    from {
        opacity: 0;
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
    }

    to {
        opacity: 1;
        max-height: 1000px;
        padding-top: 20px;
        padding-bottom: 20px;
    }
}



.series-container.active {
    display: block;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}

/* Маркер водорода */
.hydrogen-marker {
    color: #ff5722;
    font-weight: bold;
    font-size: 1.1em;
}

.activity-series-content h4 {
    margin: 15px 0 8px 0;
    font-size: 1.1em;
    color: var(--text-color);
}

.activity-series-row {
    padding: 12px 15px;
    background: rgba(255, 193, 7, 0.1);
    border-left: 4px solid #FFC107;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 1.1em;
    overflow-x: auto;
    white-space: nowrap;
    color: var(--text-color);
}

body.dark-theme .activity-series-row {
    background: rgba(255, 213, 79, 0.15);
    border-left-color: #FFD54F;
}




/* Стили для кнопки Ряда Активности (Желтая) */
#activity-mode-btn {
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 8px;
    background: rgba(255, 193, 7, 0.15);
    /* Желтоватый фон */
    color: #FFC107;
    /* Желтая молния */
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

#activity-mode-btn:hover {
    background: rgba(255, 193, 7, 0.3);
    transform: scale(1.1);
}

#activity-mode-btn.active {
    background: #FFC107;
    color: #fff;
    /* Белая молния при активе */
    box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
}

/* Темная тема для кнопки */
body.dark-theme #activity-mode-btn {
    background: rgba(255, 213, 79, 0.2);
    color: #FFD54F;
}

body.dark-theme #activity-mode-btn:hover {
    background: rgba(255, 213, 79, 0.4);
}

body.dark-theme #activity-mode-btn.active {
    background: #FFD54F;
    color: #333;
}

/* Стили для кнопки продвинутого режима информации */
#advanced-mode-info-btn {
    width: 40px;
    height: 40px;
    border: none;
    border-radius: 8px;
    background: rgba(103, 58, 183, 0.15);
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
}

#advanced-mode-info-btn:hover {
    background: rgba(103, 58, 183, 0.3);
    transform: scale(1.1);
}

#advanced-mode-info-btn.active {
    background: var(--accent-color, #646cff);
    color: white;
    box-shadow: 0 0 12px var(--accent-color, #646cff);
}

body.dark-theme #advanced-mode-info-btn {
    background: rgba(100, 181, 246, 0.2) !important;
    /* Синий цвет для темной темы */
}

body.dark-theme #advanced-mode-info-btn:hover {
    background: rgba(100, 181, 246, 0.4) !important;
    /* Синий цвет для темной темы */
}

body.dark-theme #advanced-mode-info-btn.active {
    background: #64B5F6 !important;
    /* Синий цвет для темной темы */
    box-shadow: 0 0 12px #64B5F6 !important;
    /* Синий цвет для темной темы */
}

/* --- КОНТЕЙНЕР РЯДА АКТИВНОСТИ --- */


/* Исправление отображения списка (Убираем скролл, добавляем перенос) */
.activity-list-container {
    display: flex;
    flex-wrap: wrap;
    /* РАЗРЕШАЕМ ПЕРЕНОС */
    gap: 8px;
    /* Отступы между элементами */
    align-items: center;
    justify-content: center;
    /* Центрируем */
}





/* === css/solubility.css === */

/* Добавляем поддержку безопасных зон (вырезов) и отступы */
.solubility-container {
    /* ... существующие стили ... */

    /* Добавляем padding для закругленных углов и вырезов */
    padding-left: max(16px, env(safe-area-inset-left));
    padding-right: max(16px, env(safe-area-inset-right));
    padding-bottom: env(safe-area-inset-bottom);
    width: 100%;
    box-sizing: border-box;
    /* Чтобы padding не ломал ширину */
}

/* Исправляем шапку для мобильных устройств */
.solubility-header {
    display: flex;
    flex-wrap: wrap;
    /* Разрешаем перенос элементов */
    gap: 10px;
    /* Отступ между элементами */
    align-items: center;
    justify-content: space-between;
    padding: 10px 0;
}



/* =========================================
   ЕДИНСТВЕННЫЙ МОБИЛЬНЫЙ БЛОК (Full Screen App-like)
   ========================================= */
@media (max-width: 1024px) {

    /* 1. МОДАЛЬНОЕ ОКНО - Минимальные отступы слева, справа */
    #solubility-modal {
        height: 100dvh !important;
        width: 100vw !important;
        padding: 0 !important;
        /* Отступы только слева и справа */
        padding-left: max(8px, env(safe-area-inset-left)) !important;
        padding-right: max(8px, env(safe-area-inset-right)) !important;
        /* Снизу - ТОЛЬКО safe-area, без минимальных 8px */
        padding-bottom: env(safe-area-inset-bottom, 0px) !important;
        margin: 0 !important;
        align-items: flex-start;
        justify-content: center;
        overflow: auto;
        box-sizing: border-box;
    }

    /* 2. КОНТЕНТ - На 100% пространства родителя */
    .solubility-content {
        width: 100% !important;
        height: 100% !important;
        max-width: 100% !important;
        max-height: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        border-radius: 8px !important;
        /* Небольшие закругления */
        display: flex;
        flex-direction: column;
        overflow: auto;
        box-sizing: border-box;
    }

    /* 3. ШАПКА - Вертикальное расположение (заголовок → кнопки) */
    .modal-header {
        flex-shrink: 0;
        /* Не сжимается */
        flex-direction: column;
        /* Вертикальное расположение */
        align-items: center;
        /* Центрируем */
        gap: 12px;
        padding: 15px 20px;
        padding-top: calc(env(safe-area-inset-top) + 15px) !important;
        /* Учитываем "челку" */
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
        background-color: var(--bg-color);
        border-bottom: 1px solid var(--border-color);
        box-sizing: border-box;
    }

    .modal-header h2 {
        font-size: 1.3rem;
        margin: 0;
        text-align: center;
        width: 100%;
    }

    /* Контейнер кнопок управления */
    .modal-header-controls {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
    }

    /* 4. ЛЕГЕНДА */
    .table-legend {
        flex-shrink: 0;
        padding: 10px 20px;
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
        font-size: 0.85em;
        flex-wrap: wrap;
        gap: 10px;
        box-sizing: border-box;
    }

    /* 5. СКРОЛЛ - ТОЛЬКО внутри таблицы, БЕЗ лишних отступов */
    .solubility-wrapper {
        flex: 1;
        width: 100%;
        overflow-x: auto;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        /* Полностью убираем отступы - никакого белого пространства */
        padding: 0 !important;
        box-sizing: border-box;

        /* Кастомный стиль скроллбара (как в уравнивателе) */
        scrollbar-width: thin;
        scrollbar-color: #bbdefb transparent;
    }

    /* Используем общий стиль скроллбара, но с меньшей шириной для компактности */
    .solubility-wrapper::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    .solubility-wrapper::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.03);
        border-radius: 3px;
    }

    .solubility-wrapper::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #2196F3, #64B5F6);
        border-radius: 3px;
    }

    .solubility-wrapper::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #1976D2, #2196F3);
    }

    /* Тёмная тема */
    body.dark-theme .solubility-wrapper::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.03);
    }

    body.dark-theme .solubility-wrapper::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #64B5F6, #90CAF9);
    }

    body.dark-theme .solubility-wrapper::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #42A5F5, #64B5F6);
    }

    /* 6. ТАБЛИЦА - Компактные ячейки */
    #solubility-table {
        font-size: 13px;
    }

    #solubility-table th,
    #solubility-table td {
        padding: 6px 4px;
        font-size: 0.9em;
    }

    /* Заголовки анионов - компактные */
    #solubility-table tbody th {
        min-width: 60px;
        max-width: 80px;
        font-size: 0.75em;
        padding: 6px 4px;
    }

    /* Скрываем полное название аниона, оставляем только формулу */
    #solubility-table tbody th span {
        display: none;
    }

    /* 7. КНОПКИ - Удобные для touch (минимум 44x44px) */
    .modal-header-controls button,
    #activity-series-btn,
    #color-mode-btn,
    #activity-mode-btn,
    #advanced-mode-info-btn,
    #solubility-search-btn {
        min-width: 44px !important;
        min-height: 44px !important;
        width: 44px !important;
        height: 44px !important;
        font-size: 20px;
    }

    /* Уменьшаем размер кнопок на iPhone для более компактного отображения */
    body.device-iphone .modal-header-controls button,
    body.device-iphone #activity-series-btn,
    body.device-iphone #color-mode-btn,
    body.device-iphone #activity-mode-btn,
    body.device-iphone #advanced-mode-info-btn,
    body.device-iphone #solubility-search-btn {
        min-width: 38px !important;
        min-height: 38px !important;
        width: 38px !important;
        height: 38px !important;
    }

    /* SVG иконки на мобильных - максимально увеличиваем для iPhone */
    .modal-header-controls button svg {
        width: 30px;
        height: 30px;
    }

    /* Дополнительные стили для iPhone - увеличиваем размер SVG иконок */
    body.device-iphone .modal-header-controls button svg,
    body.device-iphone #activity-series-btn svg,
    body.device-iphone #color-mode-btn svg,
    body.device-iphone #activity-mode-btn svg,
    body.device-iphone #advanced-mode-info-btn svg,
    body.device-iphone #solubility-search-btn svg {
        width: 34px !important;
        height: 34px !important;
        min-width: 34px !important;
        min-height: 34px !important;
        max-width: 34px !important;
        max-height: 34px !important;
    }

    /* Еще более конкретные правила для кнопок в шапке таблицы растворимости на iPhone */
    body.device-iphone #solubility-modal .modal-header .modal-header-controls #color-mode-btn svg,
    body.device-iphone #solubility-modal .modal-header .modal-header-controls #activity-mode-btn svg,
    body.device-iphone #solubility-modal .modal-header .modal-header-controls #advanced-mode-info-btn svg {
        width: 34px !important;
        height: 34px !important;
        min-width: 34px !important;
        min-height: 34px !important;
        max-width: 34px !important;
        max-height: 34px !important;
    }

    /* Альтернативные стили для устройств Apple (iPhone) через медиа-запросы */
    @media screen and (-webkit-min-device-pixel-ratio: 2) and (max-device-width: 768px) and (device-width: 375px),
    screen and (-webkit-min-device-pixel-ratio: 2) and (max-device-width: 768px) and (device-width: 414px),
    screen and (-webkit-min-device-pixel-ratio: 2) and (max-device-width: 768px) and (device-width: 320px),
    screen and (-webkit-min-device-pixel-ratio: 3) and (device-width: 414px) and (device-height: 896px),
    screen and (-webkit-min-device-pixel-ratio: 3) and (device-width: 375px) and (device-height: 812px),
    screen and (-webkit-min-device-pixel-ratio: 2) and (device-width: 414px) and (device-height: 736px) {

        #solubility-modal .modal-header .modal-header-controls #color-mode-btn svg,
        #solubility-modal .modal-header .modal-header-controls #activity-mode-btn svg,
        #solubility-modal .modal-header .modal-header-controls #advanced-mode-info-btn svg,
        #solubility-modal .modal-header .modal-header-controls #solubility-search-btn svg {
            width: 34px !important;
            height: 34px !important;
            min-width: 34px !important;
            min-height: 34px !important;
            max-width: 34px !important;
            max-height: 34px !important;
        }
    }

    /* Увеличиваем размер SVG иконок для специфических кнопок в таблице растворимости на iPhone */
    body.device-iphone .modal-header-controls #color-mode-btn svg,
    body.device-iphone .modal-header-controls #activity-mode-btn svg,
    body.device-iphone .modal-header-controls #advanced-mode-info-btn svg {
        width: 34px !important;
        height: 34px !important;
    }

    /* Кнопка закрытия */
    #solubility-close-btn {
        min-width: 44px !important;
        min-height: 44px !important;
        width: 44px !important;
        height: 44px !important;
        padding: 0 !important;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* 8. КНОПКА ПОИСКА - Показываем на мобильных */
    #solubility-search-btn {
        display: flex;
    }

    /* 9. ПАНЕЛЬ АКТИВНОСТИ - Компактная */
    .activity-series-row {
        font-size: 0.9em;
        padding: 10px;
    }

    .activity-series-content h4 {
        font-size: 1em;
    }

    /* 10. ПАНЕЛЬ РЯД АКТИВНОСТИ */
    .activity-series-panel {
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
    }

    /* 11. КОНТЕЙНЕР РЯДА АКТИВНОСТИ */
    #activity-series-container {
        padding-left: max(20px, env(safe-area-inset-left)) !important;
        padding-right: max(20px, env(safe-area-inset-right)) !important;
    }

    /* 12. УБИРАЕМ СИНЮЮ ПОЛОСКУ ВНИЗУ */
    /* Убираем border-bottom, НО НЕ у ячеек таблицы */
    #solubility-modal *:not(.modal-header):not(.table-legend):not(.activity-series-panel):not(td):not(th):not(.focused-cell):not(.active-row):not(.active-col) {
        border-bottom: none !important;
    }

    /* Убираем любые синие индикаторы и псевдоэлементы */
    .solubility-content::after,
    .solubility-wrapper::after,
    #solubility-table::after,
    progress {
        display: none !important;
    }
}

/* === СТИЛИ ДЛЯ РЯДА АКТИВНОСТИ === */

.act-item:active {
    transform: translateY(-1px);
}

/* =========================================
   СТИЛИ ДЛЯ РЯДА АКТИВНОСТИ (ФИНАЛ)
   ========================================= */

/* Контейнер панели - CSS Grid анимация (без фиксированных пикселей) */
.activity-series-panel {
    width: 100%;
    background: #f8f9fa;
    box-sizing: border-box;
    border-bottom: none;

    /* CSS Grid trick для анимации высоты */
    display: grid;
    grid-template-rows: 0fr;
    justify-items: center;
    opacity: 0;
    padding: 0 10px;

    /* Анимация закрытия: opacity затухает вместе с высотой */
    transition: grid-template-rows 0.35s ease-in,
        opacity 0.35s ease-in,
        padding 0.35s ease-in;
}

/* Внутренний wrapper (обязательно для grid trick) */
.activity-series-panel>.activity-content-wrapper,
.activity-series-panel>.activity-series-content {
    overflow: visible;
    min-height: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

/* Активное состояние - полностью открыто */
.activity-series-panel.active {
    grid-template-rows: 1fr;
    opacity: 1;
    padding: 20px 10px;
    border-bottom: 1px solid #e0e0e0;

    /* Анимация открытия: быстрее */
    transition: grid-template-rows 0.35s ease-out,
        opacity 0.25s ease-out,
        padding 0.35s ease-out;
}

.activity-content-wrapper {
    width: 100%;
    max-width: 900px;
    /* Ограничиваем ширину для красоты */
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Заголовок и кнопка в одной строке */
.activity-header {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    /* Расстояние между текстом и кнопкой */
    margin-bottom: 15px;
    flex-wrap: wrap;
    /* На совсем мелких экранах перенесется */
}

.activity-header h4 {
    margin: 0;
    color: #333;
    font-size: 16px;
    text-align: center;
}

/* Кнопка переключения */
.toggle-series-btn {
    padding: 6px 14px;
    border: 1px solid #2196F3;
    background: #e3f2fd;
    color: #1976D2;
    border-radius: 16px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: background 0.2s;
    white-space: nowrap;
    position: relative;
    z-index: 10;
    /* Увеличили z-index для гарантии отображения поверх */
    margin-bottom: 8px;
    /* Увеличили отступ снизу */
}

.toggle-series-btn:hover {
    background: #bbdefb;
}

/* Контейнер для карточек */
.series-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 6px;
    padding-top: 5px;
}

/* КОМПАКТНЫЕ КАРТОЧКИ ЭЛЕМЕНТОВ */
.act-item {
    width: 36px;
    height: 40px;
    font-size: 14px;

    display: flex;
    align-items: center;
    justify-content: center;
    background: #ffffff;
    border: 1px solid #ccc;
    border-radius: 6px;
    font-weight: bold;
    color: #333;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    user-select: none;

    /* Плавные анимации */
    transition: transform 0.2s ease,
        border-color 0.2s ease,
        opacity 0.3s ease,
        box-shadow 0.2s ease;

    /* Анимация появления */
    animation: cardFadeIn 0.4s ease backwards;
    -webkit-tap-highlight-color: transparent;
}

/* Последовательное появление карточек */
.act-item:nth-child(1) {
    animation-delay: 0.02s;
}

.act-item:nth-child(3) {
    animation-delay: 0.04s;
}

.act-item:nth-child(5) {
    animation-delay: 0.06s;
}

.act-item:nth-child(7) {
    animation-delay: 0.08s;
}

.act-item:nth-child(9) {
    animation-delay: 0.10s;
}

.act-item:nth-child(11) {
    animation-delay: 0.12s;
}

.act-item:nth-child(13) {
    animation-delay: 0.14s;
}

.act-item:nth-child(15) {
    animation-delay: 0.16s;
}

.act-item:nth-child(17) {
    animation-delay: 0.18s;
}

.act-item:nth-child(19) {
    animation-delay: 0.20s;
}

.act-item:nth-child(21) {
    animation-delay: 0.22s;
}

.act-item:nth-child(23) {
    animation-delay: 0.24s;
}

.act-item:nth-child(25) {
    animation-delay: 0.26s;
}

.act-item:nth-child(27) {
    animation-delay: 0.28s;
}

.act-item:nth-child(29) {
    animation-delay: 0.30s;
}

.act-item:nth-child(31) {
    animation-delay: 0.32s;
}

.act-item:nth-child(33) {
    animation-delay: 0.34s;
}

.act-item:nth-child(35) {
    animation-delay: 0.36s;
}

.act-item:nth-child(37) {
    animation-delay: 0.38s;
}

.act-item:nth-child(39) {
    animation-delay: 0.40s;
}

.act-item:nth-child(41) {
    animation-delay: 0.42s;
}

.act-item:nth-child(43) {
    animation-delay: 0.44s;
}

.act-item:nth-child(45) {
    animation-delay: 0.46s;
}

.act-item:nth-child(47) {
    animation-delay: 0.48s;
}

.act-item:nth-child(49) {
    animation-delay: 0.50s;
}

.act-item:nth-child(51) {
    animation-delay: 0.52s;
}

@keyframes cardFadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px) scale(0.9);
    }

    to {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
}

.act-item:hover {
    transform: translateY(-2px);
    border-color: #2196F3;
    color: #2196F3;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 2;
}

/* Водород */
.act-item.hydrogen {
    border-color: #ff5252;
    background: #fff5f5;
    color: #d32f2f;
}

/* Стрелочка */
.act-arrow {
    color: #bdbdbd;
    font-size: 12px;
    user-select: none;
}

/* Подпись снизу */
.activity-note {
    margin-top: 15px;
    color: #888;
    font-size: 12px;
    text-align: center;
}

/* --- ТЕМНАЯ ТЕМА --- */
body.dark-theme .activity-series-panel {
    background: #252535;
    border-bottom-color: #444;
}

body.dark-theme .activity-header h4 {
    color: #eee;
}

body.dark-theme .activity-note {
    color: #aaa;
}

body.dark-theme .act-item {
    background: #3d3d5c;
    border-color: #555;
    color: #eee;
}

body.dark-theme .act-item:hover {
    border-color: #64B5F6;
    color: #64B5F6;
    background: #4a4a6a;
}

body.dark-theme .act-item.hydrogen {
    background: #4a2c2c;
    border-color: #e57373;
    color: #e57373;
}

body.dark-theme .act-arrow {
    color: #666;
}

body.dark-theme .toggle-series-btn {
    background: #2d2d44;

    border-color: #64B5F6;
    color: #64B5F6;
}

/* =========================================
   АДАПТАЦИЯ РЯДА АКТИВНОСТИ ПОД БОЛЬШИЕ ЭКРАНЫ
   ========================================= */
@media (min-width: 1024px) {

    /* 1. Увеличиваем размер карточек */
    .act-item {
        width: 64px;
        height: 54px;
        font-size: 18px;
        border-radius: 8px;
    }

    /* 2. Увеличиваем стрелочки */
    .act-arrow {
        font-size: 16px;
        margin: 0 2px;
    }

    /* 3. Увеличиваем заголовок */
    .activity-header h4 {
        font-size: 20px;
    }

    /* 4. Увеличиваем кнопку переключения */
    .toggle-series-btn {
        padding: 8px 18px;
        font-size: 14px;
        border-radius: 20px;
    }

    /* 5. Увеличиваем подпись снизу */
    .activity-note {
        font-size: 14px;
        margin-top: 20px;
    }

    /* 6. Чуть больше отступы в контейнере */
    .series-container {
        gap: 8px;
        padding-top: 10px;
    }
}

body.dark-theme .toggle-series-btn:hover {
    background: rgba(33, 150, 243, 0.15);
}

/* ============================================================
   ЛОГИКА ОТОБРАЖЕНИЯ РЯДА АКТИВНОСТИ (Мобильные vs ПК)
   ============================================================ */

/* ПК (по умолчанию): Работает как "шторка" (accordion).
   CSS для этого уже есть в файле (классы .activity-series-panel.active).
   Таблица остается на месте, просто сдвигается вниз.
*/

/* МОБИЛЬНЫЕ: Ряд активности ЗАМЕЩАЕТ таблицу
*/
@media (max-width: 1024px) {

    /* 1. Когда панель активна, она растягивается на все доступное место */
    .activity-series-panel.active {
        flex-grow: 1;
        /* Занимаем пространство, которое раньше занимала таблица */
        max-height: none;
        /* Отключаем ограничение высоты "шторки" */
        overflow-y: auto;
        /* Разрешаем скролл внутри панели, если элементов много */
        padding-bottom: 20px;
        /* Отступ снизу для удобства */
    }

    /* 2. Когда панель активна, СКРЫВАЕМ таблицу, идущую следом */
    /* Знак "+" означает "соседний элемент сразу после" */
    .activity-series-panel.active+.solubility-wrapper {
        display: none !important;
    }
}

/* =========================================
   ������� � ��������� ����
   ========================================= */
/* =========================================
   ACTIVITY GRID FIX (STRICT LAYOUT)
   ========================================= */
.activity-content-wrapper {
    align-items: stretch;
}

.series-container.activity-grid {
    display: grid !important;
    width: min(100%, 1380px);
    margin: 0 auto;
    --activity-gap-x: 28px;
    --activity-gap-y: 14px;
    column-gap: var(--activity-gap-x);
    row-gap: var(--activity-gap-y);
    padding-inline: calc(var(--activity-gap-x) / 2);
    box-sizing: border-box;
    grid-auto-flow: row;
    justify-items: stretch;
    align-items: stretch;
    overflow: visible;
}

.series-container.activity-grid.activity-grid--metals {
    grid-template-columns: repeat(12, minmax(0, 1fr));
}

.series-container.activity-grid.activity-grid--nonmetals {
    grid-template-columns: repeat(10, minmax(0, 1fr));
}

.series-container.activity-grid .act-item {
    width: 100%;
    min-height: 44px;
    height: auto;
    aspect-ratio: 1 / 1;
    padding: 0;
    font-size: 14px;
    position: relative;
    overflow: visible;
}

.series-container.activity-grid .act-item.has-next::after {
    content: "\2192";
    display: block;
    position: absolute;
    left: calc(100% + (var(--activity-gap-x) / 2));
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 16px;
    font-weight: 700;
    font-family: "Segoe UI Symbol", "Noto Sans Symbols2", "Arial Unicode MS", sans-serif;
    line-height: 1;
    color: #7e8da5;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
    z-index: 5;
    pointer-events: none;
}

body.dark-theme .series-container.activity-grid .act-item.has-next::after {
    color: #dbe8ff;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.55);
}

@media (max-width: 1180px) {
    .series-container.activity-grid {
        --activity-gap-x: 22px;
    }

    .series-container.activity-grid.activity-grid--metals {
        grid-template-columns: repeat(10, minmax(0, 1fr));
    }

    .series-container.activity-grid.activity-grid--nonmetals {
        grid-template-columns: repeat(8, minmax(0, 1fr));
    }
}

@media (max-width: 980px) {
    .series-container.activity-grid {
        --activity-gap-x: 18px;
    }

    .series-container.activity-grid.activity-grid--metals {
        grid-template-columns: repeat(8, minmax(0, 1fr));
    }

    .series-container.activity-grid.activity-grid--nonmetals {
        grid-template-columns: repeat(6, minmax(0, 1fr));
    }
}

@media (max-width: 760px) {
    .series-container.activity-grid {
        --activity-gap-x: 10px;
        --activity-gap-y: 9px;
    }

    .series-container.activity-grid.activity-grid--metals {
        grid-template-columns: repeat(7, minmax(0, 1fr));
    }

    .series-container.activity-grid.activity-grid--nonmetals {
        grid-template-columns: repeat(5, minmax(0, 1fr));
    }

    .series-container.activity-grid .act-item {
        min-height: 36px;
        font-size: 13px;
    }

    .series-container.activity-grid .act-item.has-next::after {
        font-size: 13px;
    }
}

@media (max-width: 520px) {
    .series-container.activity-grid {
        --activity-gap-x: 7px;
        --activity-gap-y: 7px;
    }

    .series-container.activity-grid.activity-grid--metals {
        grid-template-columns: repeat(6, minmax(0, 1fr));
    }

    .series-container.activity-grid.activity-grid--nonmetals {
        grid-template-columns: repeat(5, minmax(0, 1fr));
    }

    .series-container.activity-grid .act-item {
        min-height: 31px;
        font-size: 12px;
    }

    .series-container.activity-grid .act-item.has-next::after {
        font-size: 12px;
    }
}

/* Стрелка переноса ряда (ставится динамически JS-классом .row-end-turn) */
.series-container.activity-grid .act-item.row-end-turn::after {
    content: "\21A9";
    left: calc(100% + (var(--activity-gap-x) / 2));
    top: calc(100% + (var(--activity-gap-y) / 2));
    transform: translate(-50%, -50%);
    font-size: 17px;
}

@media (max-width: 760px) {
    .series-container.activity-grid .act-item.row-end-turn::after {
        font-size: 14px;
    }
}

@media (max-width: 520px) {
    .series-container.activity-grid .act-item.row-end-turn::after {
        font-size: 13px;
    }
}

/* На больших экранах сохраняем тот же масштаб, без увеличения */
@media (min-width: 1024px) {
    .series-container.activity-grid .act-item {
        min-height: 44px;
        font-size: 14px;
    }

    .series-container.activity-grid .act-item.has-next::after {
        font-size: 16px;
    }
}

#reactions-modal {
    display: none;
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    justify-content: flex-start;
    align-items: center;
}

html.reactions-open,
body.reactions-open {
    overflow: auto;
}

.reactions-content {
    display: flex;
    flex-direction: column;
}

#reactions-modal .modal-header {
    padding: 12px 18px;
}

#reactions-modal .modal-header h2 {
    font-size: 1.35rem;
    letter-spacing: 0.2px;
}

.reactions-title {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.reactions-subtitle {
    margin: 0;
    font-size: 0.92rem;
    color: var(--text-muted, #5c6470);
    font-weight: 500;
}

.reactions-body {
    flex: 1;
    display: grid;
    gap: 12px;
    overflow: auto;
    padding: 16px 18px 18px;
    background-color: var(--bg-color);
}

/* Кнопка закрытия (унифицированная со стилем таблицы растворимости) */
.close-reactions {
    width: 40px;
    height: 40px;
    border: none;
    appearance: none;
    -webkit-appearance: none;
    border-radius: 8px;
    background: rgba(33, 150, 243, 0.15);
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-reactions svg {
    width: 22px;
    height: 22px;
    color: #2196F3;
}

@media (hover: hover) {
    .close-reactions:hover {
        background: rgba(33, 150, 243, 0.3);
        transform: scale(1.1);
    }
}

.reactions-placeholder {
    display: grid;
    gap: 8px;
    padding: 10px 0;
}

.reactions-input-block,
.reactions-output-block {
    display: grid;
    gap: 8px;
    padding: 12px 14px;
    border-radius: 14px;
    background: #f6f7fb;
    border: 1px solid rgba(60, 80, 120, 0.2);
}

.reactions-input-primary {
    border-color: rgba(70, 130, 255, 0.35);
    box-shadow: 0 6px 16px rgba(70, 130, 255, 0.08);
}

.reactions-output-secondary {
    background: #eef3ff;
    border-color: rgba(80, 100, 150, 0.18);
}

.reactions-input-block label,
.reactions-output-block label {
    font-size: 0.95rem;
    color: var(--text-color);
}

.reactions-hint {
    font-size: 0.86rem;
    color: var(--text-muted, #5b6370);
}

.reactions-status {
    font-size: 0.9rem;
    color: var(--text-color);
    padding: 10px 12px;
    border-radius: 12px;
    background: rgba(120, 140, 190, 0.1);
    border: 1px dashed rgba(120, 140, 190, 0.3);
}

.reactions-input-block textarea,
.reactions-output-block textarea {
    width: 100%;
    min-height: 64px;
    padding: 10px 12px;
    border-radius: 10px;
    border: 1px solid rgba(60, 80, 120, 0.22);
    background: #ffffff;
    color: var(--text-color);
    font-size: 1rem;
    line-height: 1.45;
    resize: vertical;
}

.reactions-output-block textarea {
    min-height: 90px;
    background: #f2f5ff;
    font-family: "JetBrains Mono", "Fira Code", Consolas, monospace;
    cursor: default;
}

.reactions-input-block textarea:focus,
.reactions-output-block textarea:focus {
    outline: none;
    border-color: rgba(70, 130, 255, 0.7);
    box-shadow: 0 0 0 3px rgba(70, 130, 255, 0.2);
}

body.dark-theme .reactions-input-block textarea,
body.dark-theme .reactions-output-block textarea {
    background: rgba(12, 16, 34, 0.9);
    border-color: rgba(140, 160, 200, 0.2);
}

.dark-theme .reactions-output-block textarea {
    background: rgba(16, 22, 44, 0.85);
}

body.dark-theme .reactions-subtitle {
    color: rgba(220, 230, 255, 0.65);
}

body.dark-theme .reactions-hint {
    color: rgba(200, 210, 230, 0.7);
}

body.dark-theme .reactions-input-block,
body.dark-theme .reactions-output-block {
    background: rgba(20, 24, 46, 0.55);
    border-color: rgba(110, 130, 180, 0.25);
}

body.dark-theme .close-reactions {
    background: rgba(100, 181, 246, 0.2);
}

body.dark-theme .close-reactions svg {
    color: #64B5F6;
}

@media (hover: hover) {
    body.dark-theme .close-reactions:hover {
        background: rgba(100, 181, 246, 0.4);
    }
}

body.dark-theme .reactions-output-secondary {
    background: rgba(16, 22, 44, 0.9);
    border-color: rgba(120, 150, 210, 0.22);
}

body.dark-theme .reactions-status {
    background: rgba(100, 120, 170, 0.18);
    border-color: rgba(130, 160, 220, 0.3);
    color: rgba(230, 240, 255, 0.9);
}

.reactions-examples {
    display: grid;
    gap: 8px;
    margin-top: 48px;
    color: var(--text-color);
}

.reactions-chips {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.reactions-chips button {
    border: 1px solid rgba(60, 80, 120, 0.25);
    background: #f1f4fa;
    color: var(--text-color);
    padding: 8px 12px;
    border-radius: 999px;
    cursor: pointer;
    font-size: 0.95rem;
    transition: transform 0.15s ease, border-color 0.15s ease, background 0.15s ease;
}

body.dark-theme .reactions-chips button {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(140, 160, 200, 0.25);
}

.reactions-chips button:hover {
    border-color: rgba(70, 130, 255, 0.7);
    background: rgba(70, 130, 255, 0.12);
    transform: translateY(-1px);
}

.reactions-chips button:active {
    transform: translateY(0);
    background: rgba(70, 130, 255, 0.18);
}

#reactions-modal textarea::placeholder {
    color: rgba(110, 120, 140, 0.85);
}

body.dark-theme #reactions-modal textarea::placeholder {
    color: rgba(190, 200, 220, 0.6);
}

/* �������: ������ �������������� ������, ������� �� ������ */
#reactions-modal .modal-content.solubility-content.reactions-content {
    max-width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter));
    width: calc(100vw - var(--solubility-left-gutter) - var(--solubility-right-gutter));
    margin-left: var(--solubility-left-gutter);
    margin-right: auto;
    box-sizing: border-box;
    height: min(88vh, 820px);
}

#reactions-modal .reactions-body,
#reactions-modal .reactions-content {
    overflow-x: hidden;
}

/* �������: ���������� �������, ��������� ���������� ��������������� ������� */
#reactions-modal {
    justify-content: flex-start;
}

@media (max-width: 1024px),
(max-height: 740px) {
    #reactions-modal .modal-content.solubility-content.reactions-content {
        height: 95vh;
    }

    .reactions-body {
        overflow: auto;
        -webkit-overflow-scrolling: touch;
    }
}

/* =========================================
   Мобильная адаптация модалки "Реакции"
   ========================================= */

/* Анимация появления модалки */
@keyframes reactions-slide-up {
    from {
        opacity: 0;
        transform: translateY(20px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes reactions-fade-in {
    from {
        opacity: 0;
    }

    to {
        opacity: 1;
    }
}

/* Планшеты (768px) */
@media (max-width: 768px) {
    :root {
        --solubility-right-gutter: 80px;
    }

    #reactions-modal {
        animation: reactions-fade-in 0.25s ease-out;
    }

    #reactions-modal .modal-content.solubility-content.reactions-content {
        width: calc(100vw - 12px - var(--solubility-right-gutter));
        max-width: calc(100vw - 12px - var(--solubility-right-gutter));
        margin-left: 12px;
        height: 96vh;
        animation: reactions-slide-up 0.3s ease-out;
    }

    #reactions-modal .modal-header {
        padding: 14px 18px;
    }

    #reactions-modal .modal-header h2 {
        font-size: 1.2rem;
    }

    .reactions-subtitle {
        font-size: 0.88rem;
    }

    .reactions-body {
        padding: 16px 18px 20px;
        gap: 14px;
    }

    .reactions-input-block,
    .reactions-output-block {
        padding: 14px 16px;
        border-radius: 16px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    }

    .reactions-chips button {
        padding: 10px 16px;
        font-size: 0.92rem;
        transition: all 0.2s ease;
    }
}

/* Телефоны (600px) — основной мобильный брейкпоинт */
@media (max-width: 600px) {
    :root {
        --solubility-right-gutter: 0px;
    }

    #reactions-modal .modal-content.solubility-content.reactions-content {
        width: 100vw;
        max-width: 100vw;
        margin: 0;
        height: 100vh;
        height: 100dvh;
        border-radius: 0;
        background: linear-gradient(180deg, #f8faff 0%, #f1f5fb 100%);
    }

    body.dark-theme #reactions-modal .modal-content.solubility-content.reactions-content {
        background: linear-gradient(180deg, #0d1117 0%, #161b22 100%);
    }

    /* Красивый header с размытием */
    #reactions-modal .modal-header {
        padding: 16px 20px;
        position: sticky;
        top: 0;
        background: rgba(248, 250, 255, 0.85);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        z-index: 10;
        border-bottom: 1px solid rgba(0, 0, 0, 0.06);
    }

    body.dark-theme #reactions-modal .modal-header {
        background: rgba(13, 17, 23, 0.85);
        border-bottom-color: rgba(255, 255, 255, 0.08);
    }

    #reactions-modal .modal-header h2 {
        font-size: 1.18rem;
        font-weight: 600;
        background: linear-gradient(135deg, #1a1a2e 0%, #4a5568 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    body.dark-theme #reactions-modal .modal-header h2 {
        background: linear-gradient(135deg, #e2e8f0 0%, #a0aec0 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .reactions-subtitle {
        font-size: 0.85rem;
        opacity: 0.75;
    }

    /* Кнопка закрытия */
    .close-reactions {
        width: 40px;
        height: 40px;
    }

    .close-reactions:active {
        transform: scale(0.92);
    }

    /* Тело модалки */
    .reactions-body {
        padding: 20px;
        gap: 16px;
    }

    /* Карточки ввода/вывода */
    .reactions-input-block,
    .reactions-output-block {
        padding: 16px;
        border-radius: 20px;
        gap: 10px;
        background: #ffffff;
        border: 1px solid rgba(0, 0, 0, 0.06);
        box-shadow:
            0 1px 3px rgba(0, 0, 0, 0.04),
            0 4px 12px rgba(0, 0, 0, 0.03);
        transition: box-shadow 0.2s ease;
    }

    .reactions-input-block.reactions-input-primary {
        border-color: rgba(59, 130, 246, 0.2);
        box-shadow:
            0 1px 3px rgba(59, 130, 246, 0.06),
            0 4px 16px rgba(59, 130, 246, 0.08);
    }

    body.dark-theme .reactions-input-block,
    body.dark-theme .reactions-output-block {
        background: rgba(30, 35, 45, 0.6);
        border-color: rgba(255, 255, 255, 0.08);
        box-shadow:
            0 1px 3px rgba(0, 0, 0, 0.2),
            0 4px 12px rgba(0, 0, 0, 0.15);
    }

    body.dark-theme .reactions-input-block.reactions-input-primary {
        border-color: rgba(96, 165, 250, 0.25);
        box-shadow:
            0 1px 3px rgba(96, 165, 250, 0.1),
            0 4px 16px rgba(96, 165, 250, 0.12);
    }

    .reactions-input-block label,
    .reactions-output-block label {
        font-size: 0.9rem;
        font-weight: 600;
        letter-spacing: 0.01em;
    }

    /* Текстовые поля */
    .reactions-input-block textarea,
    .reactions-output-block textarea {
        min-height: 80px;
        font-size: 1rem;
        padding: 14px 16px;
        border-radius: 14px;
        border: 1.5px solid rgba(0, 0, 0, 0.08);
        background: rgba(0, 0, 0, 0.02);
        transition: all 0.2s ease;
    }

    .reactions-input-block textarea:focus {
        border-color: rgba(59, 130, 246, 0.5);
        background: #ffffff;
        box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1);
    }

    body.dark-theme .reactions-input-block textarea,
    body.dark-theme .reactions-output-block textarea {
        background: rgba(0, 0, 0, 0.25);
        border-color: rgba(255, 255, 255, 0.1);
    }

    body.dark-theme .reactions-input-block textarea:focus {
        border-color: rgba(96, 165, 250, 0.5);
        background: rgba(0, 0, 0, 0.35);
        box-shadow: 0 0 0 4px rgba(96, 165, 250, 0.15);
    }

    .reactions-output-block textarea {
        min-height: 100px;
        background: rgba(59, 130, 246, 0.04);
        border-color: rgba(59, 130, 246, 0.12);
    }

    body.dark-theme .reactions-output-block textarea {
        background: rgba(96, 165, 250, 0.08);
        border-color: rgba(96, 165, 250, 0.15);
    }

    .reactions-hint {
        font-size: 0.82rem;
        opacity: 0.65;
    }

    /* Примеры */
    .reactions-examples {
        margin-top: 8px;
        padding: 16px;
        background: rgba(0, 0, 0, 0.02);
        border-radius: 16px;
    }

    body.dark-theme .reactions-examples {
        background: rgba(255, 255, 255, 0.03);
    }

    .reactions-examples>span {
        font-size: 0.88rem;
        font-weight: 500;
        opacity: 0.7;
    }

    .reactions-chips {
        gap: 10px;
        margin-top: 10px;
    }

    .reactions-chips button {
        padding: 12px 18px;
        font-size: 0.92rem;
        min-height: 46px;
        border-radius: 23px;
        font-weight: 500;
        background: #ffffff;
        border: 1.5px solid rgba(0, 0, 0, 0.1);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.04);
        transition: all 0.2s ease;
    }

    .reactions-chips button:active {
        transform: scale(0.96);
        background: rgba(59, 130, 246, 0.08);
        border-color: rgba(59, 130, 246, 0.3);
    }

    body.dark-theme .reactions-chips button {
        background: rgba(255, 255, 255, 0.06);
        border-color: rgba(255, 255, 255, 0.12);
    }

    body.dark-theme .reactions-chips button:active {
        background: rgba(96, 165, 250, 0.15);
        border-color: rgba(96, 165, 250, 0.35);
    }
}

/* Маленькие телефоны (480px) */
@media (max-width: 480px) {
    #reactions-modal .modal-header {
        padding: 14px 16px;
    }

    #reactions-modal .modal-header h2 {
        font-size: 1.1rem;
    }

    .reactions-title {
        gap: 2px;
    }

    .reactions-subtitle {
        font-size: 0.8rem;
    }

    .close-reactions {
        width: 38px;
        height: 38px;
    }

    .reactions-body {
        padding: 16px;
        gap: 14px;
    }

    .reactions-input-block,
    .reactions-output-block {
        padding: 14px;
        border-radius: 16px;
    }

    .reactions-input-block textarea,
    .reactions-output-block textarea {
        padding: 12px 14px;
        border-radius: 12px;
        min-height: 72px;
    }

    .reactions-output-block textarea {
        min-height: 90px;
    }

    .reactions-examples {
        padding: 14px;
        border-radius: 14px;
    }

    .reactions-chips {
        gap: 8px;
    }

    .reactions-chips button {
        padding: 11px 16px;
        font-size: 0.88rem;
        min-height: 44px;
        border-radius: 22px;
    }
}

/* Очень маленькие телефоны (375px) */
@media (max-width: 375px) {
    #reactions-modal .modal-header {
        padding: 12px 14px;
    }

    #reactions-modal .modal-header h2 {
        font-size: 1.02rem;
    }

    .reactions-subtitle {
        font-size: 0.78rem;
    }

    .close-reactions {
        width: 36px;
        height: 36px;
    }

    .reactions-body {
        padding: 14px;
        gap: 12px;
    }

    .reactions-input-block,
    .reactions-output-block {
        padding: 12px;
        border-radius: 14px;
    }

    .reactions-input-block textarea,
    .reactions-output-block textarea {
        min-height: 64px;
        font-size: 0.95rem;
        padding: 10px 12px;
        border-radius: 10px;
    }

    .reactions-output-block textarea {
        min-height: 80px;
    }

    .reactions-examples {
        padding: 12px;
        border-radius: 12px;
        margin-top: 4px;
    }

    .reactions-chips button {
        padding: 10px 14px;
        font-size: 0.85rem;
        min-height: 42px;
    }
}

/* Ландшафтная ориентация на телефонах */
@media (max-width: 900px) and (max-height: 500px) and (orientation: landscape) {
    #reactions-modal .modal-content.solubility-content.reactions-content {
        height: 100vh;
        height: 100dvh;
    }

    #reactions-modal .modal-header {
        padding: 10px 16px;
    }

    #reactions-modal .modal-header h2 {
        font-size: 1rem;
    }

    .reactions-subtitle {
        display: none;
    }

    .reactions-body {
        padding: 12px 16px 16px;
        gap: 10px;
        flex-direction: row;
        flex-wrap: wrap;
    }

    .reactions-input-block,
    .reactions-output-block {
        flex: 1;
        min-width: 280px;
    }

    .reactions-input-block textarea,
    .reactions-output-block textarea {
        min-height: 48px;
    }

    .reactions-output-block textarea {
        min-height: 56px;
    }

    .reactions-examples {
        width: 100%;
        margin-top: 4px;
        padding: 10px 14px;
    }
}

/* ��� ��� �������� ������� ������������� �� ����� ��� �������� */
#solubility-modal .solubility-backdrop {
    position: absolute;
    inset: 0;
    background: transparent;
    z-index: 0;
}

#solubility-modal .modal-content.solubility-content {
    position: relative;
    z-index: 1;
}

/* ������� �������������: ��������� "����" (���������� ���������) �� ����� */
#solubility-modal .pan-hint--left,
#solubility-modal .pan-hint--right {
    width: 18px;
}

#solubility-modal .pan-hint--top,
#solubility-modal .pan-hint--bottom {
    height: 16px;
}

#solubility-modal .pan-hint--left {
    background: linear-gradient(90deg, rgba(240, 240, 240, 0.5), rgba(240, 240, 240, 0));
}

#solubility-modal .pan-hint--right {
    background: linear-gradient(270deg, rgba(240, 240, 240, 0.5), rgba(240, 240, 240, 0));
}

#solubility-modal .pan-hint--top {
    background: linear-gradient(180deg, rgba(240, 240, 240, 0.5), rgba(240, 240, 240, 0));
}

#solubility-modal .pan-hint--bottom {
    background: linear-gradient(0deg, rgba(240, 240, 240, 0.5), rgba(240, 240, 240, 0));
}

body.dark-theme #solubility-modal .pan-hint--left {
    background: linear-gradient(90deg, rgba(15, 15, 15, 0.5), rgba(15, 15, 15, 0));
}

body.dark-theme #solubility-modal .pan-hint--right {
    background: linear-gradient(270deg, rgba(15, 15, 15, 0.5), rgba(15, 15, 15, 0));
}

body.dark-theme #solubility-modal .pan-hint--top {
    background: linear-gradient(180deg, rgba(15, 15, 15, 0.5), rgba(15, 15, 15, 0));
}

body.dark-theme #solubility-modal .pan-hint--bottom {
    background: linear-gradient(0deg, rgba(15, 15, 15, 0.5), rgba(15, 15, 15, 0));
}

/* ���������� ���������: ��������� � ������� ������� ������� (� �� � ��������) */
#solubility-modal .solubility-wrapper .pan-hints {
    position: sticky;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 6;
}

/* ������ ������� ������ �������� ������� */
#solubility-table {
    width: max-content;
}

.solubility-wrapper {
    overscroll-behavior: contain;
    scroll-padding: 0;
}

/* ���������� ���������: �� ��������� � ������, ����� �� ��������� ������ ������������ */
#solubility-modal .solubility-wrapper .pan-hints {
    position: absolute;
    inset: 0;
    height: 100%;
    width: 100%;
}

/* ������� �������������: ������ ������ ������ (���������� ���������) */
#solubility-modal .pan-hints {
    display: none !important;
}

#solubility-modal .advanced-mode-hint {
    position: absolute;
    top: 76px;
    left: 50%;
    z-index: 32;
    max-width: min(92vw, 480px);
    padding: 10px 16px;
    border-radius: 16px;
    border: 1px solid rgba(61, 101, 142, 0.25);
    background: rgba(245, 250, 255, 0.95);
    color: #1f3f63;
    font-size: 14px;
    font-weight: 600;
    line-height: 1.35;
    text-align: center;
    letter-spacing: 0.01em;
    box-shadow: 0 14px 30px rgba(25, 54, 84, 0.16);
    opacity: 0;
    transform: translate(-50%, -14px) scale(0.96);
    transition: opacity 0.28s ease, transform 0.28s ease;
    pointer-events: none;
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
}

#solubility-modal .advanced-mode-hint.is-visible {
    opacity: 1;
    transform: translate(-50%, 0) scale(1);
}

body.dark-theme #solubility-modal .advanced-mode-hint {
    border-color: rgba(160, 200, 240, 0.35);
    background: rgba(24, 39, 58, 0.94);
    color: #e4f0ff;
    box-shadow: 0 16px 30px rgba(0, 0, 0, 0.36);
}

@media (max-width: 1024px) {
    #solubility-modal .advanced-mode-hint {
        top: 68px;
        width: calc(100% - 28px);
        max-width: none;
        padding: 9px 14px;
        font-size: 13px;
    }
}

============================================================
ФАЙЛ: .\css\style.css
============================================================

﻿/* =========================================
   STYLE.CSS — Главный файл стилей
   Химический Ассистент v0.4
   ========================================= */

/*
   Структура файлов:
   ├── css/
   │   ├── base.css        — Базовые стили, body, canvas
   │   ├── table.css       — Таблица элементов, сетка, категории
   │   ├── modal.css       — Модальное окно, секции, аллотропы
   │   ├── theme.css       — Тёмная тема, переключатель, волна
   │   ├── fab.css         — FAB-меню
   │   └── calculator.css  — Калькулятор молекулярной массы
*/

@import url('base.css');
@import url('table.css');
@import url('modal.css');
@import url('electron-config.css');
@import url('theme.css');
@import url('fab.css');
@import url('calculator.css');
@import url('filters.css');
@import url('solubility.css?v=2');
@import url('balancer.css');
@import url('advanced-modal.css');
@import url('nodemap.css');
@import url('scroll-collapse.css');
@import url('illustrated-toggle.css');
@import url('pdf-export.css');
@import url('flip-modal.css');
@import url('live-wallpaper.css');
@import url('https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css');



============================================================
ФАЙЛ: .\css\table.css
============================================================

/* =========================================
   TABLE.CSS — Периодическая таблица
   ========================================= */

/* --- Контейнер таблицы --- */
.container {
    display: -ms-grid;
    /* IE fallback */
    display: grid;
    -ms-grid-columns: repeat(18, minmax(40px, 4vw));
    /* IE fallback */
    grid-template-columns: repeat(18, minmax(40px, 4vw));
    -ms-grid-rows: repeat(7, minmax(40px, 4vw));
    /* IE fallback */
    grid-template-rows: repeat(7, minmax(40px, 4vw));
    gap: 2px;
    position: relative;
    z-index: 2;
    /* Повышаем z-index, чтобы элементы были выше волны темы */
    /* Исправление для Chrome: явно задаем размеры */
    width: fit-content;
    max-width: 100%;
    box-sizing: border-box;
    margin-right: 20px;
    /* Отступ справа */
    padding-bottom: 2px;
    /* Добавляем отступ снизу для видимости нижней границы */
}

@media (max-width: 1024px) {
    .container {
        margin-right: 0 !important;
    }
}

/* --- Элемент таблицы --- */
.element {
    background-color: #ffffff;
    border: 1px solid #ccc;
    display: -webkit-flex;
    /* Safari/Chrome fallback */
    display: flex;
    -webkit-flex-direction: column;
    /* Safari/Chrome fallback */
    flex-direction: column;
    -webkit-align-items: center;
    /* Safari/Chrome fallback */
    align-items: center;
    -webkit-justify-content: center;
    /* Safari/Chrome fallback */
    justify-content: center;
    cursor: pointer;
    font-size: clamp(8px, 0.8vw, 12px);
    position: relative;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    transition: background-color 0.2s;
    /* Исправление для Chrome: явно задаем размеры */
    min-width: 0;
    min-height: 0;
    padding: 14px 1px 2px 1px;
    /* Top padding to clear atomic number */
    box-sizing: border-box;
    overflow: hidden;
    /* Ensure content doesn't spill out */
}

.element:hover {
    background-color: #e0e0e0;
    z-index: 10;
    /* Повышаем z-index при наведении, чтобы элемент был выше других */
    transform: scale(1.1);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
}

.atomic-number {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: clamp(9px, 0.75vw, 12px);
    font-weight: 400;
    /* Regular weight for less emphasis */
    opacity: 0.8;
}

.symbol {
    font-size: clamp(14px, 1.5vw, 20px);
    /* Reduced size */
    font-weight: 600;
    /* Semi-Bold instead of Bold */
    margin-top: 0;
    /* Remove top margin as padding handles it */
    line-height: 1.1;
}

.name {
    font-size: clamp(8px, 0.7vw, 11px);
    font-weight: 500;
    width: 98%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: center;
    margin-top: 1px;
}

/* --- Цвета категорий (светлая тема) --- */
.alkali-metal {
    background-color: #ff9999;
}

.alkaline-earth-metal {
    background-color: #ffcc99;
}

.transition-metal {
    background-color: #ffff99;
}

.post-transition-metal {
    background-color: #ccff99;
}

.metalloid {
    background-color: #99ffcc;
}

.nonmetal {
    background-color: #99ffff;
}

.halogen {
    background-color: #99ccff;
}

.noble-gas {
    background-color: #cc99ff;
}

.lanthanide {
    background-color: #ff99cc;
}

.actinide {
    background-color: #ff99ff;
}

.unknown {
    background-color: #cccccc;
}

/* --- Сетка позиций элементов --- */
#H {
    grid-row: 1;
    grid-column: 1;
}

#He {
    grid-row: 1;
    grid-column: 18;
}

#Li {
    grid-row: 2;
    grid-column: 1;
}

#Be {
    grid-row: 2;
    grid-column: 2;
}

#B {
    grid-row: 2;
    grid-column: 13;
}

#C {
    grid-row: 2;
    grid-column: 14;
}

#N {
    grid-row: 2;
    grid-column: 15;
}

#O {
    grid-row: 2;
    grid-column: 16;
}

#F {
    grid-row: 2;
    grid-column: 17;
}

#Ne {
    grid-row: 2;
    grid-column: 18;
}

#Na {
    grid-row: 3;
    grid-column: 1;
}

#Mg {
    grid-row: 3;
    grid-column: 2;
}

#Al {
    grid-row: 3;
    grid-column: 13;
}

#Si {
    grid-row: 3;
    grid-column: 14;
}

#P {
    grid-row: 3;
    grid-column: 15;
}

#S {
    grid-row: 3;
    grid-column: 16;
}

#Cl {
    grid-row: 3;
    grid-column: 17;
}

#Ar {
    grid-row: 3;
    grid-column: 18;
}

#K {
    grid-row: 4;
    grid-column: 1;
}

#Ca {
    grid-row: 4;
    grid-column: 2;
}

#Sc {
    grid-row: 4;
    grid-column: 3;
}

#Ti {
    grid-row: 4;
    grid-column: 4;
}

#V {
    grid-row: 4;
    grid-column: 5;
}

#Cr {
    grid-row: 4;
    grid-column: 6;
}

#Mn {
    grid-row: 4;
    grid-column: 7;
}

#Fe {
    grid-row: 4;
    grid-column: 8;
}

#Co {
    grid-row: 4;
    grid-column: 9;
}

#Ni {
    grid-row: 4;
    grid-column: 10;
}

#Cu {
    grid-row: 4;
    grid-column: 11;
}

#Zn {
    grid-row: 4;
    grid-column: 12;
}

#Ga {
    grid-row: 4;
    grid-column: 13;
}

#Ge {
    grid-row: 4;
    grid-column: 14;
}

#As {
    grid-row: 4;
    grid-column: 15;
}

#Se {
    grid-row: 4;
    grid-column: 16;
}

#Br {
    grid-row: 4;
    grid-column: 17;
}

#Kr {
    grid-row: 4;
    grid-column: 18;
}

#Rb {
    grid-row: 5;
    grid-column: 1;
}

#Sr {
    grid-row: 5;
    grid-column: 2;
}

#Y {
    grid-row: 5;
    grid-column: 3;
}

#Zr {
    grid-row: 5;
    grid-column: 4;
}

#Nb {
    grid-row: 5;
    grid-column: 5;
}

#Mo {
    grid-row: 5;
    grid-column: 6;
}

#Tc {
    grid-row: 5;
    grid-column: 7;
}

#Ru {
    grid-row: 5;
    grid-column: 8;
}

#Rh {
    grid-row: 5;
    grid-column: 9;
}

#Pd {
    grid-row: 5;
    grid-column: 10;
}

#Ag {
    grid-row: 5;
    grid-column: 11;
}

#Cd {
    grid-row: 5;
    grid-column: 12;
}

#In {
    grid-row: 5;
    grid-column: 13;
}

#Sn {
    grid-row: 5;
    grid-column: 14;
}

#Sb {
    grid-row: 5;
    grid-column: 15;
}

#Te {
    grid-row: 5;
    grid-column: 16;
}

#I {
    grid-row: 5;
    grid-column: 17;
}

#Xe {
    grid-row: 5;
    grid-column: 18;
}

#Cs {
    grid-row: 6;
    grid-column: 1;
}

#Ba {
    grid-row: 6;
    grid-column: 2;
}

#La {
    grid-row: 6;
    grid-column: 3;
}

#Hf {
    grid-row: 6;
    grid-column: 4;
}

#Ta {
    grid-row: 6;
    grid-column: 5;
}

#W {
    grid-row: 6;
    grid-column: 6;
}

#Re {
    grid-row: 6;
    grid-column: 7;
}

#Os {
    grid-row: 6;
    grid-column: 8;
}

#Ir {
    grid-row: 6;
    grid-column: 9;
}

#Pt {
    grid-row: 6;
    grid-column: 10;
}

#Au {
    grid-row: 6;
    grid-column: 11;
}

#Hg {
    grid-row: 6;
    grid-column: 12;
}

#Tl {
    grid-row: 6;
    grid-column: 13;
}

#Pb {
    grid-row: 6;
    grid-column: 14;
}

#Bi {
    grid-row: 6;
    grid-column: 15;
}

#Po {
    grid-row: 6;
    grid-column: 16;
}

#At {
    grid-row: 6;
    grid-column: 17;
}

#Rn {
    grid-row: 6;
    grid-column: 18;
}

#Fr {
    grid-row: 7;
    grid-column: 1;
}

#Ra {
    grid-row: 7;
    grid-column: 2;
}

#Ac {
    grid-row: 7;
    grid-column: 3;
}

#Rf {
    grid-row: 7;
    grid-column: 4;
}

#Db {
    grid-row: 7;
    grid-column: 5;
}

#Sg {
    grid-row: 7;
    grid-column: 6;
}

#Bh {
    grid-row: 7;
    grid-column: 7;
}

#Hs {
    grid-row: 7;
    grid-column: 8;
}

#Mt {
    grid-row: 7;
    grid-column: 9;
}

#Ds {
    grid-row: 7;
    grid-column: 10;
}

#Rg {
    grid-row: 7;
    grid-column: 11;
}

#Cn {
    grid-row: 7;
    grid-column: 12;
}

#Nh {
    grid-row: 7;
    grid-column: 13;
}

#Fl {
    grid-row: 7;
    grid-column: 14;
}

#Mc {
    grid-row: 7;
    grid-column: 15;
}

#Lv {
    grid-row: 7;
    grid-column: 16;
}

#Ts {
    grid-row: 7;
    grid-column: 17;
}

#Og {
    grid-row: 7;
    grid-column: 18;
}

/* --- Лантаноиды и актиноиды --- */
.lanthanides,
.actinides {
    display: grid;
    grid-template-columns: repeat(15, minmax(40px, 4vw));
    gap: 2px;
    margin-top: 1.5vw;
    margin-left: auto;
    margin-right: auto;
    width: fit-content;
    z-index: 2;
    /* Повышаем z-index, чтобы элементы были выше волны темы */
}

/* --- Анимация разлёта элементов --- */
.element,
.lanthanides .element,
.actinides .element {
    transition: transform 0.5s cubic-bezier(0.5, 0.9, 0.5, 1.0);
}

.elements-scattered .element {
    transition: transform 0.5s cubic-bezier(0.5, 0.9, 0.5, 1.0);
}

.elements-returning .element {
    transition: transform 0.3s cubic-bezier(0.4, 0.05, 0.8, 1.0);
}

/* Добавь это к цветам категорий */
.element.unknown {
    background-color: #e0e0e0;
    /* Светло-серый для неизвестных */
    color: #333;
}

/* При наведении */
.element.unknown:hover {
    background-color: #d0d0d0;
    transform: scale(1.1);
    z-index: 10;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
}

/* Фикс горизонтального скролла на мобильных устройствах */
@media (max-width: 1024px) {
    .periodic-table-container {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch;
        height: auto !important;
    }

    .table-wrapper {
        width: fit-content !important;
        min-width: 100%;
    }

    .container {
        width: fit-content !important;
        min-width: 1200px;
        /* Минимальная ширина для горизонтального скролла */
    }

    body.scroll-locked {
        overflow-x: auto !important;
        position: relative !important;
        /* Важно для скролла */
    }
}

/* Фикс горизонтального скролла на мобильных */
@media (max-width: 1024px) {
    .periodic-table-container {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch;
    }

    #mobile-table-wrapper {
        margin-left: 0 !important;
        padding: 0 16px !important;
        align-items: center !important;
    }

    body:not(.calc-active):not(.balancer-active) #mobile-table-wrapper {
        transform: none !important;
    }

    .container {
        width: max-content !important;
        min-width: 1600px !important;
    }

    body.scroll-locked {
        overflow-x: auto !important;
    }

    /* Отключаем центрирование */
    .periodic-table-container {
        justify-content: flex-start !important;
        align-items: flex-start !important;
    }
}

/* Фикс горизонтального скролла на мобильных */
@media (max-width: 1024px) {
    .periodic-table-container {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch;
    }

    #mobile-table-wrapper {
        margin-left: 0 !important;
        padding: 0 16px !important;
        align-items: center !important;
    }

    body:not(.calc-active):not(.balancer-active) #mobile-table-wrapper {
        transform: none !important;
    }

    .container {
        width: max-content !important;
        min-width: 1600px !important;
    }

    body.scroll-locked {
        overflow-x: auto !important;
    }

    /* Отключаем центрирование */
    .periodic-table-container {
        justify-content: flex-start !important;
        align-items: flex-start !important;
    }
}

/* Скрытие скроллбаров для таблицы Менделеева */
.periodic-table-container {
    -ms-overflow-style: none;
    /* IE and Edge */
    scrollbar-width: none;
    /* Firefox */
    position: relative;
}

.periodic-table-container::-webkit-scrollbar {
    display: none;
}

@media (max-width: 1024px) {
    .periodic-table-container {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }

    .periodic-table-container::-webkit-scrollbar {
        display: none;
    }
}

/* --- Увеличенные шрифты для больших экранов --- */
@media (min-width: 1600px) {
    .atomic-number {
        font-size: 0.6vw;
    }

    .symbol {
        font-size: 1.5vw;
    }

    .name {
        font-size: 0.7vw;
    }
}

@media (min-width: 1920px) {
    .atomic-number {
        font-size: 0.6vw;
    }

    .symbol {
        font-size: 1.4vw;
    }

    .name {
        font-size: 0.7vw;
    }
}

@media (min-width: 2560px) {
    .atomic-number {
        font-size: 0.5vw;
    }

    .symbol {
        font-size: 1.2vw;
    }

    .name {
        font-size: 0.6vw;
    }
}

============================================================
ФАЙЛ: .\css\theme.css
============================================================

/* =========================================
   THEME.CSS — Тёмная тема и переключатель
   ========================================= */

/* =========================================
   ПЕРЕКЛЮЧАТЕЛЬ ТЕМЫ
   ========================================= */
#theme-toggle:not(.chem-toggle) {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: none;
    background: #333;
    color: white;
    cursor: pointer;
    z-index: 5000;
    transition: transform 0.2s, background 0.3s;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
}

#theme-toggle:not(.chem-toggle) svg {
    width: 28px;
    height: 28px;
    display: block;
    margin: 0;
    padding: 0;
    pointer-events: none;
    stroke: currentColor;
    fill: none;
}

#theme-toggle:not(.chem-toggle):hover {
    transform: scale(1.1);
}

#theme-toggle:not(.chem-toggle):active {
    transform: scale(0.9);
}

#theme-toggle:not(.chem-toggle).spin {
    animation: spinIcon 0.4s ease-out;
}

#theme-toggle:not(.chem-toggle) .icon-moon {
    display: block !important;
    width: 100%;
    height: 100%;
}

#theme-toggle:not(.chem-toggle) .icon-sun {
    display: none !important;
    width: 100%;
    height: 100%;
}

body.dark-theme #theme-toggle:not(.chem-toggle) .icon-moon {
    display: none !important;
}

body.dark-theme #theme-toggle:not(.chem-toggle) .icon-sun {
    display: block !important;
    width: 100%;
    height: 100%;
}

/* =========================================
   ВОЛНА СМЕНЫ ТЕМЫ
   ========================================= */
.theme-wave-circle {
    position: fixed;
    width: 0;
    height: 0;
    border-radius: 50%;
    pointer-events: none;
    z-index: 0;
    /* Волна над фоном и частицами, но под плитками/ UI */
    transform: translate(-50%, -50%);
}

.theme-wave-circle.expand {
    animation: waveExpand 0.8s linear forwards;
}

.theme-wave-circle.background {
    width: 400vmax;
    height: 400vmax;
    animation: none;
}

@keyframes waveExpand {
    0% {
        transform: translate(-50%, -50%) scale(0);
    }

    100% {
        transform: translate(-50%, -50%) scale(1);
    }
}

/* =========================================
   ТЁМНАЯ ТЕМА — БАЗОВЫЕ СТИЛИ
   ========================================= */
body.dark-theme {
    background-color: #1a1a2e;
}

body.dark-theme #theme-toggle:not(.chem-toggle) {
    background: #f0f0f0;
    color: #1a1a2e;
}

/* --- Элементы таблицы --- */
body.dark-theme .element {
    background-color: #2d2d44;
    border-color: #444;
    color: #eee;
}

body.dark-theme .element:hover {
    background-color: #3d3d5c;
}

body.dark-theme .element .name {
    color: #ccc;
}

/* --- Цвета категорий (тёмная тема) --- */
body.dark-theme .alkali-metal {
    background-color: #8E3B3B;
}

body.dark-theme .alkaline-earth-metal {
    background-color: #8B6914;
}

body.dark-theme .transition-metal {
    background-color: #7A7A2E;
}

body.dark-theme .post-transition-metal {
    background-color: #4A7A2E;
}

body.dark-theme .metalloid {
    background-color: #2E7A5C;
}

body.dark-theme .nonmetal {
    background-color: #2E6A7A;
}

body.dark-theme .halogen {
    background-color: #2E4A7A;
}

body.dark-theme .noble-gas {
    background-color: #5C2E7A;
}

body.dark-theme .lanthanide {
    background-color: #7A2E5C;
}

body.dark-theme .actinide {
    background-color: #7A2E7A;
}

body.dark-theme .unknown {
    background-color: #4A4A4A;
}

/* =========================================
   ТЁМНАЯ ТЕМА — МОДАЛЬНОЕ ОКНО
   ========================================= */
body.dark-theme .modal {
    background-color: rgba(0, 0, 0, 0.7);
}

body.dark-theme .modal-content {
    background-color: #0a0a0f;
    color: #eee;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
}

body.dark-theme .close {
    color: #888;
}

body.dark-theme .close:hover {
    color: #fff;
}

body.dark-theme #element-title {
    color: #eee;
}

/* --- Секции (тёмная тема) --- */
body.dark-theme .info-group.basic {
    background: #0d2137;
    border-left-color: #2196F3;
}

body.dark-theme .info-group.physical {
    background: #0d2917;
    border-left-color: #4CAF50;
}

body.dark-theme .info-group.history {
    background: #2e2410;
    border-left-color: #FF9800;
}

body.dark-theme .info-group.facts {
    background: #1f0d29;
    border-left-color: #9C27B0;
}

body.dark-theme .group-title {
    color: #aaa;
}

body.dark-theme .group-content p {
    color: #ccc;
}

body.dark-theme .group-content strong {
    color: #fff;
}

/* =========================================
   АНИМАЦИЯ ПЕРЕХОДА ТЕМЫ
   ========================================= */

/* Переход в тёмную тему */
.element.to-dark {
    background-color: #2d2d44 !important;
    border-color: #444 !important;
    color: #eee !important;
    transition: all 0.15s ease-out;
}

.element.to-dark .name {
    color: #ccc !important;
}

.element.alkali-metal.to-dark {
    background-color: #8b3a3a !important;
}

.element.alkaline-earth-metal.to-dark {
    background-color: #8b6914 !important;
}

.element.transition-metal.to-dark {
    background-color: #7a7a2e !important;
}

.element.post-transition-metal.to-dark {
    background-color: #4a7a2e !important;
}

.element.metalloid.to-dark {
    background-color: #2e7a5c !important;
}

.element.nonmetal.to-dark {
    background-color: #2e6a7a !important;
}

.element.halogen.to-dark {
    background-color: #2e4a7a !important;
}

.element.noble-gas.to-dark {
    background-color: #5c2e7a !important;
}

.element.lanthanide.to-dark {
    background-color: #7a2e5c !important;
}

.element.actinide.to-dark {
    background-color: #7a2e7a !important;
}

.element.unknown.to-dark {
    background-color: #4a4a4a !important;
}

/* Переход в светлую тему */
body.dark-theme .element.to-light {
    border-color: #ccc !important;
    color: #000 !important;
    transition: all 0.15s ease-out;
}

body.dark-theme .element.to-light .name {
    color: #333 !important;
}

body.dark-theme .element.alkali-metal.to-light {
    background-color: #ff9999 !important;
}

body.dark-theme .element.alkaline-earth-metal.to-light {
    background-color: #ffcc99 !important;
}

body.dark-theme .element.transition-metal.to-light {
    background-color: #ffff99 !important;
}

body.dark-theme .element.post-transition-metal.to-light {
    background-color: #ccff99 !important;
}

body.dark-theme .element.metalloid.to-light {
    background-color: #99ffcc !important;
}

body.dark-theme .element.nonmetal.to-light {
    background-color: #99ffff !important;
}

body.dark-theme .element.halogen.to-light {
    background-color: #99ccff !important;
}

body.dark-theme .element.noble-gas.to-light {
    background-color: #cc99ff !important;
}

body.dark-theme .element.lanthanide.to-light {
    background-color: #ff99cc !important;
}

body.dark-theme .element.actinide.to-light {
    background-color: #ff99ff !important;
}

body.dark-theme .element.unknown.to-light {
    background-color: #cccccc !important;
}

/* =========================================
   АДАПТИВ
   ========================================= */
@media (max-width: 1024px) {
    #theme-toggle:not(.chem-toggle) {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 40px !important;
        height: 40px !important;
        font-size: 20px;
        z-index: 5000;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    /* Увеличиваем SVG иконку для лучшей видимости на iPhone */
    #theme-toggle:not(.chem-toggle) svg {
        width: 28px !important;
        /* Увеличиваем размер иконки */
        height: 28px !important;
        stroke: currentColor !important;
        fill: currentColor !important;
        /* Добавляем fill для надежности */
        color: inherit !important;
        display: block !important;
        margin: auto !important;
        /* Центрируем иконку */
    }

    /* Явно показываем иконку луны на светлой теме */
    #theme-toggle:not(.chem-toggle) .icon-moon {
        display: block !important;
        opacity: 1 !important;
        visibility: visible !important;
    }

    /* Явно скрываем иконку солнца на светлой теме */
    #theme-toggle:not(.chem-toggle) .icon-sun {
        display: none !important;
    }

    /* Дополнительные стили для обеспечения видимости иконки */
    #theme-toggle:not(.chem-toggle) .icon-moon,
    #theme-toggle:not(.chem-toggle) .icon-sun {
        width: 100% !important;
        height: 100% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        min-width: 24px !important;
        min-height: 24px !important;
    }

    /* Дополнительные стили для iPhone - увеличиваем размер иконки темы */
    body.device-iphone #theme-toggle:not(.chem-toggle) svg {
        width: 32px !important;
        /* Увеличиваем размер иконки на iPhone */
        height: 32px !important;
        min-width: 32px !important;
        min-height: 32px !important;
    }

    body.dark-theme .modal {
        background: rgba(0, 0, 0, 0.3);
    }

    body.dark-theme .modal-content {
        background: rgba(26, 26, 46, 0.75);
        border-bottom-color: #64B5F6;
    }

    body.dark-theme .close {
        background: rgba(255, 255, 255, 0.1);
        color: #ccc;
    }

    body.dark-theme #element-title {
        border-bottom-color: rgba(255, 255, 255, 0.1);
    }

    body.dark-theme .info-group {
        background: #151525;
    }
}

/* Горизонтальная ориентация */
@media (max-width: 768px) and (orientation: landscape) {
    #theme-toggle:not(.chem-toggle) {
        top: 5px;
        left: 5px;
        width: 36px;
        height: 36px;
        font-size: 18px;
    }
}

/* Скрываем кнопку темы на мобильных при открытой таблице растворимости */
@media (max-width: 1024px) {
    body.solubility-open #theme-toggle {
        opacity: 0;
        pointer-events: none;
    }
}

/* Светлая тема — только луна */
#theme-toggle:not(.chem-toggle) .icon-sun {
    display: none !important;
}

/* Тёмная тема — только солнце */
body.dark-theme #theme-toggle:not(.chem-toggle) .icon-moon {
    display: none !important;
}

/* =========================================
   ТЁМНАЯ ТЕМА — КАСТОМНЫЙ СКРОЛЛБАР
   ========================================= */
/* Удалены дублирующие стили скроллбара, так как теперь используются универсальные стили */

============================================================
ФАЙЛ: .\electron-app\INSTALL_OBOI.md
============================================================

# Установка Oboi для Chemical Assistant

Для работы функции "Живые Обои" требуется установить приложение Oboi.
> Режим обоев работает только на Windows.

## Как установить:

1. Скачайте последнюю версию Oboi с официального репозитория:
   https://github.com/KaitlynEthylia/Oboi/releases

2. Распакуйте архив и найдите файл `oboi.exe`

3. Скопируйте `oboi.exe` в папку:
   `C:\Users\79319\Documents\GitHub\mendeleevtable\electron-app\resources\`

4. Перезапустите приложение Chemical Assistant

## Альтернативный способ (через Chocolatey):

Если у вас установлен Chocolatey, вы можете установить Oboi командой:
```
choco install oboi
```

После этого приложение сможет использовать Oboi для установки живых обоев.


============================================================
ФАЙЛ: .\electron-app\package.json
============================================================

{
  "name": "chemical-assistant-wallpaper",
  "version": "1.0.0",
  "description": "Интерактивная таблица Менделеева с возможностью установки как обои Windows",
  "main": "electron/main.js",
  "scripts": {
    "start": "electron .",
    "electron": "electron .",
    "dev": "set NODE_ENV=development && electron .",
    "build": "electron-builder",
    "build:win": "electron-builder --win",
    "build:portable": "electron-builder --win portable",
    "build:linux": "electron-builder --linux",
    "build:all": "electron-builder --win --linux"
  },
  "keywords": [
    "chemistry",
    "periodic-table",
    "mendeleev",
    "wallpaper",
    "education",
    "electron"
  ],
  "author": {
    "name": "Chemical Assistant Team",
    "email": "support@chemicalassistant.app"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/layfhaker/mendeleevtable.git"
  },
  "devDependencies": {
    "electron": "^28.0.0",
    "electron-builder": "^24.9.1"
  },
  "dependencies": {
    "auto-launch": "^5.0.6"
  },
  "optionalDependencies": {
    "electron-as-wallpaper": "^2.0.3"
  },
  "build": {
    "artifactName": "ChemicalAssistant.${ext}",
    "appId": "com.chemistryassistant.wallpaper",
    "productName": "Chemical Assistant",
    "files": [
      "electron/**/*",
      "resources/**/*",
      "node_modules/auto-launch/**/*",
      {
        "from": "..",
        "to": "app",
        "filter": [
          "index.html",
          "css/**",
          "js/**",
          "img/**",
          "manifest.json",
          "sw.js"
        ]
      }
    ],
    "directories": {
      "output": "dist",
      "buildResources": "build"
    },
    "win": {
      "target": [
        {
          "target": "nsis",
          "arch": [
            "x64"
          ]
        }
      ],
      "icon": "img/icon-512.png",
      "requestedExecutionLevel": "asInvoker"
    },
    "linux": {
      "target": [
        "AppImage",
        "deb"
      ],
      "icon": "img/icon-512.png",
      "category": "Education"
    },
    "nsis": {
      "oneClick": false,
      "allowToChangeInstallationDirectory": true,
      "createDesktopShortcut": true,
      "createStartMenuShortcut": true,
      "shortcutName": "Chemical Assistant",
      "artifactName": "ChemicalAssistant-Setup.exe",
      "perMachine": false,
      "allowElevation": true
    }
  }
}


============================================================
ФАЙЛ: .\electron-app\README.md
============================================================

# 🖥️ Electron Desktop App — Chemical Assistant

Десктопная версия интерактивной таблицы Менделеева с функцией установки обоев Windows.

## 🚀 Быстрый старт

### Установка зависимостей
```bash
cd electron-app
npm install
```

### Запуск приложения
```bash
# Обычный запуск
npm start

# Запуск с DevTools (для разработки)
npm run dev
```

### Сборка приложения
```bash
# Сборка обоих вариантов (portable + installer)
npm run build

# Только Windows версия
npm run build:win

# Только portable версия
npm run build:portable

# Только Linux пакеты
npm run build:linux
```

## 📦 Файлы после сборки

Готовые файлы появятся в папке `electron-app/dist/`:

- **ChemicalAssistant.exe** — портативная версия (Windows)
- **ChemicalAssistant-Setup.exe** — инсталлятор для Windows
- **ChemicalAssistant.AppImage** — Linux AppImage
- **ChemicalAssistant.deb** — Linux DEB пакет
- **ChemicalAssistant.snap** — Linux Snap пакет

## ✨ Уникальные возможности Electron версии

### 🖼️ Установка обоев Windows
1. Запустите приложение
2. Настройте таблицу как хотите (тема, открытые элементы)
3. Откройте FAB-меню (круглая кнопка справа снизу)
4. Нажмите "Установить обои"
5. Текущий вид становится обоями рабочего стола
> Режим обоев работает только на Windows.

### 🔄 Scroll-Collapse система
- Таблица плавно сжимается при виртуальном скролле
- До порога 300px страница не прокручивается
- Естественное поведение при прокрутке вниз

## 📂 Структура

```
electron-app/
├── electron/              # Код Electron приложения
│   ├── main.js           # Главный процесс
│   ├── preload.js        # Безопасный API для renderer
│   └── wallpaper-api.js  # Windows API для обоев
├── package.json          # NPM конфигурация
├── node_modules/         # Зависимости (создается при npm install)
└── dist/                 # Готовые .exe файлы (создается при npm run build)
```

Исходники приложения (HTML, CSS, JS, изображения) находятся в **корне репозитория** (`../`).

## 🛠️ Системные требования

- **ОС:** Windows 10/11 (64-bit) или Linux (x64)
- **Память:** 100 МБ свободного места
- **Экран:** 1280×720 и выше
- **Node.js:** 16.0+ (для разработки)

## 🔧 Разработка

### Изменение исходников
Все файлы интерфейса находятся в корне проекта:
- `../index.html` — разметка
- `../css/` — стили
- `../js/` — логика
- `../img/` — изображения

После изменений просто перезапустите приложение.

### Изменение Electron кода
Файлы в папке `electron/`:
- `main.js` — главный процесс, создание окна
- `preload.js` — связь между renderer и main процессом
- `wallpaper-api.js` — логика установки обоев через PowerShell

## 📄 Лицензия

MIT License — можно использовать в любых целях с указанием авторства.

---

**Веб-версия:** https://layfhaker.github.io/mendeleevtable/
**GitHub:** https://github.com/layfhaker/mendeleevtable


============================================================
ФАЙЛ: .\electron-app\electron\main.js
============================================================

/* =========================================
   ELECTRON MAIN.JS — Главный процесс Electron
   с поддержкой Live Wallpaper и System Tray
   ========================================= */

const { app, BrowserWindow, ipcMain, Tray, Menu, nativeImage, Notification } = require('electron');

// Disable hardware acceleration to prevent rendering issues in wallpaper mode
app.disableHardwareAcceleration();

const path = require('path');
const fs = require('fs');
const AutoLaunch = require('auto-launch');
let setAsWallpaper = null;

if (process.platform === 'win32') {
    ({ setAsWallpaper } = require('./wallpaper-api'));
}

let attach = async () => {
    throw new Error('Live wallpaper is not available for this platform.');
};
let detach = async () => {};
let reset = () => {};

if (process.platform === 'win32') {
    try {
        ({ attach, detach, reset } = require('electron-as-wallpaper'));
    } catch (error) {
        console.warn('[Wallpaper] electron-as-wallpaper is unavailable:', error.message);
    }
} else if (process.platform === 'linux') {
    try {
        ({ attach, detach, reset } = require('./wallpaper-linux'));
    } catch (error) {
        console.warn('[Wallpaper] Linux wallpaper helper is unavailable:', error.message);
    }
}

let mainWindow;
let tray;
let appRootPath;

function getAppRootCandidates() {
    if (app.isPackaged) {
        const appPath = app.getAppPath();
        const resourcesPath = process.resourcesPath;
        return [
            path.join(appPath, 'app'),
            appPath,
            path.join(resourcesPath, 'app'),
            resourcesPath
        ];
    }

    const devRoot = path.join(__dirname, '../..');
    return [devRoot, path.resolve(devRoot)];
}

function resolveAppRoot() {
    const candidates = getAppRootCandidates();
    for (const candidate of candidates) {
        try {
            const indexPath = path.join(candidate, 'index.html');
            if (fs.existsSync(indexPath)) {
                return { root: candidate, indexPath };
            }
        } catch (error) {
            // Ignore invalid paths and keep searching.
        }
    }

    const fallbackRoot = candidates[0];
    return {
        root: fallbackRoot,
        indexPath: path.join(fallbackRoot, 'index.html'),
        missing: true
    };
}

// Auto-launch configuration
const autoLauncher = new AutoLaunch({
    name: 'Chemical Assistant',
    path: app.getPath('exe')
});

/**
 * Create main window
 */
function createWindow() {
    const resolved = resolveAppRoot();
    appRootPath = resolved.root;

    mainWindow = new BrowserWindow({
        width: 1920,
        height: 1080,
        frame: false,
        titleBarStyle: 'hidden',
        webPreferences: {
            preload: path.join(__dirname, 'preload.js'),
            contextIsolation: true,
            nodeIntegration: false,
            enableRemoteModule: false
        },
        backgroundColor: '#f0f0f0',
        title: 'Chemical Assistant',
        icon: path.join(appRootPath, 'img', 'icon-192.png'),
        autoHideMenuBar: true
    });

    if (!resolved.missing) {
        mainWindow.loadFile(resolved.indexPath);
    } else {
        console.error('[Main] index.html not found in any app root candidate:', getAppRootCandidates());
        const errorHtml = `
            <html lang="ru">
                <head>
                    <meta charset="UTF-8" />
                    <title>Chemical Assistant</title>
                    <style>
                        body { font-family: sans-serif; padding: 40px; background: #0f172a; color: #e2e8f0; }
                        code { background: #1e293b; padding: 2px 6px; border-radius: 4px; }
                        h1 { margin-top: 0; }
                    </style>
                </head>
                <body>
                    <h1>Не удалось загрузить приложение</h1>
                    <p>Файл <code>index.html</code> не найден в пакете.</p>
                    <p>Проверьте, что сборка включает корневые файлы сайта (index.html, css, js, img).</p>
                </body>
            </html>
        `;
        mainWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(errorHtml)}`);
    }

    mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription, validatedURL, isMainFrame) => {
        if (!isMainFrame) return;
        console.error('[Main] Failed to load:', { errorCode, errorDescription, validatedURL });
        const errorHtml = `
            <html lang="ru">
                <head>
                    <meta charset="UTF-8" />
                    <title>Chemical Assistant</title>
                    <style>
                        body { font-family: sans-serif; padding: 40px; background: #0f172a; color: #e2e8f0; }
                        code { background: #1e293b; padding: 2px 6px; border-radius: 4px; }
                        h1 { margin-top: 0; }
                    </style>
                </head>
                <body>
                    <h1>Ошибка загрузки</h1>
                    <p>Не удалось открыть <code>${validatedURL}</code>.</p>
                    <p>${errorDescription} (код ${errorCode}).</p>
                </body>
            </html>
        `;
        mainWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(errorHtml)}`);
    });

    if (process.env.NODE_ENV === 'development') {
        mainWindow.webContents.openDevTools();
    }

    // ========================================
    // IMPORTANT: Don't quit on close if wallpaper is active
    // ========================================
    mainWindow.on('close', (event) => {
        if (global.isWallpaperActive) {
            // Prevent closing, hide instead
            event.preventDefault();
            mainWindow.hide();

            // Show notification
            showNotification(
                'Chemical Assistant',
                'Running in system tray. Live wallpaper is still active.'
            );
        }
    });

    mainWindow.on('closed', () => {
        mainWindow = null;
    });
}

/**
 * Create system tray icon
 */
function createTray() {
    // Load icon
    const iconPath = path.join(appRootPath, 'img', 'icon-192.png');
    let trayIcon;

    try {
        trayIcon = nativeImage.createFromPath(iconPath).resize({ width: 16, height: 16 });
    } catch (error) {
        console.error('[Tray] Error loading icon:', error);
        // Create a simple fallback icon
        trayIcon = nativeImage.createEmpty();
    }

    tray = new Tray(trayIcon);
    tray.setToolTip('Chemical Assistant');

    updateTrayMenu();

    // Double-click to show window
    tray.on('double-click', () => {
        if (mainWindow) {
            mainWindow.show();
            mainWindow.focus();
        } else {
            createWindow();
        }
    });
}

/**
 * Update tray context menu
 */
function updateTrayMenu() {
    const isWallpaperActive = global.isWallpaperActive || false;

    const contextMenu = Menu.buildFromTemplate([
        {
            label: 'Open Chemical Assistant',
            click: () => {
                if (mainWindow) {
                    mainWindow.show();
                    mainWindow.focus();
                } else {
                    createWindow();
                }
            }
        },
        { type: 'separator' },
        {
            label: 'Live Wallpaper',
            type: 'checkbox',
            checked: isWallpaperActive,
            click: async (menuItem) => {
                if (menuItem.checked) {
                    try {
                        await attach(mainWindow, {
                            transparent: true,
                            forwardKeyboardInput: true,
                            forwardMouseInput: true,
                        });
                        global.isWallpaperActive = true;
                        showNotification('Success', 'Live wallpaper enabled!');
                    } catch (error) {
                        showNotification('Error', `Failed to enable live wallpaper: ${error.message}`);
                        menuItem.checked = false; // Reset checkbox state
                    }
                } else {
                    try {
                        await detach(mainWindow);
                        global.isWallpaperActive = false;
                        showNotification('Success', 'Live wallpaper disabled.');
                    } catch (error) {
                        showNotification('Error', `Failed to disable live wallpaper: ${error.message}`);
                    }
                }
                updateTrayMenu();
            }
        },
        { type: 'separator' },
        {
            label: 'Exit',
            click: async () => {
                // Cleanup and quit
                if (global.isWallpaperActive) {
                    try {
                        await detach(mainWindow);
                        reset(); // Restore original wallpaper
                    } catch (error) {
                        console.error('Error detaching wallpaper:', error);
                    }
                    global.isWallpaperActive = false;
                }
                app.quit();
            }
        }
    ]);

    tray.setContextMenu(contextMenu);
}

/**
 * Show system notification
 */
function showNotification(title, body) {
    if (Notification.isSupported()) {
        const iconPath = path.join(appRootPath, 'img', 'icon-192.png');
        new Notification({
            title: title,
            body: body,
            icon: iconPath
        }).show();
    }
}

// ========================================
// App Lifecycle
// ========================================

app.whenReady().then(() => {
    createWindow();
    createTray();

    app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) {
            createWindow();
        }
    });
});

// Don't quit when all windows closed (tray mode)
app.on('window-all-closed', (event) => {
    // Keep app running if wallpaper is active
    if (global.isWallpaperActive) {
        // Don't quit
        return;
    } else if (process.platform !== 'darwin') {
        app.quit();
    }
});

// Cleanup before quit
app.on('before-quit', async () => {
    if (global.isWallpaperActive) {
        try {
            await detach(mainWindow);
            reset(); // Restore original wallpaper
        } catch (error) {
            console.error('Error detaching wallpaper on quit:', error);
        }
        global.isWallpaperActive = false;
    }
});

// ========================================
// IPC Handlers
// ========================================

// Static wallpaper (screenshot)
ipcMain.handle('set-wallpaper', async (event) => {
    try {
        if (process.platform !== 'win32' || !setAsWallpaper) {
            return {
                success: false,
                message: 'Установка обоев поддерживается только на Windows'
            };
        }

        const screenshot = await mainWindow.webContents.capturePage();
        const pngBuffer = screenshot.toPNG();
        const tempDir = app.getPath('temp');
        const wallpaperPath = path.join(tempDir, 'chemical-assistant-wallpaper.png');
        fs.writeFileSync(wallpaperPath, pngBuffer);
        await setAsWallpaper(wallpaperPath);
        return {
            success: true,
            message: 'Wallpaper set successfully!',
            path: wallpaperPath
        };
    } catch (error) {
        return {
            success: false,
            message: 'Error: ' + error.message
        };
    }
});

// Live wallpaper - enable
ipcMain.handle('enable-live-wallpaper', async (event) => {
    try {
        await attach(mainWindow, {
            transparent: true,
            forwardKeyboardInput: true,
            forwardMouseInput: true,
        });
        global.isWallpaperActive = true;
        updateTrayMenu();
        return {
            success: true,
            message: 'Live wallpaper enabled!'
        };
    } catch (error) {
        return {
            success: false,
            message: `Failed to enable live wallpaper: ${error.message}`
        };
    }
});

// Live wallpaper - disable
ipcMain.handle('disable-live-wallpaper', async (event) => {
    try {
        await detach(mainWindow);
        global.isWallpaperActive = false;
        updateTrayMenu();
        return {
            success: true,
            message: 'Live wallpaper disabled.'
        };
    } catch (error) {
        return {
            success: false,
            message: `Failed to disable live wallpaper: ${error.message}`
        };
    }
});

// Live wallpaper - check status
ipcMain.handle('is-live-wallpaper-active', () => {
    return global.isWallpaperActive || false;
});

// Auto-start - enable/disable
ipcMain.handle('set-autostart', async (event, enable) => {
    try {
        if (enable) {
            await autoLauncher.enable();
        } else {
            await autoLauncher.disable();
        }
        return { success: true };
    } catch (error) {
        return {
            success: false,
            message: error.message
        };
    }
});

// Auto-start - check status
ipcMain.handle('is-autostart-enabled', async () => {
    try {
        return await autoLauncher.isEnabled();
    } catch (error) {
        return false;
    }
});

// App info
ipcMain.handle('get-app-info', () => {
    return {
        name: app.getName(),
        version: app.getVersion(),
        platform: process.platform,
        arch: process.arch
    };
});

console.log('[Main] Electron app initialized with tray support');


============================================================
ФАЙЛ: .\electron-app\electron\preload.js
============================================================

/* =========================================
   ELECTRON PRELOAD.JS — Безопасный API для renderer
   с поддержкой Live Wallpaper
   ========================================= */

const { contextBridge, ipcRenderer } = require('electron');

// Безопасно передаем API в renderer процесс
contextBridge.exposeInMainWorld('electronAPI', {
    /**
     * Устанавливает текущее состояние таблицы как статичные обои Windows
     * @returns {Promise<{success: boolean, message: string}>}
     */
    setAsWallpaper: async () => {
        if (process.platform !== 'win32') {
            return {
                success: false,
                message: 'Установка обоев поддерживается только на Windows'
            };
        }

        try {
            const result = await ipcRenderer.invoke('set-wallpaper');
            return result;
        } catch (error) {
            console.error('[Preload] Ошибка setAsWallpaper:', error);
            return {
                success: false,
                message: 'Ошибка связи с главным процессом'
            };
        }
    },

    /**
     * Включает живые обои
     * @returns {Promise<{success: boolean, message: string}>}
     */
    enableLiveWallpaper: async () => {
        try {
            const result = await ipcRenderer.invoke('enable-live-wallpaper');
            return result;
        } catch (error) {
            console.error('[Preload] Ошибка enableLiveWallpaper:', error);
            return {
                success: false,
                message: 'Ошибка связи с главным процессом'
            };
        }
    },

    /**
     * Отключает живые обои
     * @returns {Promise<{success: boolean, message: string}>}
     */
    disableLiveWallpaper: async () => {
        try {
            const result = await ipcRenderer.invoke('disable-live-wallpaper');
            return result;
        } catch (error) {
            console.error('[Preload] Ошибка disableLiveWallpaper:', error);
            return {
                success: false,
                message: 'Ошибка связи с главным процессом'
            };
        }
    },

    /**
     * Проверяет статус живых обоев
     * @returns {Promise<boolean>}
     */
    isLiveWallpaperActive: async () => {
        try {
            const result = await ipcRenderer.invoke('is-live-wallpaper-active');
            return result;
        } catch (error) {
            console.error('[Preload] Ошибка isLiveWallpaperActive:', error);
            return false;
        }
    },

    /**
     * Включает/отключает автозапуск с Windows
     * @param {boolean} enable
     * @returns {Promise<{success: boolean, message?: string}>}
     */
    setAutostart: async (enable) => {
        try {
            const result = await ipcRenderer.invoke('set-autostart', enable);
            return result;
        } catch (error) {
            console.error('[Preload] Ошибка setAutostart:', error);
            return {
                success: false,
                message: 'Ошибка связи с главным процессом'
            };
        }
    },

    /**
     * Проверяет статус автозапуска
     * @returns {Promise<boolean>}
     */
    isAutostartEnabled: async () => {
        try {
            const result = await ipcRenderer.invoke('is-autostart-enabled');
            return result;
        } catch (error) {
            console.error('[Preload] Ошибка isAutostartEnabled:', error);
            return false;
        }
    },

    /**
     * Получает информацию о приложении
     * @returns {Promise<{name: string, version: string, platform: string}>}
     */
    getAppInfo: async () => {
        try {
            const info = await ipcRenderer.invoke('get-app-info');
            return info;
        } catch (error) {
            console.error('[Preload] Ошибка getAppInfo:', error);
            return null;
        }
    },

    /**
     * Проверяет, запущено ли приложение в Electron
     * @returns {boolean}
     */
    isElectron: () => {
        return true;
    }
});

console.log('[Preload] Electron API инициализирован с поддержкой Live Wallpaper');


============================================================
ФАЙЛ: .\electron-app\electron\wallpaper-api.js
============================================================

/* =========================================
   ELECTRON WALLPAPER-API.JS — Windows API для установки обоев
   ========================================= */

const { exec } = require('child_process');
const path = require('path');
const fs = require('fs');

/**
 * Устанавливает изображение как обои рабочего стола Windows
 * @param {string} imagePath - Абсолютный путь к изображению
 * @returns {Promise<void>}
 */
async function setAsWallpaper(imagePath) {
    return new Promise((resolve, reject) => {
        // Проверяем существование файла
        if (!fs.existsSync(imagePath)) {
            return reject(new Error(`Файл не найден: ${imagePath}`));
        }

        // Проверяем платформу
        if (process.platform !== 'win32') {
            return reject(new Error('Установка обоев поддерживается только на Windows'));
        }

        // Нормализуем путь для PowerShell (обратные слеши)
        const normalizedPath = path.resolve(imagePath).replace(/\\/g, '\\\\');

        // PowerShell команда для установки обоев
        const psCommand = `
            $setwallpapersrc = @"
using System.Runtime.InteropServices;
public class Wallpaper {
    public const int SetDesktopWallpaper = 20;
    public const int UpdateIniFile = 0x01;
    public const int SendWinIniChange = 0x02;
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    private static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);
    public static void SetWallpaper(string path) {
        SystemParametersInfo(SetDesktopWallpaper, 0, path, UpdateIniFile | SendWinIniChange);
    }
}
"@
            Add-Type -TypeDefinition $setwallpapersrc
            [Wallpaper]::SetWallpaper("${normalizedPath}")
        `;

        // Альтернативный метод через реестр (более надежный)
        const registryCommand = `
            Set-ItemProperty -path 'HKCU:\\Control Panel\\Desktop' -name Wallpaper -value "${normalizedPath}"
            Set-ItemProperty -path 'HKCU:\\Control Panel\\Desktop' -name WallpaperStyle -value '10'
            Set-ItemProperty -path 'HKCU:\\Control Panel\\Desktop' -name TileWallpaper -value '0'
            rundll32.exe user32.dll, UpdatePerUserSystemParameters, 0, $false
        `;

        // Используем реестровый метод (более стабильный)
        const command = `powershell -Command "${registryCommand.replace(/"/g, '\\"').replace(/\n/g, '; ')}"`;

        console.log('[Wallpaper API] Выполняется команда установки обоев...');

        exec(command, (error, stdout, stderr) => {
            if (error) {
                console.error('[Wallpaper API] Ошибка выполнения:', error);
                console.error('[Wallpaper API] stderr:', stderr);
                return reject(new Error(`Не удалось установить обои: ${error.message}`));
            }

            console.log('[Wallpaper API] Обои успешно установлены!');
            if (stdout) console.log('[Wallpaper API] stdout:', stdout);

            resolve();
        });
    });
}

/**
 * Альтернативный метод через SystemParametersInfo (более прямой подход)
 * @param {string} imagePath - Абсолютный путь к изображению
 * @returns {Promise<void>}
 */
async function setAsWallpaperDirect(imagePath) {
    return new Promise((resolve, reject) => {
        if (!fs.existsSync(imagePath)) {
            return reject(new Error(`Файл не найден: ${imagePath}`));
        }

        if (process.platform !== 'win32') {
            return reject(new Error('Поддерживается только Windows'));
        }

        const normalizedPath = path.resolve(imagePath);

        // Используем C# код через PowerShell для прямого вызова Windows API
        const psScript = `
Add-Type @"
using System;
using System.Runtime.InteropServices;
public class WallpaperHelper {
    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);
}
"@
[WallpaperHelper]::SystemParametersInfo(0x0014, 0, "${normalizedPath.replace(/\\/g, '\\\\')}", 0x0003)
        `;

        const command = `powershell -NoProfile -ExecutionPolicy Bypass -Command "${psScript.replace(/"/g, '\\"').replace(/\n/g, '; ')}"`;

        exec(command, (error, stdout, stderr) => {
            if (error) {
                console.error('[Wallpaper API Direct] Ошибка:', error);
                return reject(error);
            }
            console.log('[Wallpaper API Direct] Успех!');
            resolve();
        });
    });
}

module.exports = {
    setAsWallpaper,
    setAsWallpaperDirect
};


============================================================
ФАЙЛ: .\electron-app\electron\wallpaper-linux.js
============================================================

const { execFileSync } = require('child_process');

function isWaylandSession() {
  return process.env.XDG_SESSION_TYPE === 'wayland' || !!process.env.WAYLAND_DISPLAY;
}

function hasBinary(name) {
  try {
    execFileSync('which', [name], { stdio: 'ignore' });
    return true;
  } catch (error) {
    return false;
  }
}

function getWindowIdHex(window) {
  const handle = window.getNativeWindowHandle();
  let wid;
  if (handle.length >= 8) {
    wid = handle.readBigUInt64LE(0);
  } else {
    wid = BigInt(handle.readUInt32LE(0));
  }
  return `0x${wid.toString(16)}`;
}

function ensureSupported() {
  if (isWaylandSession()) {
    throw new Error('Wayland is not supported for live wallpaper yet.');
  }
  if (!hasBinary('xprop')) {
    throw new Error('Missing dependency: xprop (install package x11-utils).');
  }
}

function setWallpaperProperties(window) {
  const widHex = getWindowIdHex(window);
  execFileSync('xprop', [
    '-id',
    widHex,
    '-f',
    '_NET_WM_WINDOW_TYPE',
    '32a',
    '-set',
    '_NET_WM_WINDOW_TYPE',
    '_NET_WM_WINDOW_TYPE_DESKTOP'
  ]);
  execFileSync('xprop', [
    '-id',
    widHex,
    '-f',
    '_NET_WM_STATE',
    '32a',
    '-set',
    '_NET_WM_STATE',
    '_NET_WM_STATE_BELOW,_NET_WM_STATE_STICKY,_NET_WM_STATE_SKIP_TASKBAR,_NET_WM_STATE_SKIP_PAGER'
  ]);
}

function clearWallpaperProperties(window) {
  const widHex = getWindowIdHex(window);
  execFileSync('xprop', ['-id', widHex, '-remove', '_NET_WM_STATE']);
  execFileSync('xprop', [
    '-id',
    widHex,
    '-f',
    '_NET_WM_WINDOW_TYPE',
    '32a',
    '-set',
    '_NET_WM_WINDOW_TYPE',
    '_NET_WM_WINDOW_TYPE_NORMAL'
  ]);
}

async function attach(window) {
  ensureSupported();
  window.setAlwaysOnTop(false);
  window.setFullScreen(true);
  window.setSkipTaskbar(true);
  window.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
  setWallpaperProperties(window);
}

async function detach(window) {
  try {
    clearWallpaperProperties(window);
  } catch (error) {
    // Best effort cleanup; don't block shutdown.
  }
  window.setSkipTaskbar(false);
  window.setVisibleOnAllWorkspaces(false);
  window.setFullScreen(false);
}

function reset(window) {
  return detach(window);
}

module.exports = {
  attach,
  detach,
  reset
};


============================================================
ФАЙЛ: .\electron-app\electron\win32-api.js
============================================================

/**
 * Windows API Bindings for Live Wallpaper
 * Uses C#, PowerShell and child_process to interact with Windows desktop
 */

const { execSync, spawnSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

// Debug logger
function log(msg) {
    try {
        const logFile = path.join(process.cwd(), 'debug_wp.txt');
        fs.appendFileSync(logFile, `[${new Date().toISOString()}] ${msg}\n`);
    } catch (e) { }
}

/**
 * Consolidated Wallpaper Setup: Finding WorkerW, Reparenting, and Positioning
 * all in one C# execution for maximum reliability.
 */
async function attachToWallpaper(childHandle, width, height) {
    log(`attachToWallpaper called: Child=${childHandle}, Size=${width}x${height}`);

    // C# source code for window attachment
    const csCode = `
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

class P {
    [DllImport("user32.dll")] static extern IntPtr FindWindow(string c, string w);
    [DllImport("user32.dll")] static extern IntPtr FindWindowEx(IntPtr p, IntPtr a, string c, string w);
    [DllImport("user32.dll")] static extern IntPtr SendMessageTimeout(IntPtr h, uint m, UIntPtr w, IntPtr l, uint f, uint t, out IntPtr r);
    [DllImport("user32.dll")] static extern bool EnumWindows(EP e, IntPtr l);
    [DllImport("user32.dll")] static extern int GetClassName(IntPtr h, StringBuilder s, int n);
    [DllImport("user32.dll", SetLastError = true)] static extern IntPtr SetParent(IntPtr c, IntPtr p);
    [DllImport("user32.dll")] static extern bool SetWindowPos(IntPtr h, IntPtr a, int x, int y, int cx, int cy, uint f);
    [DllImport("user32.dll")] static extern bool ShowWindow(IntPtr h, int c);
    [DllImport("user32.dll")] static extern int SetWindowLong(IntPtr h, int i, int v);
    [DllImport("user32.dll")] static extern bool IsWindowVisible(IntPtr h);
    [DllImport("user32.dll")] static extern bool GetClientRect(IntPtr h, out RECT r);

    delegate bool EP(IntPtr h, IntPtr l);

    [StructLayout(LayoutKind.Sequential)]
    public struct RECT { public int Left; public int Top; public int Right; public int Bottom; }

    static void Main() {
        try {
            IntPtr progman = FindWindow("Progman", null);
            if (progman == IntPtr.Zero) return;

            // Trigger WorkerW
            IntPtr result;
            SendMessageTimeout(progman, 0x052C, UIntPtr.Zero, IntPtr.Zero, 0, 1000, out result);
            Thread.Sleep(500);

            IntPtr wallpaperWorkerW = IntPtr.Zero;
            EnumWindows(new EP((h, l) => {
                StringBuilder sb = new StringBuilder(256);
                GetClassName(h, sb, 256);
                if (sb.ToString() == "WorkerW") {
                    if (FindWindowEx(h, IntPtr.Zero, "SHELLDLL_DefView", null) == IntPtr.Zero) {
                        wallpaperWorkerW = h;
                    }
                }
                return true;
            }), IntPtr.Zero);

            IntPtr target = (wallpaperWorkerW != IntPtr.Zero) ? wallpaperWorkerW : progman;
            
            long hVal = long.Parse("${childHandle}");
            IntPtr child = new IntPtr(hVal);
            
            // WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS
            SetWindowLong(child, -16, 0x40000000 | 0x10000000 | 0x04000000);
            SetParent(child, target);

            RECT rect;
            GetClientRect(target, out rect);
            int w = rect.Right - rect.Left;
            int h = rect.Bottom - rect.Top;
            if (w <= 0) { w = ${width}; h = ${height}; }

            // HWND_BOTTOM (1)
            SetWindowPos(child, new IntPtr(1), 0, 0, w, h, 0x0040 | 0x0010);
            ShowWindow(child, 5);

            Console.WriteLine("SUCCESS:" + target.ToInt64());
        } catch (Exception e) {
            Console.WriteLine("ERR:" + e.Message);
        }
    }
}
`;

    const tempDir = os.tmpdir();
    const csFile = path.join(tempDir, `att-${Date.now()}.cs`);
    const exeFile = path.join(tempDir, `att-${Date.now()}.exe`);

    return new Promise((resolve) => {
        try {
            fs.writeFileSync(csFile, csCode, 'utf8');
            const cscPath = fs.existsSync('C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe')
                ? 'C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe'
                : 'C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe';

            if (!fs.existsSync(cscPath)) {
                log('CSC not found');
                resolve(null);
                return;
            }

            const compileResult = spawnSync(cscPath, ['/nologo', '/optimize', `/out:${exeFile}`, csFile], { windowsHide: true });
            if (compileResult.status !== 0) {
                log('CSC compilation failed: ' + compileResult.stderr.toString());
                resolve(null);
                return;
            }

            const childProc = spawn(exeFile, [], { windowsHide: true });
            let output = '';
            childProc.stdout.on('data', (data) => output += data.toString());
            childProc.on('close', (code) => {
                log('attachToWallpaper exit ' + code + ' output: ' + output.trim());
                try { fs.unlinkSync(csFile); } catch (e) { }
                setTimeout(() => { try { fs.unlinkSync(exeFile); } catch (e) { } }, 5000);

                if (output.includes('SUCCESS')) {
                    const hStr = output.split('SUCCESS:')[1].trim().split(/[\r\n]+/)[0];
                    resolve(parseInt(hStr, 10));
                } else {
                    resolve(null);
                }
            });
        } catch (e) {
            log('attachToWallpaper error: ' + e.message);
            resolve(null);
        }
    });
}

/**
 * Capture a screenshot of the current desktop (with icons)
 * to be used as a background overlay.
 */
async function getDesktopScreenshot(outputPath) {
    log(`Capturing desktop to ${outputPath}`);
    try {
        const script = `
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
$Screen = [System.Windows.Forms.Screen]::PrimaryScreen
$Width  = $Screen.Bounds.Width
$Height = $Screen.Bounds.Height
$Left   = $Screen.Bounds.Left
$Top    = $Screen.Bounds.Top
$Bitmap = New-Object System.Drawing.Bitmap($Width, $Height)
$Graphic = [System.Drawing.Graphics]::FromImage($Bitmap)
$Graphic.CopyFromScreen($Left, $Top, 0, 0, $Bitmap.Size)
$Bitmap.Save("${outputPath.replace(/\\/g, '\\\\')}", [System.Drawing.Imaging.ImageFormat]::Png)
$Graphic.Dispose()
$Bitmap.Dispose()
`;
        const tempFile = path.join(os.tmpdir(), `cap-${Date.now()}.ps1`);
        fs.writeFileSync(tempFile, '\ufeff' + script, 'utf8');

        return new Promise((resolve) => {
            const ps = spawn('powershell', ['-NoProfile', '-ExecutionPolicy', 'Bypass', '-File', tempFile], { windowsHide: true });
            ps.on('close', (code) => {
                try { fs.unlinkSync(tempFile); } catch (e) { }
                log(`Capture finished with code ${code}`);
                resolve(code === 0);
            });
        });
    } catch (e) {
        log('Capture error: ' + e.message);
        return false;
    }
}

/**
 * Legacy support for finding Progman
 */
function findProgman() {
    try {
        const script = `
Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
public class User32Progman {
    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
}
'@
$handle = [User32Progman]::FindWindow("Progman", $null)
Write-Output $handle.ToInt64()
`;
        const tempFile = path.join(os.tmpdir(), `prog-${Date.now()}.ps1`);
        fs.writeFileSync(tempFile, '\ufeff' + script, 'utf8');
        const result = execSync(`powershell -NoProfile -ExecutionPolicy Bypass -File "${tempFile}"`, { encoding: 'utf8', windowsHide: true });
        try { fs.unlinkSync(tempFile); } catch (e) { }
        return parseInt(result, 10);
    } catch (e) { return 0; }
}

/**
 * Refresh desktop icons
 */
function refreshDesktop() {
    try {
        const script = `
Add-Type -TypeDefinition @'
using System;
using System.Runtime.InteropServices;
public class User32 {
    [DllImport("user32.dll", SetLastError = true)]
    public static extern bool SystemParametersInfo(uint uiAction, uint uiParam, IntPtr pvParam, uint fWinIni);
}
'@
[User32]::SystemParametersInfo(20, 0, [IntPtr]::Zero, 3)
`;
        const tempFile = path.join(os.tmpdir(), `ref-${Date.now()}.ps1`);
        fs.writeFileSync(tempFile, script, 'utf8');
        spawn('powershell', ['-NoProfile', '-ExecutionPolicy', 'Bypass', '-File', tempFile], { detached: true, windowsHide: true }).unref();
        setTimeout(() => { try { fs.unlinkSync(tempFile); } catch (e) { } }, 5000);
        return true;
    } catch (e) { return false; }
}

module.exports = {
    attachToWallpaper,
    findProgman,
    refreshDesktop
};


============================================================
ФАЙЛ: .\icons\README.md
============================================================

# SVG Иконки

Эта директория содержит все SVG иконки проекта в виде отдельных файлов.

## Список иконок

| Файл | Описание | Использование |
|------|----------|---------------|
| `icon-calc.svg` | Калькулятор | Кнопка калькулятора в FAB меню |
| `icon-sun.svg` | Солнце | Переключатель темы (светлая тема) |
| `icon-moon.svg` | Луна | Переключатель темы (темная тема) |
| `icon-particles.svg` | Частицы | Кнопка частиц в FAB меню |
| `icon-menu.svg` | Гамбургер меню | Кнопка открытия меню |
| `icon-close.svg` | Крестик | Кнопка закрытия меню |
| `icon-filter.svg` | Фильтр | Кнопка фильтров |
| `icon-search.svg` | Лупа | Кнопка поиска |
| `icon-palette.svg` | Палитра | Цветовые режимы |
| `icon-bolt.svg` | Молния | Ряды активности |
| `icon-info.svg` | Информация | Продвинутый режим |

## Как работает

SVG файлы автоматически собираются в спрайт при помощи скрипта `build-icons.js`.

### Процесс сборки

1. Скрипт читает все SVG файлы из этой директории
2. Конвертирует каждый SVG в `<symbol>` элемент
3. Генерирует `js/icons.js` с inline спрайтом
4. Иконки становятся доступны через `<use href="#icon-name">`

### Запуск сборки

```bash
node build-icons.js
```

> **Важно:** После изменения любого SVG файла нужно запустить сборку!

## Добавление новой иконки

1. Создайте новый SVG файл в этой директории:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <!-- содержимое иконки -->
</svg>
```

2. Добавьте имя файла (без .svg) в массив `iconFiles` в `build-icons.js`

3. Запустите сборку:

```bash
node build-icons.js
```

4. Используйте в HTML:

```html
<svg><use href="#icon-название"></use></svg>
```

## Редактирование иконки

1. Откройте нужный SVG файл в редакторе
2. Внесите изменения
3. Запустите `node build-icons.js`
4. Перезагрузите страницу в браузере

## Формат SVG

Все иконки должны соответствовать стандарту:

- **viewBox**: `0 0 24 24` (рекомендуется)
- **Атрибуты**: используйте `currentColor` для цветов, чтобы иконки наследовали цвет текста
- **Оптимизация**: удалите ненужные атрибуты (id, class из графических редакторов)

## Инструменты для работы с SVG

- **Редакторы**: Figma, Adobe Illustrator, Inkscape
- **Оптимизация**: [SVGOMG](https://jakearchibald.github.io/svgomg/)
- **Просмотр**: Любой браузер или VS Code с расширением SVG

## Технические детали

- Формат: SVG 1.1
- Кодировка: UTF-8
- Размер viewBox: 24x24 (стандарт Material Design)
- Стиль обводки: `stroke="currentColor"` для адаптивности

## GitHub Linguist

Файл `.gitattributes` в корне проекта настроен так, чтобы GitHub распознавал SVG как язык программирования:

```
*.svg linguist-detectable=true
*.svg linguist-language=SVG
```

Это позволяет SVG отображаться в статистике языков репозитория.


============================================================
ФАЙЛ: .\js\bad-apple.js
============================================================

(function () {
    'use strict';

    const PERIODIC_SYMBOL_GRID_18X10 = [
        ['H', null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 'He'],
        ['Li', 'Be', null, null, null, null, null, null, null, null, null, null, 'B', 'C', 'N', 'O', 'F', 'Ne'],
        ['Na', 'Mg', null, null, null, null, null, null, null, null, null, null, 'Al', 'Si', 'P', 'S', 'Cl', 'Ar'],
        ['K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr'],
        ['Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe'],
        ['Cs', 'Ba', null, 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn'],
        ['Fr', 'Ra', null, 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og'],
        [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
        [null, null, 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', null],
        [null, null, 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', null]
    ];

    function toSelector(symbol) {
        return '#' + symbol + ',[data-symbol="' + symbol + '"]';
    }

    const PERIODIC_SELECTOR_GRID_18X10 = PERIODIC_SYMBOL_GRID_18X10.map((row) => {
        return row.map((symbol) => (symbol ? toSelector(symbol) : null));
    });

    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    function rgbToCss(rgb) {
        return 'rgb(' + rgb[0] + ', ' + rgb[1] + ', ' + rgb[2] + ')';
    }

    function blendRgb(fromRgb, toRgb, alpha) {
        const a = clamp(alpha, 0, 1);
        return [
            Math.round(fromRgb[0] + (toRgb[0] - fromRgb[0]) * a),
            Math.round(fromRgb[1] + (toRgb[1] - fromRgb[1]) * a),
            Math.round(fromRgb[2] + (toRgb[2] - fromRgb[2]) * a)
        ];
    }

    function parseColor(color) {
        if (typeof color !== 'string') {
            return [0, 0, 0];
        }

        const raw = color.trim();
        const hex = raw.match(/^#([a-fA-F0-9]{3}|[a-fA-F0-9]{6})$/);
        if (hex) {
            const value = hex[1];
            if (value.length === 3) {
                return [
                    parseInt(value[0] + value[0], 16),
                    parseInt(value[1] + value[1], 16),
                    parseInt(value[2] + value[2], 16)
                ];
            }
            return [
                parseInt(value.slice(0, 2), 16),
                parseInt(value.slice(2, 4), 16),
                parseInt(value.slice(4, 6), 16)
            ];
        }

        const rgb = raw.match(/^rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)$/i);
        if (rgb) {
            return [
                clamp(Number(rgb[1]), 0, 255),
                clamp(Number(rgb[2]), 0, 255),
                clamp(Number(rgb[3]), 0, 255)
            ];
        }

        if (typeof document !== 'undefined' && document.body) {
            const temp = document.createElement('span');
            temp.style.color = raw;
            temp.style.display = 'none';
            document.body.appendChild(temp);
            const computed = window.getComputedStyle(temp).color;
            document.body.removeChild(temp);
            return parseColor(computed);
        }

        return [0, 0, 0];
    }

    class BadApplePlayer {
        constructor(options) {
            const config = options || {};
            const normalizedPayload = BadApplePlayer.normalizePayload(
                config.payload || BadApplePlayer.createDemoPayload()
            );

            this.root = config.root || document;
            this.gridMap = config.gridMap || PERIODIC_SELECTOR_GRID_18X10;
            this.syncAudio = config.syncAudio !== false;
            this.audio = this._resolveAudio(config.audio || null);
            this.onFinish = typeof config.onFinish === 'function' ? config.onFinish : null;

            this.onRgb = parseColor(config.onColor || '#111111');
            this.offRgb = parseColor(config.offColor || '#f3f3f3');

            this.payload = normalizedPayload;
            this.width = normalizedPayload.width;
            this.height = normalizedPayload.height;
            this.fps = normalizedPayload.fps;
            this.encoding = normalizedPayload.encoding;
            this.frames = normalizedPayload.frames;
            this.frameCount = this.frames.length;

            this.isPlaying = false;
            this.currentFrame = 0;
            this._lastRenderedFrame = -1;
            this._startTimeMs = null;
            this._rafId = null;
            this._tickBound = this._tick.bind(this);

            this._cells = this._resolveGridCells(this.gridMap);
            this._originalStyleAttr = new Map();
            this._rememberOriginalStyles();
        }

        static normalizePayload(payloadInput) {
            let payload = payloadInput;
            if (typeof payloadInput === 'string') {
                payload = JSON.parse(payloadInput);
            }

            if (!payload || typeof payload !== 'object') {
                throw new Error('BadApplePlayer payload must be an object or JSON string.');
            }

            const width = Math.max(1, Number(payload.width) || 18);
            const height = Math.max(1, Number(payload.height) || 10);
            const fps = Math.max(1, Number(payload.fps) || 12);
            const encoding = String(payload.encoding || 'hex-bitset-v1').toLowerCase();
            const frames = Array.isArray(payload.frames) ? payload.frames.slice() : [];

            if (encoding !== 'hex-bitset-v1' && encoding !== 'hex-nibbles-v1') {
                throw new Error('Unsupported payload encoding: ' + encoding);
            }

            const expectedLength = encoding === 'hex-bitset-v1'
                ? Math.ceil((width * height) / 4)
                : width * height;

            const normalizedFrames = frames.map((frame) => {
                const cleaned = String(frame || '')
                    .toLowerCase()
                    .replace(/[^0-9a-f]/g, '');

                if (cleaned.length >= expectedLength) {
                    return cleaned.slice(0, expectedLength);
                }
                return cleaned + '0'.repeat(expectedLength - cleaned.length);
            });

            return {
                width,
                height,
                fps,
                encoding,
                frames: normalizedFrames
            };
        }

        static _bitsToHex(bits) {
            let result = '';
            for (let index = 0; index < bits.length; index += 4) {
                const b0 = bits[index] ? 1 : 0;
                const b1 = bits[index + 1] ? 1 : 0;
                const b2 = bits[index + 2] ? 1 : 0;
                const b3 = bits[index + 3] ? 1 : 0;
                result += ((b0 << 3) | (b1 << 2) | (b2 << 1) | b3).toString(16);
            }
            return result;
        }

        static createDemoPayload(options) {
            const config = options || {};
            const width = Math.max(1, Number(config.width) || 18);
            const height = Math.max(1, Number(config.height) || 10);
            const fps = Math.max(1, Number(config.fps) || 12);
            const durationSeconds = Math.max(1, Number(config.durationSeconds) || 8);
            const frameCount = Math.max(1, Math.floor(fps * durationSeconds));
            const frames = [];

            for (let frameIndex = 0; frameIndex < frameCount; frameIndex += 1) {
                const bits = new Array(width * height).fill(0);
                const t = frameIndex / frameCount;
                const cx = Math.sin(t * 6) * 0.45;
                const cy = Math.cos(t * 5) * 0.25;

                for (let row = 0; row < height; row += 1) {
                    for (let col = 0; col < width; col += 1) {
                        const nx = (col / Math.max(1, width - 1)) * 2 - 1;
                        const ny = (row / Math.max(1, height - 1)) * 2 - 1;
                        const distance = Math.sqrt((nx - cx) * (nx - cx) + (ny - cy) * (ny - cy));
                        const ring = distance > 0.28 && distance < 0.48;
                        const wave = Math.sin(nx * 4 + t * 12) + Math.cos(ny * 3 - t * 9);
                        const sweep = Math.abs(col - ((frameIndex * 2) % width)) <= 0;
                        const on = ring || wave > 0.85 || sweep;
                        bits[row * width + col] = on ? 1 : 0;
                    }
                }

                frames.push(BadApplePlayer._bitsToHex(bits));
            }

            return {
                encoding: 'hex-bitset-v1',
                width,
                height,
                fps,
                frames
            };
        }

        setPayload(payloadInput, options) {
            const config = options || {};
            const normalizedPayload = BadApplePlayer.normalizePayload(payloadInput);
            this.stop({ restore: true, reset: false });

            this.payload = normalizedPayload;
            this.width = normalizedPayload.width;
            this.height = normalizedPayload.height;
            this.fps = normalizedPayload.fps;
            this.encoding = normalizedPayload.encoding;
            this.frames = normalizedPayload.frames;
            this.frameCount = this.frames.length;

            if (config.reset !== false) {
                this.currentFrame = 0;
                this._lastRenderedFrame = -1;
            }
        }

        play(options) {
            const config = options || {};
            if (this.frameCount === 0) {
                return;
            }

            if (config.restart) {
                this.currentFrame = 0;
                this._lastRenderedFrame = -1;
            }

            if (this.currentFrame >= this.frameCount) {
                this.currentFrame = 0;
                this._lastRenderedFrame = -1;
            }

            if (this.isPlaying) {
                return;
            }

            this.isPlaying = true;
            this._startTimeMs = performance.now() - (this.currentFrame * 1000) / this.fps;

            if (this.audio && this.syncAudio) {
                try {
                    const targetTime = this.currentFrame / this.fps;
                    if (Math.abs(this.audio.currentTime - targetTime) > 0.12) {
                        this.audio.currentTime = targetTime;
                    }
                    const playPromise = this.audio.play();
                    if (playPromise && typeof playPromise.catch === 'function') {
                        playPromise.catch(() => {});
                    }
                } catch (error) {
                    // Ignore autoplay restrictions.
                }
            }

            this._rafId = requestAnimationFrame(this._tickBound);
        }

        pause(options) {
            const config = options || {};
            if (!this.isPlaying) {
                return;
            }
            this.isPlaying = false;

            if (this._rafId !== null) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }

            if (config.pauseAudio !== false && this.audio && !this.audio.paused) {
                this.audio.pause();
            }
        }

        stop(options) {
            const config = options || {};
            this.pause({ pauseAudio: config.pauseAudio });

            if (config.restore !== false) {
                this.restoreOriginalStyles();
            }

            if (config.reset !== false) {
                this.currentFrame = 0;
                this._lastRenderedFrame = -1;
                this._startTimeMs = null;
                if (this.audio && config.pauseAudio !== false) {
                    try {
                        this.audio.currentTime = 0;
                    } catch (error) {
                        // Ignore out-of-range seek issues.
                    }
                }
            }
        }

        seekFrame(frameIndex, options) {
            const config = options || {};
            const clampedFrame = clamp(
                Math.floor(Number(frameIndex) || 0),
                0,
                Math.max(0, this.frameCount - 1)
            );

            this.currentFrame = clampedFrame;
            this._lastRenderedFrame = -1;
            this._startTimeMs = performance.now() - (clampedFrame * 1000) / this.fps;

            if (config.syncAudio !== false && this.audio) {
                try {
                    this.audio.currentTime = clampedFrame / this.fps;
                } catch (error) {
                    // Ignore out-of-range seek issues.
                }
            }

            if (config.render !== false) {
                this.renderFrame(clampedFrame);
                this._lastRenderedFrame = clampedFrame;
            }
        }

        renderFrame(frameIndex) {
            if (frameIndex < 0 || frameIndex >= this.frameCount) {
                return;
            }

            const frameData = this.frames[frameIndex];
            const totalPixels = this.width * this.height;

            for (let pixelIndex = 0; pixelIndex < totalPixels; pixelIndex += 1) {
                const row = Math.floor(pixelIndex / this.width);
                const col = pixelIndex % this.width;
                const cell = this._cells[row] && this._cells[row][col];
                if (!cell) {
                    continue;
                }

                const level = this._readPixelLevel(frameData, pixelIndex);
                const rgb = blendRgb(this.offRgb, this.onRgb, level);
                const color = rgbToCss(rgb);
                cell.style.transition = 'none';
                cell.style.backgroundColor = color;
                cell.style.color = color;
                cell.style.boxShadow = 'none';
            }
        }

        restoreOriginalStyles() {
            this._originalStyleAttr.forEach((styleValue, cell) => {
                if (styleValue === null) {
                    cell.removeAttribute('style');
                } else {
                    cell.setAttribute('style', styleValue);
                }
            });
        }

        _tick(timestampMs) {
            if (!this.isPlaying) {
                return;
            }

            let frameIndex;
            if (this.audio && this.syncAudio && !this.audio.paused && !this.audio.ended) {
                frameIndex = Math.floor(this.audio.currentTime * this.fps);
            } else {
                frameIndex = Math.floor((timestampMs - this._startTimeMs) / (1000 / this.fps));
            }

            if (frameIndex >= this.frameCount || (this.audio && this.syncAudio && this.audio.ended)) {
                this.stop({ restore: true, reset: true, pauseAudio: false });
                if (this.onFinish) {
                    this.onFinish();
                }
                return;
            }

            if (frameIndex !== this._lastRenderedFrame && frameIndex >= 0) {
                this.renderFrame(frameIndex);
                this._lastRenderedFrame = frameIndex;
                this.currentFrame = frameIndex + 1;
            }

            this._rafId = requestAnimationFrame(this._tickBound);
        }

        _readPixelLevel(frameData, pixelIndex) {
            if (this.encoding === 'hex-nibbles-v1') {
                const nibble = parseInt(frameData[pixelIndex] || '0', 16);
                return clamp(nibble / 15, 0, 1);
            }

            const charIndex = Math.floor(pixelIndex / 4);
            const bitOffset = 3 - (pixelIndex % 4);
            const nibble = parseInt(frameData[charIndex] || '0', 16);
            const bit = (nibble >> bitOffset) & 1;
            return bit;
        }

        _resolveAudio(audioInput) {
            if (!audioInput) {
                return null;
            }
            if (typeof audioInput === 'string') {
                return this.root.querySelector(audioInput);
            }
            if (typeof audioInput.play === 'function') {
                return audioInput;
            }
            return null;
        }

        _resolveGridCells(gridMap) {
            const rows = [];
            for (let row = 0; row < this.height; row += 1) {
                const rowDef = Array.isArray(gridMap[row]) ? gridMap[row] : [];
                const resolvedRow = [];
                for (let col = 0; col < this.width; col += 1) {
                    resolvedRow.push(this._resolveCell(rowDef[col]));
                }
                rows.push(resolvedRow);
            }
            return rows;
        }

        _resolveCell(cellDef) {
            if (!cellDef) {
                return null;
            }

            if (cellDef.nodeType === 1) {
                return cellDef;
            }

            if (Array.isArray(cellDef)) {
                for (const candidate of cellDef) {
                    const resolved = this._resolveCell(candidate);
                    if (resolved) {
                        return resolved;
                    }
                }
                return null;
            }

            if (typeof cellDef === 'string') {
                return this.root.querySelector(cellDef);
            }

            if (typeof cellDef === 'object' && cellDef.selector) {
                return this.root.querySelector(String(cellDef.selector));
            }

            if (typeof cellDef === 'object' && cellDef.element && cellDef.element.nodeType === 1) {
                return cellDef.element;
            }

            return null;
        }

        _rememberOriginalStyles() {
            const visited = new Set();
            for (const row of this._cells) {
                for (const cell of row) {
                    if (!cell || visited.has(cell)) {
                        continue;
                    }
                    visited.add(cell);
                    this._originalStyleAttr.set(cell, cell.getAttribute('style'));
                }
            }
        }
    }

    window.BadApplePlayer = BadApplePlayer;
    window.PERIODIC_SYMBOL_GRID_18X10 = PERIODIC_SYMBOL_GRID_18X10;
    window.PERIODIC_SELECTOR_GRID_18X10 = PERIODIC_SELECTOR_GRID_18X10;
})();


============================================================
ФАЙЛ: .\js\download-link-updater.js
============================================================

/**
 * Updates download button link to point to latest GitHub release
 */
async function updateDownloadLink() {
    const downloadBtn = document.getElementById('download-app-btn');
    const linuxBtn = document.getElementById('download-linux-btn');
    const linuxAppImage = document.getElementById('download-linux-appimage');
    const linuxDeb = document.getElementById('download-linux-deb');

    if (!downloadBtn && !linuxBtn && !linuxAppImage && !linuxDeb) {
        console.log('[Download] Button not found, skipping update');
        return;
    }

    try {
        console.log('[Download] Fetching latest release info...');
        const response = await fetch('https://api.github.com/repos/layfhaker/mendeleevtable/releases');

        if (!response.ok) {
            throw new Error(`GitHub API error: ${response.status}`);
        }

        const releases = await response.json();
        const data = releases[0]; // Get most recent release (includes pre-releases)
        if (!data) throw new Error('No releases found');
        console.log('[Download] Latest release:', data.tag_name);

        // Find the .exe installer file
        const exeAsset = data.assets.find(asset =>
            asset.name.toLowerCase().endsWith('.exe') &&
            !asset.name.includes('Portable')
        );
        const appImageAsset = data.assets.find(asset =>
            asset.name.toLowerCase().endsWith('.appimage')
        );
        const debAsset = data.assets.find(asset =>
            asset.name.toLowerCase().endsWith('.deb')
        );

        if (exeAsset) {
            downloadBtn.href = exeAsset.browser_download_url;
            console.log('[Download] Link updated:', exeAsset.name);

            // Update version display
            const versionSpan = document.querySelector('.download-details span:first-child');
            if (versionSpan) {
                versionSpan.textContent = `Версия ${data.tag_name.replace('v', '')}`;
            }

            // Update file size
            const sizeSpan = document.querySelector('.download-details span:last-child');
            if (sizeSpan) {
                const sizeMB = (exeAsset.size / (1024 * 1024)).toFixed(1);
                sizeSpan.textContent = `~${sizeMB} МБ`;
            }
        } else {
            console.warn('[Download] No .exe file found in latest release');
        }

        if (appImageAsset && linuxBtn) {
            linuxBtn.href = appImageAsset.browser_download_url;
        }
        if (appImageAsset && linuxAppImage) {
            linuxAppImage.href = appImageAsset.browser_download_url;
        }
        if (debAsset && linuxDeb) {
            linuxDeb.href = debAsset.browser_download_url;
        }
    } catch (error) {
        console.error('[Download] Failed to update link:', error);
        // Keep default link as fallback
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', updateDownloadLink);
} else {
    updateDownloadLink();
}


============================================================
ФАЙЛ: .\js\elements.js
============================================================

﻿const elementsData = {
    "H": {
        atomicNumber: "1",
        name: "Водород",
        atomicMass: "1.008",
        period: "1",
        group: "1",
        block: "s",
        category: "Неметалл",
        electronConfig: "1s<sup>1</sup>",
        electronConfigFull: "1s<sup>1</sup>",
        electronConfigShort: "1s<sup>1</sup>",
        valenceStates: "I",
        shellDistribution: [1],
        orbitals: [
            { n: 1, l: "s", electrons: 1 }
        ],
        electronegativity: "2.20",
        density: "0.00008988 г/см³",
        meltingPoint: "−259.14 °C",
        boilingPoint: "−252.87 °C",
        state: "Газ",
        color: "Бесцветный",
        discoveryYear: "1766",
        discoverer: "Генри Кавендиш",
        nameOrigin: "От греч. ὕδωρ (вода) + γεννάω (рождаю) — «рождающий воду»",
        applications: "Производство аммиака, нефтепереработка, топливные элементы, ракетное топливо, сварка, воздушные шары",
        facts: "Самый лёгкий и самый распространённый элемент во Вселенной (около 75% всей барионной массы). Имеет три изотопа с собственными названиями: протий, дейтерий и тритий."
    },

    "He": {
        atomicNumber: "2",
        name: "Гелий",
        atomicMass: "4.0026",
        period: "1",
        group: "18",
        block: "s",
        category: "Благородный газ",
        electronConfig: "1s<sup>2</sup>",
        electronConfigFull: "1s<sup>2</sup>",
        electronConfigShort: "1s<sup>2</sup>",
        valenceStates: "0",
        shellDistribution: [2],
        orbitals: [
            { n: 1, l: "s", electrons: 2 }
        ],
        electronegativity: "-",
        density: "0.0001785 г/см³",
        meltingPoint: "−272.20 °C (при 2.5 МПа)",
        boilingPoint: "−268.93 °C",
        state: "Газ",
        color: "Бесцветный",
        discoveryYear: "1868 (спектр), 1895 (выделен)",
        discoverer: "Жюль Жансен, Норман Локьер (спектр); Уильям Рамзай (выделение)",
        nameOrigin: "От греч. ἥλιος (helios) — «солнце», т.к. был обнаружен в спектре Солнца",
        applications: "Криогеника, охлаждение МРТ-сканеров, защитная атмосфера для сварки, воздушные шары и дирижабли, дыхательные смеси для водолазов",
        facts: "Имеет самую низкую температуру кипения среди всех элементов. Второй по распространённости элемент во Вселенной (около 24% массы). При охлаждении ниже 2.17 K становится сверхтекучим."
    },

    "Li": {
        atomicNumber: "3",
        name: "Литий",
        atomicMass: "6.94",
        period: "2",
        group: "1",
        block: "s",
        category: "Щелочной металл",
        electronConfig: "[He] 2s<sup>1</sup>",
        valenceStates: "I",
        electronegativity: "0.98",
        density: "0.534 г/см³",
        meltingPoint: "180.50 °C",
        boilingPoint: "1342 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1817",
        discoverer: "Юхан Август Арфведсон",
        nameOrigin: "От греч. λίθος (lithos) — «камень»",
        applications: "Литий-ионные аккумуляторы, керамика и стекло, смазки, лекарства (стабилизатор настроения при биполярном расстройстве), ядерная энергетика",
        facts: "Самый лёгкий металл и наименее плотный твёрдый элемент. Может плавать на воде. Литий-6 используется в термоядерном оружии."
    },

    "Be": {
        atomicNumber: "4",
        name: "Бериллий",
        atomicMass: "9.0122",
        period: "2",
        group: "2",
        block: "s",
        category: "Щелочноземельный металл",
        electronConfig: "[He] 2s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: "1.57",
        density: "1.85 г/см³",
        meltingPoint: "1287 °C",
        boilingPoint: "2970 °C",
        state: "Твёрдое",
        color: "Стально-серый",
        discoveryYear: "1798 (открыт), 1828 (выделен)",
        discoverer: "Луи Воклен (открытие); Фридрих Вёлер, Антуан Бюсси (выделение)",
        nameOrigin: "От минерала берилл (греч. βήρυλλος)",
        applications: "Окна для рентгеновских трубок, аэрокосмическая промышленность, сплав бериллиевая бронза (пружины, инструменты без искр), ядерные реакторы (замедлитель нейтронов)",
        facts: "Прозрачен для рентгеновского излучения. Токсичен — вдыхание пыли вызывает бериллиоз. Драгоценные камни изумруд и аквамарин — это разновидности берилла."
    },

    "B": {
        atomicNumber: "5",
        name: "Бор",
        atomicMass: "10.81",
        period: "2",
        group: "13",
        block: "p",
        category: "Металлоид",
        electronConfig: "[He] 2s<sup>2</sup> 2p<sup>1</sup>",
        valenceStates: "III",
        electronegativity: "2.04",
        density: "2.34 г/см³ (β-ромбоэдрический)",
        meltingPoint: "2076 °C",
        boilingPoint: "3927 °C",
        state: "Твёрдое",
        color: "Чёрный (кристаллический), коричневый (аморфный)",
        discoveryYear: "1808",
        discoverer: "Жозеф Гей-Люссак, Луи Тенар; Гемфри Дэви",
        nameOrigin: "От араб. بورق (бурак) через минерал бура",
        applications: "Стекловолокно, боросиликатное стекло (Pyrex), отбеливатели (перборат натрия), полупроводники, нитрид бора (абразив, аналог алмаза)",
        facts: "Имеет несколько аллотропов. Кристаллический бор — один из самых твёрдых материалов (9.3 по шкале Мооса). Нитрид бора имеет структуры, аналогичные графиту и алмазу.",
        allotropes: {
            amorphous: {
                name: "Аморфный бор",
                density: "1.73 г/см³",
                color: "Коричневый порошок",
                structure: "Аморфная",
                alloDiscoveryYear: "1808",
                alloDiscoverer: "Гей-Люссак, Тенар, Дэви",
                alloFacts: "Первая полученная форма бора, чистота ~50%"
            },
            betaRhombohedral: {
                name: "β-ромбоэдрический",
                density: "2.34 г/см³",
                color: "Чёрный",
                structure: "Ромбоэдрическая (106-атомная ячейка)",
                hardness: "9.3 по шкале Мооса",
                properties: "Основная стабильная форма",
                alloDiscoveryYear: "1909",
                alloDiscoverer: "Вайнтрауб",
                alloFacts: "Первая чистая кристаллическая форма бора"
            }
        },
        extraAllotropes: {
            alphaRhombohedral: {
                name: "α-ромбоэдрический",
                density: "2.46 г/см³",
                color: "Чёрный",
                structure: "Ромбоэдрическая (12-атомная ячейка)",
                properties: "Менее стабильный, образуется при низких температурах",
                alloDiscoveryYear: "1943",
                alloDiscoverer: "Лаубенгайер и др.",
                alloFacts: "Образуется при осаждении из газовой фазы при низких температурах"
            },
            tetragonal: {
                name: "Тетрагональный",
                density: "2.36 г/см³",
                color: "Тёмно-серый",
                structure: "Тетрагональная",
                properties: "Синтезируется при высоком давлении",
                alloDiscoveryYear: "1960-е",
                alloDiscoverer: "Несколько групп",
                alloFacts: "Синтезируется при давлении >10 ГПа"
            }
        }
    },

    "C": {
        atomicNumber: "6",
        name: "Углерод",
        atomicMass: "12.011",
        period: "2",
        group: "14",
        block: "p",
        category: "Неметалл",
        electronConfig: "[He] 2s<sup>2</sup> 2p<sup>2</sup>",
        valenceStates: "IV, II",
        electronegativity: "2.55",
        density: "2.267 г/см³ (графит)",
        meltingPoint: "Сублимирует при ~3825 °C",
        boilingPoint: "~3900 °C (сублимация)",
        state: "Твёрдое",
        color: "Чёрный (графит)",
        discoveryYear: "Известен с древности",
        discoverer: "Известен с древности",
        nameOrigin: "От лат. carbo — «уголь»",
        applications: "Сталь и чугун, алмазы, графит (карандаши, смазки, электроды), углеродное волокно, активированный уголь, графен",
        facts: "Основа всей органической химии и жизни. Четвёртый по распространённости элемент во Вселенной. При атмосферном давлении не плавится, а сублимирует.",
        // Основные аллотропы (показываются сразу)
        allotropes: {
            graphite: {
                name: "Графит",
                density: "2.267 г/см³",
                meltingPoint: "Сублимирует при ~3825 °C",
                color: "Чёрный с металлическим блеском",
                structure: "Слоистая гексагональная (sp²)",
                hardness: "1–2 по шкале Мооса",
                conductivity: "Проводник (в плоскости слоёв)",
                alloDiscoveryYear: "Известен с древности",
                alloDiscoverer: "Древние цивилизации",
                alloFacts: "Название от греч. grapho (пишу). Лавуазье доказал связь с алмазом в 1772"
            },
            diamond: {
                name: "Алмаз",
                density: "3.515 г/см³",
                meltingPoint: "~3550 °C (при высоком давлении)",
                color: "Бесцветный, прозрачный",
                structure: "Кубическая тетраэдрическая (sp³)",
                hardness: "10 по шкале Мооса",
                conductivity: "Изолятор, отличный теплопроводник",
                alloDiscoveryYear: "Известен с древности",
                alloDiscoverer: "Древняя Индия (~4 век до н.э.)",
                alloFacts: "Название от греч. adamas (непобедимый). Самый твёрдый природный материал"
            },
            graphene: {
                name: "Графен",
                density: "~0.77 мг/м² (2D)",
                color: "Прозрачный (поглощает 2.3% света)",
                structure: "Двумерная гексагональная решётка (sp²)",
                hardness: "Самый прочный известный материал",
                conductivity: "Отличный проводник",
                alloDiscoveryYear: "2004",
                alloDiscoverer: "Андрей Гейм, Константин Новосёлов",
                alloFacts: "Нобелевская премия 2010. Прочнее стали в 200 раз при толщине в 1 атом."
            },
            fullerene: {
                name: "Фуллерены (C₆₀, C₇₀)",
                density: "1.65 г/см³",
                meltingPoint: "Сублимирует при ~280 °C",
                color: "Чёрный/тёмно-коричневый",
                structure: "Молекулярная (сферы и эллипсы, sp²)",
                properties: "C₆₀ — усечённый икосаэдр, C₇₀ — эллипсоид",
                alloDiscoveryYear: "1985",
                alloDiscoverer: "Крото, Смолли, Кёрл",
                alloFacts: "Нобелевская премия 1996. Назван в честь архитектора Бакминстера Фуллера"
            }
        },
        extraAllotropes: {
            nanotube: {
                name: "Углеродные нанотрубки",
                density: "1.3–1.4 г/см³",
                color: "Чёрный",
                structure: "Цилиндрическая (свёрнутый графен, sp²)",
                properties: "Прочность в 100 раз выше стали, проводник или полупроводник",
                alloDiscoveryYear: "1991",
                alloDiscoverer: "Сумио Иидзима",
                alloFacts: "Теплопроводность выше алмаза. Потенциал для космического лифта"
            },
            lonsdaleite: {
                name: "Лонсдейлит",
                density: "3.52 г/см³",
                color: "Жёлто-коричневый",
                structure: "Гексагональная (sp³)",
                hardness: "Теоретически твёрже алмаза",
                properties: "Образуется при ударах метеоритов",
                alloDiscoveryYear: "1967",
                alloDiscoverer: "Банди, Каспер",
                alloFacts: "Назван в честь кристаллографа Кэтлин Лонсдейл. Найден в метеорите Каньон Дьябло"
            },
            amorphous: {
                name: "Аморфный углерод",
                density: "1.8–2.1 г/см³",
                color: "Чёрный",
                structure: "Неупорядоченная (смесь sp² и sp³)",
                properties: "Сажа, активированный уголь, древесный уголь",
                alloDiscoveryYear: "Известен с древности",
                alloDiscoverer: "Древние цивилизации",
                alloFacts: "Древесный уголь использовался с каменного века для рисунков и выплавки металлов"
            }
        }
    },

    "N": {
        atomicNumber: "7",
        name: "Азот",
        atomicMass: "14.007",
        period: "2",
        group: "15",
        block: "p",
        category: "Неметалл",
        electronConfig: "[He] 2s<sup>2</sup> 2p<sup>3</sup>",
        valenceStates: "V, III",
        electronegativity: "3.04",
        density: "0.001251 г/см³",
        meltingPoint: "−210.00 °C",
        boilingPoint: "−195.79 °C",
        state: "Газ",
        color: "Бесцветный",
        discoveryYear: "1772",
        discoverer: "Даниэль Резерфорд",
        nameOrigin: "От греч. νίτρον (nitron — селитра) + γεννάω (рождаю)",
        applications: "Производство аммиака и удобрений, криогеника, инертная атмосфера, взрывчатые вещества, пищевая промышленность (упаковка)",
        facts: "Составляет 78% атмосферы Земли. Тройная связь N≡N — одна из самых прочных химических связей. Жидкий азот кипит при −196 °C и широко используется для охлаждения."
    },

    "O": {
        atomicNumber: "8",
        name: "Кислород",
        atomicMass: "15.999",
        period: "2",
        group: "16",
        block: "p",
        category: "Неметалл",
        electronConfig: "[He] 2s<sup>2</sup> 2p<sup>4</sup>",
        electronConfigFull: "1s<sup>2</sup> 2s<sup>2</sup> 2p<sup>4</sup>",
        electronConfigShort: "[He] 2s<sup>2</sup> 2p<sup>4</sup>",
        valenceStates: "II",
        shellDistribution: [2, 6],
        orbitals: [
            { n: 1, l: "s", electrons: 2 },
            { n: 2, l: "s", electrons: 2 },
            { n: 2, l: "p", electrons: 4 }
        ],
        electronegativity: "3.44",
        density: "0.001429 г/см³ (O₂)",
        meltingPoint: "−218.79 °C",
        boilingPoint: "−182.96 °C",
        state: "Газ",
        color: "Бесцветный (O₂), бледно-голубой (O₃)",
        discoveryYear: "1774",
        discoverer: "Карл Шееле, Джозеф Пристли; элементарность доказана Антуаном Лавуазье",
        nameOrigin: "От греч. ὀξύς (oxys — кислый) + γεννάω (рождаю) — «рождающий кислоты»",
        applications: "Дыхание и медицина, металлургия (выплавка стали), сварка и резка, ракетное топливо, очистка воды",
        facts: "Самый распространённый элемент в земной коре (~46% по массе). Необходим для дыхания большинства организмов. Озоновый слой защищает Землю от УФ-излучения.",
        allotropes: {
            dioxygen: {
                name: "Дикислород (O₂)",
                density: "0.001429 г/см³",
                meltingPoint: "−218.79 °C",
                boilingPoint: "−182.96 °C",
                color: "Бесцветный газ, бледно-голубая жидкость",
                structure: "Двухатомная молекула",
                properties: "Парамагнитен, необходим для дыхания",
                alloDiscoveryYear: "1774",
                alloDiscoverer: "Шееле, Пристли; элементарность — Лавуазье",
                alloFacts: "21% атмосферы Земли. Необходим для дыхания и горения"
            },
            ozone: {
                name: "Озон (O₃)",
                density: "0.00214 г/см³",
                meltingPoint: "−192.2 °C",
                boilingPoint: "−112 °C",
                color: "Бледно-голубой газ",
                structure: "Трёхатомная молекула (угловая)",
                properties: "Сильный окислитель, озоновый слой",
                alloDiscoveryYear: "1839",
                alloDiscoverer: "Кристиан Шёнбейн",
                alloFacts: "Название от греч. ozein (пахнуть). Озоновый слой защищает от УФ"
            }
        },
        extraAllotropes: {
            tetraoxygen: {
                name: "Тетракислород (O₄)",
                color: "Бесцветный",
                structure: "Четырёхатомная молекула",
                properties: "Метастабильная форма при высоком давлении",
                alloDiscoveryYear: "2001",
                alloDiscoverer: "Качарич и др.",
                alloFacts: "Метастабильная молекула, существует доли секунды"
            },
            redOxygen: {
                name: "Красный кислород (O₈)",
                color: "Красный",
                structure: "Октамерные кластеры",
                properties: "Фаза при экстремальном давлении (>10 ГПа)",
                alloDiscoveryYear: "1979",
                alloDiscoverer: "Группа под давлением",
                alloFacts: "Образуется при давлении >10 ГПа, красный цвет из-за изменения электронной структуры"
            }
        }
    },

    "F": {
        atomicNumber: "9",
        name: "Фтор",
        atomicMass: "18.998",
        period: "2",
        group: "17",
        block: "p",
        category: "Галоген",
        electronConfig: "[He] 2s<sup>2</sup> 2p<sup>5</sup>",
        valenceStates: "I",
        electronegativity: "3.98",
        density: "0.001696 г/см³",
        meltingPoint: "−219.67 °C",
        boilingPoint: "−188.11 °C",
        state: "Газ",
        color: "Бледно-жёлтый",
        discoveryYear: "1886 (выделен)",
        discoverer: "Анри Муассан",
        nameOrigin: "От лат. fluere — «течь» (из-за использования флюорита как флюса)",
        applications: "Фторирование воды, тефлон (ПТФЭ), фреоны (хладагенты), фторсодержащие лекарства, обогащение урана (UF₆)",
        facts: "Самый электроотрицательный элемент. Самый реактивный неметалл — реагирует почти со всеми веществами. Многие исследователи погибли или получили травмы при попытках его выделить."
    },

    "Ne": {
        atomicNumber: "10",
        name: "Неон",
        atomicMass: "20.180",
        period: "2",
        group: "18",
        block: "p",
        category: "Благородный газ",
        electronConfig: "[He] 2s<sup>2</sup> 2p<sup>6</sup>",
        valenceStates: "0",
        electronegativity: "—",
        density: "0.0009002 г/см³",
        meltingPoint: "−248.59 °C",
        boilingPoint: "−246.08 °C",
        state: "Газ",
        color: "Бесцветный (светится красно-оранжевым в разряде)",
        discoveryYear: "1898",
        discoverer: "Уильям Рамзай, Моррис Трэверс",
        nameOrigin: "От греч. νέος (neos) — «новый»",
        applications: "Неоновые вывески и лампы, гелий-неоновые лазеры, криогеника, индикаторы высокого напряжения",
        facts: "Единственный благородный газ, для которого не получено ни одного стабильного соединения. Пятый по распространённости элемент во Вселенной. Неоновые лампы были изобретены в 1910 году."
    },

    // 11 - Натрий (Sodium)
    "Na": {
        atomicNumber: 11,
        symbol: "Na",
        name: "Натрий",
        atomicMass: 22.990,
        period: 3,
        group: 1,
        block: "s",
        category: "Щелочной металл",
        electronConfig: "[Ne] 3s<sup>1</sup>",
        electronConfigFull: "1s<sup>2</sup> 2s<sup>2</sup> 2p<sup>6</sup> 3s<sup>1</sup>",
        electronConfigShort: "[Ne] 3s<sup>1</sup>",
        valenceStates: "I",
        shellDistribution: [2, 8, 1],
        orbitals: [
            { n: 1, l: "s", electrons: 2 },
            { n: 2, l: "s", electrons: 2 },
            { n: 2, l: "p", electrons: 6 },
            { n: 3, l: "s", electrons: 1 }
        ],
        electronegativity: 0.93,
        density: "0.968 г/см³",
        meltingPoint: "97.79 °C",
        boilingPoint: "882.94 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1807",
        discoverer: "Гемфри Дэви",
        nameOrigin: "От латинского natrium (сода), символ Na — от Neo-Latin natrium",
        applications: "Натриевые лампы, производство соединений натрия, теплоносители в ядерных реакторах, восстановитель в металлургии",
        facts: "Шестой по распространённости элемент в земной коре. Мягкий металл — легко режется ножом. В пламени горит характерным жёлтым цветом."
    },

    // 12 - Магний (Magnesium)
    "Mg": {
        atomicNumber: 12,
        symbol: "Mg",
        name: "Магний",
        atomicMass: 24.305,
        period: 3,
        group: 2,
        block: "s",
        category: "Щёлочноземельный металл",
        electronConfig: "[Ne] 3s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: 1.31,
        density: "1.738 г/см³",
        meltingPoint: "650 °C",
        boilingPoint: "1090 °C",
        state: "Твёрдое",
        color: "Серебристо-серый",
        discoveryYear: "1755 (обнаружен), 1808 (выделен)",
        discoverer: "Джозеф Блэк (обнаружил), Гемфри Дэви (выделил)",
        nameOrigin: "От Магнезии — района в Греции",
        applications: "Лёгкие сплавы (авиация, автомобили), пиротехника (яркое белое пламя), медицина (антациды, слабительные)",
        facts: "Восьмой по распространённости элемент в земной коре. Горит ослепительно-белым пламенем. Необходим для работы более 300 ферментов."
    },

    // 13 - Алюминий (Aluminium)
    "Al": {
        atomicNumber: 13,
        symbol: "Al",
        name: "Алюминий",
        atomicMass: 26.982,
        period: 3,
        group: 13,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Ne] 3s<sup>2</sup> 3p<sup>1</sup>",
        valenceStates: "III",
        electronegativity: 1.61,
        density: "2.70 г/см³",
        meltingPoint: "660.32 °C",
        boilingPoint: "2519 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1825",
        discoverer: "Ханс Кристиан Эрстед",
        nameOrigin: "От латинского alumen (квасцы)",
        applications: "Авиация и автомобили, упаковка (фольга, банки), строительство, электропроводка",
        facts: "Самый распространённый металл в земной коре. Плотность в три раза меньше стали. В 1854 году стоил дороже золота."
    },

    // 14 - Кремний (Silicon)
    "Si": {
        atomicNumber: 14,
        symbol: "Si",
        name: "Кремний",
        atomicMass: 28.085,
        period: 3,
        group: 14,
        block: "p",
        category: "Металлоид",
        electronConfig: "[Ne] 3s<sup>2</sup> 3p<sup>2</sup>",
        valenceStates: "IV, II",
        electronegativity: 1.90,
        density: "2.329 г/см³",
        meltingPoint: "1414 °C",
        boilingPoint: "3265 °C",
        state: "Твёрдое",
        color: "Серый с голубоватым отливом",
        discoveryYear: "1824",
        discoverer: "Йёнс Якоб Берцелиус",
        nameOrigin: "От латинского silex (кремень)",
        applications: "Полупроводниковая электроника, солнечные батареи, силиконы, стекло и керамика",
        facts: "Второй по распространённости элемент в земной коре (~28%). Основа современной электроники («Кремниевая долина»).",
        allotropes: {
            crystalline: {
                name: "Кристаллический",
                density: "2.329 г/см³",
                color: "Серый с металлическим блеском",
                structure: "Алмазоподобная кубическая решётка",
                properties: "Полупроводник, основа микроэлектроники",
                alloDiscoveryYear: "1854",
                alloDiscoverer: "Анри Сент-Клер Девиль",
                alloFacts: "Первый кристаллический кремний. Основа всей современной электроники"
            },
            amorphous: {
                name: "Аморфный",
                density: "1.8–2.3 г/см³",
                color: "Коричневый/тёмно-серый",
                structure: "Неупорядоченная тетраэдрическая сетка",
                properties: "Тонкоплёночные солнечные батареи, ЖК-дисплеи",
                alloDiscoveryYear: "1824",
                alloDiscoverer: "Йёнс Якоб Берцелиус",
                alloFacts: "Первая полученная форма кремния — коричневый порошок"
            }
        },
        extraAllotropes: {
            siIII: {
                name: "Si-III (BC8)",
                density: "2.55 г/см³",
                color: "Серый",
                structure: "Кубическая (BC8)",
                properties: "Металлическая фаза, образуется при давлении >11 ГПа",
                alloDiscoveryYear: "1963",
                alloDiscoverer: "Джеймисон и др.",
                alloFacts: "Сверхпроводник при температуре ниже 7 K"
            },
            siXII: {
                name: "Si-XII (R8)",
                density: "2.53 г/см³",
                color: "Серый",
                structure: "Ромбоэдрическая (R8)",
                properties: "Полуметаллическая фаза при декомпрессии",
                alloDiscoveryYear: "1994",
                alloDiscoverer: "Кавамура и др.",
                alloFacts: "Образуется при медленном снятии давления с Si-II"
            }
        }
    },

    // 15 - Фосфор (Phosphorus)
    "P": {
        atomicNumber: 15,
        symbol: "P",
        name: "Фосфор",
        atomicMass: 30.974,
        period: 3,
        group: 15,
        block: "p",
        category: "Неметалл",
        electronConfig: "[Ne] 3s<sup>2</sup> 3p<sup>3</sup>",
        valenceStates: "V, III",
        electronegativity: 2.19,
        density: "1.823 г/см³",
        meltingPoint: "44.15 °C",
        boilingPoint: "280.5 °C",
        state: "Твёрдое",
        color: "Белый/красный/чёрный",
        discoveryYear: "1669",
        discoverer: "Хенниг Бранд",
        nameOrigin: "От греческого Φωσφόρος (светоносец)",
        applications: "Удобрения (фосфаты), спички (красный фосфор), моющие средства, пестициды",
        facts: "Первый элемент, открытый научным путём. Получен Брандом при перегонке мочи. Необходим для ДНК, РНК, АТФ.",
        allotropes: {
            white: {
                name: "Белый фосфор",
                density: "1.823 г/см³",
                meltingPoint: "44.15 °C",
                boilingPoint: "280.5 °C",
                color: "Восковидный белый/жёлтый",
                structure: "Молекулярная (тетраэдры P₄)",
                properties: "Пирофорный, токсичный, светится в темноте",
                alloDiscoveryYear: "1669",
                alloDiscoverer: "Хенниг Бранд",
                alloFacts: "Первый элемент, открытый научным путём. Получен из мочи. Светится в темноте"

            },
            red: {
                name: "Красный фосфор",
                density: "2.27 г/см³",
                meltingPoint: "~590 °C (возгонка)",
                color: "Тёмно-красный",
                structure: "Полимерная аморфная",
                properties: "Стабильный, нетоксичный, используется в спичках",
                alloDiscoveryYear: "1845",
                alloDiscoverer: "Антон фон Шрёттер",
                alloFacts: "Безопасная замена белого фосфора в спичках"
            },
            black: {
                name: "Чёрный фосфор",
                density: "2.69 г/см³",
                color: "Чёрный",
                structure: "Слоистая орторомбическая",
                properties: "Наиболее стабильный, полупроводник (аналог графена)",
                alloDiscoveryYear: "1914",
                alloDiscoverer: "Перси Бриджмен",
                alloFacts: "Нобелевка Бриджмену (1946) за физику высоких давлений. Называют «фосфореном» по аналогии с графеном"

            }
        },
        extraAllotropes: {
            violet: {
                name: "Фиолетовый (Гиттторфа)",
                density: "2.36 г/см³",
                meltingPoint: "~620 °C",
                color: "Фиолетовый/пурпурный",
                structure: "Моноклинная кристаллическая",
                properties: "Игольчатые кристаллы, открыт в 1865",
                alloDiscoveryYear: "1865",
                alloDiscoverer: "Иоганн Вильгельм Гитторф",
                alloFacts: "Иногда считают кристаллической формой красного фосфора"
            },
            diphosphorus: {
                name: "Дифосфор (P₂)",
                color: "Бесцветный газ",
                structure: "Двухатомная молекула (P≡P)",
                properties: "Существует при высокой температуре (>1200°C)",
                alloDiscoveryYear: "~1900",
                alloDiscoverer: "Спектроскопические исследования",
                alloFacts: "Тройная связь P≡P, аналог N₂, но менее стабилен"
            }
        }
    },

    // 16 - Сера (Sulfur)
    "S": {
        atomicNumber: 16,
        symbol: "S",
        name: "Сера",
        atomicMass: 32.06,
        period: 3,
        group: 16,
        block: "p",
        category: "Неметалл",
        electronConfig: "[Ne] 3s<sup>2</sup> 3p<sup>4</sup>",
        valenceStates: "VI, IV, II",
        electronegativity: 2.58,
        density: "2.067 г/см³",
        meltingPoint: "115.21 °C",
        boilingPoint: "444.6 °C",
        state: "Твёрдое",
        color: "Ярко-жёлтый",
        discoveryYear: "Известна с древности",
        discoverer: "Известна с древности (Лавуазье, 1777)",
        nameOrigin: "От санскритского sulvere и латинского sulphurium",
        applications: "Производство серной кислоты, вулканизация резины, удобрения, фунгициды, порох",
        facts: "Известна как «горючий камень» с библейских времён. Десятый по распространённости элемент во Вселенной. Горит синим пламенем.",
        allotropes: {
            orthorhombic: {
                name: "α-сера (ромбическая)",
                density: "2.07 г/см³",
                meltingPoint: "112.8 °C",
                color: "Жёлтые кристаллы",
                structure: "Кольца S₈",
                properties: "Стабильна ниже 95.6°C",
                alloDiscoveryYear: "Известна с древности",
                alloDiscoverer: "Древние цивилизации",
                alloFacts: "Самая стабильная форма при комнатной температуре. «Горящий камень» библейских текстов"
            },
            monoclinic: {
                name: "β-сера (моноклинная)",
                density: "1.96 г/см³",
                meltingPoint: "119.6 °C",
                color: "Игольчатые жёлтые кристаллы",
                structure: "Кольца S₈",
                properties: "Стабильна от 95.6°C до плавления",
                alloDiscoveryYear: "1823",
                alloDiscoverer: "Эйльхард Мичерлих",
                alloFacts: "Открытие полиморфизма — одно вещество, разные кристаллические формы"
            }
        },
        extraAllotropes: {
            gamma: {
                name: "γ-сера",
                density: "2.19 г/см³",
                color: "Жёлтый",
                structure: "Кольца S₈ (моноклинная)",
                properties: "Пластичная модификация",
                alloDiscoveryYear: "1891",
                alloDiscoverer: "Энгель",
                alloFacts: "Также называется «перламутровая сера» или сера Энгеля"
            },
            plastic: {
                name: "Пластическая сера",
                density: "~2.0 г/см³",
                color: "Жёлто-коричневый",
                structure: "Полимерные цепи",
                properties: "Аморфная, резиноподобная, образуется при быстром охлаждении",
                alloDiscoveryYear: "XIX век",
                alloDiscoverer: "Различные исследователи",
                alloFacts: "Образуется при выливании расплавленной серы в холодную воду"
            },
            diatomic: {
                name: "Дисера (S₂)",
                color: "Синий газ",
                structure: "Двухатомная молекула",
                properties: "Газообразная форма при T > 700°C (аналог O₂)",
                alloDiscoveryYear: "1926",
                alloDiscoverer: "Спектроскопические исследования",
                alloFacts: "Придаёт синий цвет пламени горящей серы"
            },
            rings: {
                name: "Кольцевые формы (S₆, S₇, S₁₂)",
                color: "Жёлтый",
                structure: "Кольца различного размера",
                properties: "Присутствуют в расплаве и растворах",
                alloDiscoveryYear: "1960–1980-е",
                alloDiscoverer: "Различные группы",
                alloFacts: "S₆ — оранжевый, S₇ — жёлтый, S₁₂ — бледно-жёлтый"
            }
        }
    },

    // 17 - Хлор (Chlorine)
    "Cl": {
        atomicNumber: 17,
        symbol: "Cl",
        name: "Хлор",
        atomicMass: 35.45,
        period: 3,
        group: 17,
        block: "p",
        category: "Галоген",
        electronConfig: "[Ne] 3s<sup>2</sup> 3p<sup>5</sup>",
        valenceStates: "VII, V, III, I",
        electronegativity: 3.16,
        density: "0.003214 г/см³",
        meltingPoint: "−101.5 °C",
        boilingPoint: "−34.04 °C",
        state: "Газ",
        color: "Жёлто-зелёный",
        discoveryYear: "1774",
        discoverer: "Карл Вильгельм Шееле",
        nameOrigin: "От греческого χλωρός — бледно-зелёный",
        applications: "Дезинфекция воды, производство ПВХ, отбеливатели, соляная кислота",
        facts: "Третья по величине электроотрицательность. Высшее сродство к электрону. Использовался как боевой газ в WWI."
    },

    // 18 - Аргон (Argon)
    "Ar": {
        atomicNumber: 18,
        symbol: "Ar",
        name: "Аргон",
        atomicMass: 39.948,
        period: 3,
        group: 18,
        block: "p",
        category: "Благородный газ",
        electronConfig: "[Ne] 3s<sup>2</sup> 3p<sup>6</sup>",
        valenceStates: "0",
        electronegativity: "—",
        density: "0.001784 г/см³",
        meltingPoint: "−189.34 °C",
        boilingPoint: "−185.85 °C",
        state: "Газ",
        color: "Бесцветный",
        discoveryYear: "1894",
        discoverer: "Лорд Рэлей и Уильям Рамзай",
        nameOrigin: "От греческого ἀργός — ленивый, неактивный",
        applications: "Защитный газ при сварке, лампы накаливания, аргоновые лазеры, консервация документов",
        facts: "Третий по распространённости газ в атмосфере (0.934%). Самый распространённый благородный газ на Земле."
    },

    // 19 - Калий (Potassium)
    "K": {
        atomicNumber: 19,
        symbol: "K",
        name: "Калий",
        atomicMass: 39.098,
        period: 4,
        group: 1,
        block: "s",
        category: "Щелочной металл",
        electronConfig: "[Ar] 4s<sup>1</sup>",
        valenceStates: "I",
        electronegativity: 0.82,
        density: "0.862 г/см³",
        meltingPoint: "63.5 °C",
        boilingPoint: "759 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1807",
        discoverer: "Гемфри Дэви",
        nameOrigin: "От слова potash; символ K — от латинского kalium",
        applications: "Удобрения (95% производства), стекло, мыловарение, пиротехника",
        facts: "Второй по лёгкости металл. Бурно реагирует с водой. Горит лиловым пламенем. Жизненно важен для клеток."
    },

    // 20 - Кальций (Calcium)
    "Ca": {
        atomicNumber: 20,
        symbol: "Ca",
        name: "Кальций",
        atomicMass: 40.078,
        period: 4,
        group: 2,
        block: "s",
        category: "Щёлочноземельный металл",
        electronConfig: "[Ar] 4s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: 1.00,
        density: "1.55 г/см³",
        meltingPoint: "842 °C",
        boilingPoint: "1484 °C",
        state: "Твёрдое",
        color: "Серебристо-жёлтый",
        discoveryYear: "1808",
        discoverer: "Гемфри Дэви",
        nameOrigin: "От латинского calx (известь)",
        applications: "Цемент и известь, металлургия, аккумуляторы, пищевые добавки, медицина",
        facts: "Пятый по распространённости элемент в земной коре. Самый распространённый металл в организме человека. Необходим для костей и зубов."
    },
    // 21 - Скандий (Scandium)
    "Sc": {
        atomicNumber: 21,
        symbol: "Sc",
        name: "Скандий",
        atomicMass: 44.956,
        period: 4,
        group: 3,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>1</sup> 4s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.36,
        density: "3.0 г/см³",
        meltingPoint: "1541 °C",
        boilingPoint: "2836 °C",
        state: "Твёрдое",
        color: "Серебристый с жёлтым отливом",
        discoveryYear: "1879",
        discoverer: "Ларс Нильсон",
        nameOrigin: "От лат. Scandia — Скандинавия, в честь родины первооткрывателя",
        applications: "Легирование алюминиевых сплавов (авиация, ракетостроение), металлогалогенные лампы высокой интенсивности, спортивное оборудование (велосипеды, бейсбольные биты)",
        facts: "Предсказан Менделеевым в 1870 году как «экабор». Моноизотопный элемент (⁴⁵Sc). Один из самых лёгких переходных металлов. Рассеянный элемент — входит в состав более 100 минералов, но собственных месторождений не образует. Добавка всего 0,1–0,5% скандия резко повышает прочность алюминиевых сплавов."
    },

    // 22 - Титан (Titanium)
    "Ti": {
        atomicNumber: 22,
        symbol: "Ti",
        name: "Титан",
        atomicMass: 47.867,
        period: 4,
        group: 4,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>2</sup> 4s<sup>2</sup>",
        valenceStates: "IV, III",
        electronegativity: 1.54,
        density: "4.5 г/см³",
        meltingPoint: "1668 °C",
        boilingPoint: "3287 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1791",
        discoverer: "Уильям Грегор (обнаружил), Мартин Клапрот (назвал, 1795)",
        nameOrigin: "В честь титанов — могучих детей богини Геи из древнегреческой мифологии",
        applications: "Авиа- и ракетостроение, судостроение, медицинские импланты и протезы, химическое оборудование, спортинвентарь, диоксид титана в красках и косметике",
        facts: "Четвёртый по распространённости конструкционный металл в земной коре (0,57%). Прочен как сталь, но вдвое легче. Биосовместим — срастается с костной тканью. Устойчив к коррозии благодаря прочной оксидной плёнке. Две кристаллические модификации: α-Ti (до 883°C) и β-Ti.",
        allotropes: {
            alpha: {
                name: "α-титан",
                density: "4.506 г/см³",
                structure: "Гексагональная плотноупакованная (ГПУ)",
                properties: "Стабилен до 882°C, анизотропный",
                alloFacts: "Основная форма при комнатной температуре."
            },
            beta: {
                name: "β-титан",
                density: "4.4 г/см³",
                structure: "Объёмно-центрированная кубическая (ОЦК)",
                properties: "Пластичный, высокопрочный",
                alloFacts: "Стабилен выше 882°C. Легирование ванадием стабилизирует эту фазу при комнатной температуре."
            }
        },
        extraAllotropes: {
            omega: {
                name: "ω-титан",
                structure: "Гексагональная",
                properties: "Метастабильная фаза высокого давления",
                alloFacts: "Образуется при ударном сжатии или быстром охлаждении."
            }
        }
    },

    // 23 - Ванадий (Vanadium)
    "V": {
        atomicNumber: 23,
        symbol: "V",
        name: "Ванадий",
        atomicMass: 50.942,
        period: 4,
        group: 5,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>3</sup> 4s<sup>2</sup>",
        valenceStates: "V, IV, III, II",
        electronegativity: 1.63,
        density: "6.11 г/см³",
        meltingPoint: "1910 °C",
        boilingPoint: "3407 °C",
        state: "Твёрдое",
        color: "Серебристо-серый",
        discoveryYear: "1801 (Дель Рио), 1830 (Сефстрём)",
        discoverer: "Андрес Мануэль Дель Рио; повторно — Нильс Сефстрём",
        nameOrigin: "В честь скандинавской богини красоты Ванадис (Фрейи) — соединения ванадия имеют красивую разноцветную окраску",
        applications: "Легирование сталей (повышает прочность и упругость), быстрорежущие стали, пружины, катализаторы в химической промышленности, ванадиевые редокс-батареи",
        facts: "Дель Рио открыл элемент в 1801 году и назвал «эритроний», но не отстоял открытие. Рассеянный элемент — в свободном виде не встречается. На воздухе покрывается красивой разноцветной оксидной плёнкой. Соединения токсичны в высоких концентрациях."
    },

    // 24 - Хром (Chromium)
    "Cr": {
        atomicNumber: 24,
        symbol: "Cr",
        name: "Хром",
        atomicMass: 51.996,
        period: 4,
        group: 6,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>5</sup> 4s<sup>1</sup>",
        valenceStates: "VI, III, II",
        electronegativity: 1.66,
        density: "7.19 г/см³",
        meltingPoint: "1907 °C",
        boilingPoint: "2671 °C",
        state: "Твёрдое",
        color: "Голубовато-белый",
        discoveryYear: "1797",
        discoverer: "Луи-Николя Воклен",
        nameOrigin: "От греч. χρῶμα (хрома) — цвет, краска, из-за разнообразия окраски соединений хрома",
        applications: "Нержавеющие и легированные стали, хромирование для защиты от коррозии, пигменты и красители, дубление кожи, катализаторы",
        facts: "Один из самых твёрдых чистых металлов — 9 по шкале Мооса. Минерал крокоит (хромат свинца) найден близ Екатеринбурга в 1766 году. Соединения Cr(VI) канцерогенны. Антиферромагнетик. Биогенный элемент — участвует в метаболизме глюкозы."
    },

    // 25 - Марганец (Manganese)
    "Mn": {
        atomicNumber: 25,
        symbol: "Mn",
        name: "Марганец",
        atomicMass: 54.938,
        period: 4,
        group: 7,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>5</sup> 4s<sup>2</sup>",
        valenceStates: "VII, VI, IV, II, III",
        electronegativity: 1.55,
        density: "7.3 г/см³",
        meltingPoint: "1246 °C",
        boilingPoint: "2061 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1774",
        discoverer: "Юхан Готлиб Ган",
        nameOrigin: "От лат. названия минерала lapis manganensis (чёрная магнезия), известного с древности",
        applications: "Раскисление и легирование сталей (более 90% производства), сталь Гадфильда (износостойкая), ферромарганец, батарейки (диоксид марганца), керамика",
        facts: "Моноизотопный элемент (⁵⁵Mn). Минерал пиролюзит известен с древности как «чёрная магнезия». Четыре полиморфные модификации. Сталь Гадфильда (12–13% Mn) используется для землеройной техники и брони. Биогенный элемент — важен для фотосинтеза и работы ферментов.",
        allotropes: {
            alpha: {
                name: "α-марганец",
                density: "7.21 г/см³",
                structure: "Кубическая (сложная ячейка, 58 атомов)",
                properties: "Очень твёрдый и хрупкий, антиферромагнетик",
                alloFacts: "Стабилен до 700°C. Из-за сложности решётки металл хрупок как стекло."
            }
        },
        extraAllotropes: {
            beta: {
                name: "β-марганец",
                structure: "Кубическая (20 атомов)",
                properties: "Существует при 700–1079°C",
                alloFacts: "Пластичнее α-формы, но закалить её невозможно (распадается)."
            },
            gamma: {
                name: "γ-марганец",
                structure: "ГЦК (искажённая)",
                properties: "Существует при 1079–1143°C",
                alloFacts: "Гибкая и мягкая форма, аналог аустенита."
            },
            delta: {
                name: "δ-марганец",
                structure: "ОЦК",
                properties: "Высокотемпературная (1143–1246°C)",
                alloFacts: "Аналог δ-железа."
            }
        }
    },

    // 26 - Железо (Iron)
    "Fe": {
        atomicNumber: 26,
        symbol: "Fe",
        name: "Железо",
        atomicMass: 55.845,
        period: 4,
        group: 8,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>6</sup> 4s<sup>2</sup>",
        electronConfigFull: "1s<sup>2</sup> 2s<sup>2</sup> 2p<sup>6</sup> 3s<sup>2</sup> 3p<sup>6</sup> 3d<sup>6</sup> 4s<sup>2</sup>",
        electronConfigShort: "[Ar] 3d<sup>6</sup> 4s<sup>2</sup>",
        valenceStates: "II, III",
        shellDistribution: [2, 8, 14, 2],
        orbitals: [
            { n: 1, l: "s", electrons: 2 },
            { n: 2, l: "s", electrons: 2 },
            { n: 2, l: "p", electrons: 6 },
            { n: 3, l: "s", electrons: 2 },
            { n: 3, l: "p", electrons: 6 },
            { n: 3, l: "d", electrons: 6 },
            { n: 4, l: "s", electrons: 2 }
        ],
        electronegativity: 1.83,
        density: "7.87 г/см³",
        meltingPoint: "1538 °C",
        boilingPoint: "2862 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "Известно с древности",
        discoverer: "Известно с древности (железный век)",
        nameOrigin: "От лат. Ferrum, возможно от fars — быть твёрдым",
        applications: "Основа чёрной металлургии — чугун и сталь, строительные конструкции, машиностроение, транспорт, электротехника (трансформаторы, электродвигатели), магниты",
        facts: "Один из самых распространённых элементов во Вселенной и на Земле (4-е место в земной коре). Ферромагнетик. Изотоп ⁵⁶Fe — конечный продукт термоядерного синтеза в звёздах (пик железа). Быстро корродирует во влажной среде. Биогенный элемент — входит в состав гемоглобина и миоглобина.",
        allotropes: {
            alpha: {
                name: "α-железо (Феррит)",
                density: "7.87 г/см³",
                structure: "Объёмно-центрированная кубическая (ОЦК)",
                properties: "Ферромагнетик до 770°C, мягкий и пластичный",
                alloFacts: "Основная форма железа при комнатной температуре. Растворяет мало углерода."
            },
            gamma: {
                name: "γ-железо (Аустенит)",
                density: "8.14 г/см³",
                structure: "Гранецентрированная кубическая (ГЦК)",
                properties: "Парамагнетик, высокая пластичность",
                alloFacts: "Существует выше 912°C. Растворяет углерод, основа нержавеющих сталей."
            }
        },
        extraAllotropes: {
            delta: {
                name: "δ-железо",
                structure: "Объёмно-центрированная кубическая (ОЦК)",
                properties: "Высокотемпературная форма (1394–1538°C)",
                alloFacts: "Аналогично α-железу, но существует при высоких температурах."
            },
            epsilon: {
                name: "ε-железо",
                structure: "Гексагональная плотноупакованная (ГПУ)",
                properties: "Образуется при давлении >10 ГПа",
                alloFacts: "Возможно, составляет ядро Земли."
            }
        }
    },

    // 27 - Кобальт (Cobalt)
    "Co": {
        atomicNumber: 27,
        symbol: "Co",
        name: "Кобальт",
        atomicMass: 58.933,
        period: 4,
        group: 9,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>7</sup> 4s<sup>2</sup>",
        valenceStates: "II, III",
        electronegativity: 1.88,
        density: "8.9 г/см³",
        meltingPoint: "1495 °C",
        boilingPoint: "2927 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с розоватым отливом",
        discoveryYear: "1735",
        discoverer: "Георг Брандт",
        nameOrigin: "От нем. Kobold — домовой, гном. Горняки называли руду именем злого духа, так как при обжиге выделялся ядовитый оксид мышьяка",
        applications: "Жаропрочные сплавы (лопатки турбин), легирование сталей, магнитные сплавы, литий-ионные аккумуляторы, синие краски и пигменты, катализаторы",
        facts: "Ферромагнетик с точкой Кюри 1121°C. Единственный стабильный изотоп — ⁵⁹Co. Соединения кобальта окрашивают стекло в синий цвет — этим пользовались ещё в Древнем Египте и Вавилоне. Входит в состав витамина B₁₂ (кобаламин). Радиоизотоп ⁶⁰Co — источник γ-излучения для радиотерапии и стерилизации."
    },

    // 28 - Никель (Nickel)
    "Ni": {
        atomicNumber: 28,
        symbol: "Ni",
        name: "Никель",
        atomicMass: 58.693,
        period: 4,
        group: 10,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>8</sup> 4s<sup>2</sup>",
        valenceStates: "II, III",
        electronegativity: 1.91,
        density: "8.908 г/см³",
        meltingPoint: "1455 °C",
        boilingPoint: "2913 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1751",
        discoverer: "Аксель Кронстедт",
        nameOrigin: "От нем. Kupfernickel — «медный дьявол». Руда походила на медную, но медь из неё получить не удавалось. Nickel — имя горного духа-озорника",
        applications: "Легирование нержавеющих сталей, никелирование, аккумуляторы (Ni-Cd, Ni-MH), монеты, катализаторы гидрогенизации, суперсплавы для турбин",
        facts: "Ферромагнетик с точкой Кюри 358°C. Химически малоактивен благодаря защитной оксидной плёнке. Чистый металл получен Рихтером в 1804 году после 32 перекристаллизаций. Образует очень ядовитый карбонил Ni(CO)₄. Никелевые сплавы были известны в Китае более 2000 лет назад."
    },

    // 29 - Медь (Copper)
    "Cu": {
        atomicNumber: 29,
        symbol: "Cu",
        name: "Медь",
        atomicMass: 63.546,
        period: 4,
        group: 11,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>1</sup>",
        electronConfigFull: "1s<sup>2</sup> 2s<sup>2</sup> 2p<sup>6</sup> 3s<sup>2</sup> 3p<sup>6</sup> 3d<sup>10</sup> 4s<sup>1</sup>",
        electronConfigShort: "[Ar] 3d<sup>10</sup> 4s<sup>1</sup>",
        valenceStates: "I, II",
        shellDistribution: [2, 8, 18, 1],
        orbitals: [
            { n: 1, l: "s", electrons: 2 },
            { n: 2, l: "s", electrons: 2 },
            { n: 2, l: "p", electrons: 6 },
            { n: 3, l: "s", electrons: 2 },
            { n: 3, l: "p", electrons: 6 },
            { n: 3, l: "d", electrons: 10 },
            { n: 4, l: "s", electrons: 1 }
        ],
        electronegativity: 1.90,
        density: "8.96 г/см³",
        meltingPoint: "1083 °C",
        boilingPoint: "2567 °C",
        state: "Твёрдое",
        color: "Золотисто-розовый",
        discoveryYear: "Известна с древности (9 тыс. до н.э.)",
        discoverer: "Известна с древности",
        nameOrigin: "От лат. Cuprum — по названию острова Кипр, где в древности добывали медь",
        applications: "Электропроводка и кабели, трубы для водоснабжения, сплавы (латунь, бронза, мельхиор), монеты, кровля, теплообменники",
        facts: "Один из первых металлов, освоенных человеком. Дал название эпохам — медный век и бронзовый век. Вторая после серебра электропроводность и теплопроводность. На воздухе покрывается зелёной патиной (карбонат меди). Биогенный элемент — входит в состав гемоцианина и многих ферментов."
    },

    // 30 - Цинк (Zinc)
    "Zn": {
        atomicNumber: 30,
        symbol: "Zn",
        name: "Цинк",
        atomicMass: 65.38,
        period: 4,
        group: 12,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: 1.65,
        density: "7.14 г/см³",
        meltingPoint: "419.5 °C",
        boilingPoint: "907 °C",
        state: "Твёрдое",
        color: "Голубовато-белый",
        discoveryYear: "XIII век (Индия), 1746 (Европа)",
        discoverer: "Известен в Индии с XIII в.; в Европе выделен Андреасом Маргграфом",
        nameOrigin: "Вероятно от нем. Zinke — зубец, острие — по форме кристаллов",
        applications: "Оцинкование стали, сплавы (латунь), батарейки и аккумуляторы, цинковые белила, лекарства и БАДы, кровельные материалы",
        facts: "Сплав с медью — латунь — известен с III тысячелетия до н.э. Амфотерный металл — реагирует и с кислотами, и со щелочами. При комнатной температуре хрупок, при 100–150°C становится пластичным. Горит голубовато-зелёным пламенем. Биогенный элемент — входит в состав более 300 ферментов."
    },

    // 21-30 пропущены (переходные металлы 4 периода - Sc-Zn)
    // Можно добавить позже

    // 31 - Галлий (Gallium)
    "Ga": {
        atomicNumber: 31,
        symbol: "Ga",
        name: "Галлий",
        atomicMass: 69.723,
        period: 4,
        group: 13,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>2</sup> 4p<sup>1</sup>",
        valenceStates: "III",
        electronegativity: 1.81,
        density: "5.91 г/см³",
        meltingPoint: "29.76 °C",
        boilingPoint: "2204 °C",
        state: "Твёрдое (плавится в руке)",
        color: "Серебристо-белый с голубоватым оттенком",
        discoveryYear: "1875",
        discoverer: "Поль Эмиль Лекок де Буабодран",
        nameOrigin: "От лат. Gallia (Франция) и gallus (петух — намёк на фамилию открывателя)",
        applications: "Полупроводники (GaAs), светодиоды, лазеры, термометры, солнечные батареи",
        facts: "Плавится от тепла руки (29.76°C). Был предсказан Менделеевым как «эка-алюминий». Смачивает стекло и кожу. Расширяется при затвердевании."
    },

    // 32 - Германий (Germanium)
    "Ge": {
        atomicNumber: 32,
        symbol: "Ge",
        name: "Германий",
        atomicMass: 72.630,
        period: 4,
        group: 14,
        block: "p",
        category: "Металлоид",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>2</sup> 4p<sup>2</sup>",
        valenceStates: "IV, II",
        electronegativity: 2.01,
        density: "5.323 г/см³",
        meltingPoint: "938.25 °C",
        boilingPoint: "2833 °C",
        state: "Твёрдое",
        color: "Серовато-белый",
        discoveryYear: "1886",
        discoverer: "Клеменс Винклер",
        nameOrigin: "От лат. Germania (Германия)",
        applications: "Инфракрасная оптика, волоконная оптика, полупроводники, детекторы излучения, катализаторы",
        facts: "Предсказан Менделеевым как «эка-кремний». Первый транзистор (1947) был германиевым. Прозрачен для инфракрасного излучения."
    },

    // 33 - Мышьяк (Arsenic)
    "As": {
        atomicNumber: 33,
        symbol: "As",
        name: "Мышьяк",
        atomicMass: 74.922,
        period: 4,
        group: 15,
        block: "p",
        category: "Металлоид",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>2</sup> 4p<sup>3</sup>",
        valenceStates: "V, III",
        electronegativity: 2.18,
        density: "5.727 г/см³ (серый)",
        meltingPoint: "Сублимирует при 614 °C",
        boilingPoint: "614 °C (сублимация)",
        state: "Твёрдое",
        color: "Серый металлический / жёлтый / чёрный",
        discoveryYear: "~1250",
        discoverer: "Альберт Великий",
        nameOrigin: "От греч. arsenikon (жёлтый пигмент) через перс. zarnikh",
        applications: "Полупроводники (GaAs), пестициды, консервация древесины, сплавы свинца",
        facts: "Известен как «король ядов» — использовался для отравлений. Имеет характерный чесночный запах при нагревании. Наполеон, возможно, был отравлен мышьяком.",
        allotropes: {
            grey: {
                name: "Серый (металлический)",
                density: "5.727 г/см³",
                color: "Серый с металлическим блеском",
                structure: "Ромбоэдрическая слоистая",
                properties: "Наиболее стабильная форма, полупроводник",
                alloFacts: "Основная форма, хрупкий полуметалл"
            },
            yellow: {
                name: "Жёлтый",
                density: "1.97 г/см³",
                color: "Жёлтый",
                structure: "Молекулярная (As₄)",
                properties: "Мягкий, восковидный, нестабильный",
                alloFacts: "Аналог белого фосфора, быстро переходит в серый"
            }
        },
        extraAllotropes: {
            black: {
                name: "Чёрный",
                density: "4.7 г/см³",
                color: "Чёрный",
                structure: "Аморфная",
                properties: "Образуется при быстром охлаждении паров",
                alloFacts: "Стекловидная форма, похожа на чёрный фосфор"
            }
        }
    },

    // 34 - Селен (Selenium)
    "Se": {
        atomicNumber: 34,
        symbol: "Se",
        name: "Селен",
        atomicMass: 78.971,
        period: 4,
        group: 16,
        block: "p",
        category: "Неметалл",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>2</sup> 4p<sup>4</sup>",
        valenceStates: "VI, IV, II",
        electronegativity: 2.55,
        density: "4.81 г/см³ (серый)",
        meltingPoint: "221 °C",
        boilingPoint: "685 °C",
        state: "Твёрдое",
        color: "Серый / красный / чёрный",
        discoveryYear: "1817",
        discoverer: "Йёнс Якоб Берцелиус",
        nameOrigin: "От греч. σελήνη (selene — Луна)",
        applications: "Фотоэлементы, ксерография, стекло (обесцвечивание/окрашивание), шампуни от перхоти, пищевые добавки",
        facts: "Необходимый микроэлемент для человека. Проводимость увеличивается на свету (фотопроводимость). Открыт как примесь в серной кислоте.",
        allotropes: {
            grey: {
                name: "Серый (тригональный)",
                density: "4.81 г/см³",
                color: "Серый с металлическим блеском",
                structure: "Спиральные цепи Se∞",
                properties: "Наиболее стабильная форма, полупроводник с фотопроводимостью",
                alloFacts: "Единственная форма с фотопроводимостью — основа ксерографии"
            },
            red: {
                name: "Красный",
                density: "4.39 г/см³",
                color: "Красный",
                structure: "Кольца Se₈",
                properties: "Несколько кристаллических модификаций (α, β, γ)",
                alloFacts: "Аналог серы, три моноклинные формы"
            }
        },
        extraAllotropes: {
            black: {
                name: "Чёрный (аморфный)",
                density: "4.28 г/см³",
                color: "Чёрный/тёмно-красный",
                structure: "Аморфная (кольца и цепи)",
                properties: "Стекловидная форма",
                alloFacts: "Образуется при быстром охлаждении расплава"
            }
        }
    },

    // 35 - Бром (Bromine)
    "Br": {
        atomicNumber: 35,
        symbol: "Br",
        name: "Бром",
        atomicMass: 79.904,
        period: 4,
        group: 17,
        block: "p",
        category: "Галоген",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>2</sup> 4p<sup>5</sup>",
        valenceStates: "VII, V, III, I",
        electronegativity: 2.96,
        density: "3.1028 г/см³",
        meltingPoint: "−7.2 °C",
        boilingPoint: "58.8 °C",
        state: "Жидкость",
        color: "Красно-коричневый",
        discoveryYear: "1826",
        discoverer: "Антуан Жером Балар",
        nameOrigin: "От греч. βρῶμος (bromos — зловоние)",
        applications: "Антипирены (замедлители горения), пестициды, фотография, лекарства, красители",
        facts: "Один из двух жидких элементов при комнатной температуре (второй — ртуть). Пары очень токсичны и едки. Название отражает его резкий неприятный запах."
    },

    // 36 - Криптон (Krypton)
    "Kr": {
        atomicNumber: 36,
        symbol: "Kr",
        name: "Криптон",
        atomicMass: 83.798,
        period: 4,
        group: 18,
        block: "p",
        category: "Благородный газ",
        electronConfig: "[Ar] 3d<sup>10</sup> 4s<sup>2</sup> 4p<sup>6</sup>",
        valenceStates: "0",
        electronegativity: 3.00,
        density: "0.003749 г/см³",
        meltingPoint: "−157.37 °C",
        boilingPoint: "−153.42 °C",
        state: "Газ",
        color: "Бесцветный",
        discoveryYear: "1898",
        discoverer: "Уильям Рамзай, Моррис Трэверс",
        nameOrigin: "От греч. κρυπτός (kryptos — скрытый)",
        applications: "Лампы (вспышки, проекторы), лазеры, изоляция окон, эталон длины (до 1983)",
        facts: "Планета Криптон в комиксах о Супермене названа в честь этого элемента. Изотоп Kr-86 использовался для определения метра с 1960 по 1983 год."
    },

    // 37 - Рубидий (Rubidium)
    "Rb": {
        atomicNumber: 37,
        symbol: "Rb",
        name: "Рубидий",
        atomicMass: 85.468,
        period: 5,
        group: 1,
        block: "s",
        category: "Щелочной металл",
        electronConfig: "[Kr] 5s<sup>1</sup>",
        valenceStates: "I",
        electronegativity: 0.82,
        density: "1.532 г/см³",
        meltingPoint: "39.30 °C",
        boilingPoint: "688 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1861",
        discoverer: "Роберт Бунзен, Густав Кирхгоф",
        nameOrigin: "От лат. rubidus (тёмно-красный) — по цвету спектральных линий",
        applications: "Атомные часы, фотоэлементы, специальное стекло, медицина (исследования)",
        facts: "Один из первых элементов, открытых спектроскопически. Плавится от тепла тела в жаркий день. Самовоспламеняется на воздухе."
    },

    // 38 - Стронций (Strontium)
    "Sr": {
        atomicNumber: 38,
        symbol: "Sr",
        name: "Стронций",
        atomicMass: 87.62,
        period: 5,
        group: 2,
        block: "s",
        category: "Щёлочноземельный металл",
        electronConfig: "[Kr] 5s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: 0.95,
        density: "2.64 г/см³",
        meltingPoint: "777 °C",
        boilingPoint: "1377 °C",
        state: "Твёрдое",
        color: "Серебристо-жёлтый",
        discoveryYear: "1790 (минерал), 1808 (металл)",
        discoverer: "Адэр Кроуфорд (минерал), Гемфри Дэви (металл)",
        nameOrigin: "От деревни Стронтиан в Шотландии",
        applications: "Фейерверки (красный цвет), магниты, стекло для ЭЛТ, зубные пасты",
        facts: "Горит ярко-красным пламенем. Sr-90 — опасный радиоактивный изотоп из ядерных осадков, накапливается в костях. Используется в светящихся красках."
    },

    // 39 - Иттрий (Yttrium)
    "Y": {
        atomicNumber: 39,
        symbol: "Y",
        name: "Иттрий",
        atomicMass: 88.906,
        period: 5,
        group: 3,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>1</sup> 5s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.22,
        density: "4.472 г/см³",
        meltingPoint: "1526 °C",
        boilingPoint: "3345 °C",
        state: "Твёрдое",
        color: "Серебристый",
        discoveryYear: "1794",
        discoverer: "Юхан Гадолин",
        nameOrigin: "От деревни Иттербю в Швеции",
        applications: "Светодиоды и люминофоры (красный цвет TV), сверхпроводники (YBCO), лазеры (YAG), сплавы",
        facts: "Четыре элемента названы в честь деревни Иттербю (Y, Tb, Er, Yb). Часто относят к редкоземельным элементам. Используется в белых светодиодах."
    },

    // 40 - Цирконий (Zirconium)
    "Zr": {
        atomicNumber: 40,
        symbol: "Zr",
        name: "Цирконий",
        atomicMass: 91.224,
        period: 5,
        group: 4,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>2</sup> 5s<sup>2</sup>",
        valenceStates: "IV",
        electronegativity: 1.33,
        density: "6.52 г/см³",
        meltingPoint: "1855 °C",
        boilingPoint: "4409 °C",
        state: "Твёрдое",
        color: "Серебристо-серый",
        discoveryYear: "1789 (оксид), 1824 (металл)",
        discoverer: "Мартин Клапрот (оксид), Йёнс Якоб Берцелиус (металл)",
        nameOrigin: "От минерала циркон, от перс. zargun (золотистый)",
        applications: "Ядерные реакторы (оболочки твэлов), керамика, зубные коронки, кубический цирконий (имитация алмаза)",
        facts: "Прозрачен для нейтронов — идеален для ядерных реакторов. Кубический диоксид циркония — популярная замена алмаза в ювелирных изделиях. Очень коррозионностойкий.",
        allotropes: {
            alpha: {
                name: "α-цирконий",
                density: "6.52 г/см³",
                structure: "Гексагональная плотноупакованная (ГПУ)",
                properties: "Стабилен до 863°C",
                alloFacts: "Основная низкотемпературная фаза."
            },
            beta: {
                name: "β-цирконий",
                structure: "Объёмно-центрированная кубическая (ОЦК)",
                properties: "Стабилен выше 863°C",
                alloFacts: "Высокотемпературная фаза."
            }
        },
        extraAllotropes: {
            omega: {
                name: "ω-цирконий",
                structure: "Гексагональная",
                properties: "Фаза высокого давления",
                alloFacts: "Образуется под давлением."
            }
        }
    },

    // 41 - Ниобий (Niobium)
    "Nb": {
        atomicNumber: 41,
        symbol: "Nb",
        name: "Ниобий",
        atomicMass: 92.906,
        period: 5,
        group: 5,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>4</sup> 5s<sup>1</sup>",
        valenceStates: "V, IV, III",
        electronegativity: 1.6,
        density: "8.57 г/см³",
        meltingPoint: "2477 °C",
        boilingPoint: "4744 °C",
        state: "Твёрдое",
        color: "Серебристо-серый",
        discoveryYear: "1801",
        discoverer: "Чарльз Хэтчетт",
        nameOrigin: "От Ниобы, дочери Тантала в греческой мифологии (из-за сходства с танталом)",
        applications: "Сверхпроводящие магниты (МРТ, БАК), жаропрочные сплавы для реактивных двигателей, хирургические импланты, ювелирные сплавы",
        facts: "Сверхпроводник при 9.3 K — один из самых высоких Tc среди элементов. Сплав Nb-Ti используется в 90% сверхпроводящих магнитов. Бразилия производит ~90% мирового ниобия."
    },

    // 42 - Молибден (Molybdenum)
    "Mo": {
        atomicNumber: 42,
        symbol: "Mo",
        name: "Молибден",
        atomicMass: 95.95,
        period: 5,
        group: 6,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>5</sup> 5s<sup>1</sup>",
        valenceStates: "VI, V, IV",
        electronegativity: 2.16,
        density: "10.28 г/см³",
        meltingPoint: "2623 °C",
        boilingPoint: "4639 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1781",
        discoverer: "Карл Вильгельм Шееле (открыл), Петер Якоб Гьельм (выделил)",
        nameOrigin: "От греч. μόλυβδος (molybdos) — свинец, т.к. молибденит путали со свинцовым блеском",
        applications: "Легирование сталей (инструментальные, нержавеющие), катализаторы, смазки (MoS₂), электроды, нагреватели",
        facts: "Шестое по тугоплавкости вещество. Дисульфид молибдена (MoS₂) — природная «сухая смазка». Биогенный элемент — входит в состав ферментов азотфиксации."
    },

    // 43 - Технеций (Technetium)
    "Tc": {
        atomicNumber: 43,
        symbol: "Tc",
        name: "Технеций",
        atomicMass: 98,
        period: 5,
        group: 7,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>5</sup> 5s<sup>2</sup>",
        valenceStates: "VII, IV",
        electronegativity: 1.9,
        density: "11.5 г/см³",
        meltingPoint: "2157 °C",
        boilingPoint: "4265 °C",
        state: "Твёрдое",
        color: "Серебристо-серый",
        discoveryYear: "1937",
        discoverer: "Карло Перье и Эмилио Сегре",
        nameOrigin: "От греч. τεχνητός (technetos) — искусственный",
        applications: "Медицинская диагностика (⁹⁹ᵐTc — 80% всех радиоизотопных процедур), ингибитор коррозии стали",
        facts: "Первый искусственно полученный элемент. Все изотопы радиоактивны. ⁹⁹ᵐTc — самый используемый радиоизотоп в медицине. На Земле в природе практически отсутствует."
    },

    // 44 - Рутений (Ruthenium)
    "Ru": {
        atomicNumber: 44,
        symbol: "Ru",
        name: "Рутений",
        atomicMass: 101.07,
        period: 5,
        group: 8,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>7</sup> 5s<sup>1</sup>",
        valenceStates: "III, IV, VIII",
        electronegativity: 2.2,
        density: "12.45 г/см³",
        meltingPoint: "2334 °C",
        boilingPoint: "4150 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1844",
        discoverer: "Карл Клаус",
        nameOrigin: "От лат. Ruthenia — Россия (открыт в Казани)",
        applications: "Катализаторы (синтез аммиака, гидрирование), резисторы, электроконтакты, покрытия жёстких дисков",
        facts: "Единственный элемент, названный в честь России. Один из платиновых металлов. RuO₄ — токсичный летучий оксид. Добавка к титану повышает коррозионную стойкость в 100 раз."
    },

    // 45 - Родий (Rhodium)
    "Rh": {
        atomicNumber: 45,
        symbol: "Rh",
        name: "Родий",
        atomicMass: 102.906,
        period: 5,
        group: 9,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>8</sup> 5s<sup>1</sup>",
        valenceStates: "III",
        electronegativity: 2.28,
        density: "12.41 г/см³",
        meltingPoint: "1964 °C",
        boilingPoint: "3695 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1803",
        discoverer: "Уильям Волластон",
        nameOrigin: "От греч. ῥόδον (rhodon) — роза, из-за розового цвета солей",
        applications: "Автокатализаторы (80% производства), покрытие зеркал и ювелирных изделий, термопары",
        facts: "Самый дорогой драгоценный металл (дороже золота и платины). Отражает 80% видимого света. Крайне устойчив к коррозии. Мировое производство ~30 тонн/год."
    },

    // 46 - Палладий (Palladium)
    "Pd": {
        atomicNumber: 46,
        symbol: "Pd",
        name: "Палладий",
        atomicMass: 106.42,
        period: 5,
        group: 10,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>10</sup>",
        valenceStates: "II, IV",
        electronegativity: 2.20,
        density: "12.02 г/см³",
        meltingPoint: "1555 °C",
        boilingPoint: "2963 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1803",
        discoverer: "Уильям Волластон",
        nameOrigin: "В честь астероида Паллада, открытого годом ранее",
        applications: "Автокатализаторы, электроника (конденсаторы), стоматология, очистка водорода, ювелирное дело (белое золото)",
        facts: "Поглощает до 900 объёмов водорода. Единственный элемент с полностью заполненной 4d-оболочкой и пустой 5s. Реакция Сузуки (Нобелевская премия 2010) использует Pd-катализаторы."
    },

    // 47 - Серебро (Silver)
    "Ag": {
        atomicNumber: 47,
        symbol: "Ag",
        name: "Серебро",
        atomicMass: 107.868,
        period: 5,
        group: 11,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>1</sup>",
        valenceStates: "I",
        electronegativity: 1.93,
        density: "10.49 г/см³",
        meltingPoint: "961.8 °C",
        boilingPoint: "2162 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "Известно с древности",
        discoverer: "Известно с древности (~5000 лет до н.э.)",
        nameOrigin: "От лат. argentum (светлый, белый), символ от того же корня",
        applications: "Ювелирное дело, электроника (лучшая электропроводность), фотография, зеркала, антибактериальные покрытия, припои",
        facts: "Рекордсмен по электро- и теплопроводности среди всех металлов. Обладает антибактериальными свойствами. Темнеет от сероводорода (образуется Ag₂S). Один из 7 металлов древности."
    },

    // 48 - Кадмий (Cadmium)
    "Cd": {
        atomicNumber: 48,
        symbol: "Cd",
        name: "Кадмий",
        atomicMass: 112.414,
        period: 5,
        group: 12,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: 1.69,
        density: "8.65 г/см³",
        meltingPoint: "321.1 °C",
        boilingPoint: "767 °C",
        state: "Твёрдое",
        color: "Серебристо-голубоватый",
        discoveryYear: "1817",
        discoverer: "Фридрих Штромейер и Карл Герман",
        nameOrigin: "От лат. cadmia — цинковая руда (каламин), в которой был обнаружен",
        applications: "Никель-кадмиевые аккумуляторы, антикоррозионные покрытия, пигменты (жёлтые, оранжевые), регулирующие стержни ядерных реакторов",
        facts: "Токсичный тяжёлый металл (болезнь итай-итай в Японии). Поглощает нейтроны — используется в ядерных реакторах. Применение сокращается из-за экологических требований."
    },

    // 49 - Индий (Indium)
    "In": {
        atomicNumber: 49,
        symbol: "In",
        name: "Индий",
        atomicMass: 114.818,
        period: 5,
        group: 13,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>2</sup> 5p<sup>1</sup>",
        valenceStates: "III, I",
        electronegativity: 1.78,
        density: "7.31 г/см³",
        meltingPoint: "156.6 °C",
        boilingPoint: "2072 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1863",
        discoverer: "Фердинанд Райх и Теодор Рихтер",
        nameOrigin: "От индиго-синей линии в спектре (лат. indicum — индиго)",
        applications: "ITO-покрытия (сенсорные экраны, ЖК-дисплеи), припои, полупроводники (InP, InAs, InSb), фотоэлементы",
        facts: "Мягкий металл — можно резать ножом. Издаёт характерный «крик» при сгибании. 70% мирового производства идёт на ITO для дисплеев. Критически важный материал для электроники."
    },

    // 50 - Олово (Tin)
    "Sn": {
        atomicNumber: 50,
        symbol: "Sn",
        name: "Олово",
        atomicMass: 118.71,
        period: 5,
        group: 14,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>2</sup> 5p<sup>2</sup>",
        valenceStates: "IV, II",
        electronegativity: 1.96,
        density: "7.26 г/см³ (белое)",
        meltingPoint: "231.9 °C",
        boilingPoint: "2602 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "Известно с древности",
        discoverer: "Известно с древности (~3500 лет до н.э.)",
        nameOrigin: "Символ Sn от лат. stannum; русское название от праславянского *olovo",
        applications: "Покрытие консервных банок (белая жесть), припои, бронза (сплав с медью), органические соединения олова",
        facts: "Один из 7 металлов древности. Бронзовый век назван по сплаву олова с медью. «Оловянная чума» — превращение белого олова в серое при T < 13°C. Издаёт характерный «крик олова» при сгибании.",
        allotropes: {
            white: {
                name: "β-олово (белое)",
                density: "7.26 г/см³",
                color: "Серебристо-белый",
                structure: "Тетрагональная",
                properties: "Стабильно выше 13.2°C, ковкий металл",
                alloDiscoveryYear: "Известно с древности",
                alloDiscoverer: "Древние цивилизации",
                alloFacts: "Обычная металлическая форма олова"
            },
            gray: {
                name: "α-олово (серое)",
                density: "5.77 г/см³",
                color: "Серый порошок",
                structure: "Кубическая (типа алмаза)",
                properties: "Полупроводник, стабильно ниже 13.2°C",
                alloDiscoveryYear: "XIX век",
                alloDiscoverer: "Систематическое изучение",
                alloFacts: "«Оловянная чума» — спонтанный переход белого олова в серое на холоде, разрушает изделия"
            }
        }
    },

    // 51 - Сурьма (Antimony)
    "Sb": {
        atomicNumber: 51,
        symbol: "Sb",
        name: "Сурьма",
        atomicMass: 121.76,
        period: 5,
        group: 15,
        block: "p",
        category: "Металлоид",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>2</sup> 5p<sup>3</sup>",
        valenceStates: "V, III",
        electronegativity: 2.05,
        density: "6.68 г/см³",
        meltingPoint: "630.6 °C",
        boilingPoint: "1587 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с синеватым оттенком",
        discoveryYear: "Известна с древности",
        discoverer: "Известна с древности (~3000 лет до н.э.)",
        nameOrigin: "Символ Sb от лат. stibium; русское «сурьма» от тур. sürme — чернить брови",
        applications: "Антипирены (замедлители горения), свинцовые аккумуляторы, типографские сплавы, полупроводники (GaSb, InSb)",
        facts: "Древние египтянки использовали сурьму для подведения глаз. Расширяется при затвердевании (как вода). Баббиты — антифрикционные сплавы на основе сурьмы."
    },

    // 52 - Теллур (Tellurium)
    "Te": {
        atomicNumber: 52,
        symbol: "Te",
        name: "Теллур",
        atomicMass: 127.6,
        period: 5,
        group: 16,
        block: "p",
        category: "Металлоид",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>2</sup> 5p<sup>4</sup>",
        valenceStates: "VI, IV, II",
        electronegativity: 2.1,
        density: "6.24 г/см³",
        meltingPoint: "449.5 °C",
        boilingPoint: "988 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с металлическим блеском",
        discoveryYear: "1782",
        discoverer: "Франц Йозеф Мюллер фон Райхенштайн",
        nameOrigin: "От лат. tellus — Земля",
        applications: "Солнечные панели (CdTe), термоэлектрики, вулканизация резины, легирование стали и меди",
        facts: "Один из редчайших элементов в земной коре (как платина). Соединения теллура придают дыханию чесночный запах. CdTe — второй по распространённости материал для солнечных батарей."
    },

    // 53 - Йод (Iodine)
    "I": {
        atomicNumber: 53,
        symbol: "I",
        name: "Йод",
        atomicMass: 126.904,
        period: 5,
        group: 17,
        block: "p",
        category: "Галоген",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>2</sup> 5p<sup>5</sup>",
        valenceStates: "VII, V, III, I",
        electronegativity: 2.66,
        density: "4.93 г/см³",
        meltingPoint: "113.7 °C",
        boilingPoint: "184.3 °C",
        state: "Твёрдое",
        color: "Тёмно-фиолетовый с металлическим блеском",
        discoveryYear: "1811",
        discoverer: "Бернар Куртуа",
        nameOrigin: "От греч. ἰώδης (iodes) — фиалковый, по цвету паров",
        applications: "Медицина (антисептик, контрастные вещества), йодированная соль, фотография, катализаторы, ЖК-дисплеи",
        facts: "Биогенный элемент — необходим для гормонов щитовидной железы. Сублимирует с образованием фиолетовых паров. Открыт случайно при производстве селитры из водорослей."
    },

    // 54 - Ксенон (Xenon)
    "Xe": {
        atomicNumber: 54,
        symbol: "Xe",
        name: "Ксенон",
        atomicMass: 131.293,
        period: 5,
        group: 18,
        block: "p",
        category: "Благородный газ",
        electronConfig: "[Kr] 4d<sup>10</sup> 5s<sup>2</sup> 5p<sup>6</sup>",
        valenceStates: "0",
        electronegativity: 2.6,
        density: "5.894 г/л",
        meltingPoint: "−111.8 °C",
        boilingPoint: "−108.1 °C",
        state: "Газообразное",
        color: "Бесцветный",
        discoveryYear: "1898",
        discoverer: "Уильям Рамзай и Моррис Траверс",
        nameOrigin: "От греч. ξένος (xenos) — чужой, странный",
        applications: "Ксеноновые лампы (кино, автомобили), анестезия, ионные двигатели космических аппаратов, детекторы тёмной материи",
        facts: "Первый благородный газ, для которого получены химические соединения (XeF₂, 1962). Используется как анестетик — безопаснее закиси азота. Самый тяжёлый стабильный благородный газ."
    },

    // 55 - Цезий (Cesium)
    "Cs": {
        atomicNumber: 55,
        symbol: "Cs",
        name: "Цезий",
        atomicMass: 132.905,
        period: 6,
        group: 1,
        block: "s",
        category: "Щелочной металл",
        electronConfig: "[Xe] 6s<sup>1</sup>",
        valenceStates: "I",
        electronegativity: 0.79,
        density: "1.93 г/см³",
        meltingPoint: "28.4 °C",
        boilingPoint: "671 °C",
        state: "Твёрдое",
        color: "Бледно-золотистый",
        discoveryYear: "1860",
        discoverer: "Роберт Бунзен и Густав Кирхгоф",
        nameOrigin: "От лат. caesius — небесно-голубой (по цвету спектральных линий)",
        applications: "Атомные часы (эталон секунды), фотоэлементы, бурение нефтяных скважин (формиат цезия), ионные двигатели",
        facts: "Первый элемент, открытый спектроскопически. Самый электроположительный стабильный элемент. Плавится в руке (Tпл = 28.4°C). Бурно реагирует с водой и воспламеняется на воздухе."
    },

    // 56 - Барий (Barium)
    "Ba": {
        atomicNumber: 56,
        symbol: "Ba",
        name: "Барий",
        atomicMass: 137.327,
        period: 6,
        group: 2,
        block: "s",
        category: "Щёлочноземельный металл",
        electronConfig: "[Xe] 6s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: 0.89,
        density: "3.51 г/см³",
        meltingPoint: "727 °C",
        boilingPoint: "1845 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1808",
        discoverer: "Гемфри Дэви",
        nameOrigin: "От греч. βαρύς (barys) — тяжёлый (по плотности минерала барита)",
        applications: "Рентгеноконтрастные вещества (BaSO₄), пиротехника (зелёный цвет), производство стекла, бурение скважин (барит)",
        facts: "Соли бария ядовиты, кроме нерастворимого сульфата (используется в медицине). Барит (BaSO₄) — важнейший минерал, утяжелитель буровых растворов. Окрашивает пламя в жёлто-зелёный цвет."
    },

    // 57 - Лантан (Lanthanum)
    "La": {
        atomicNumber: 57,
        symbol: "La",
        name: "Лантан",
        atomicMass: 138.905,
        period: 6,
        group: 3,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 5d<sup>1</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.1,
        density: "6.16 г/см³",
        meltingPoint: "920 °C",
        boilingPoint: "3464 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1839",
        discoverer: "Карл Густав Мосандер",
        nameOrigin: "От греч. λανθάνειν (lanthanein) — скрываться (долго «прятался» в церите)",
        applications: "Аккумуляторы (NiMH), катализаторы крекинга нефти, оптические стёкла, мишметалл (кремни зажигалок)",
        facts: "Родоначальник группы лантаноидов. Не имеет f-электронов, несмотря на принадлежность к f-блоку. Мишметалл (сплав РЗЭ с ~25% La) высекает искры при трении."
    },

    // 58 - Церий (Cerium)
    "Ce": {
        atomicNumber: 58,
        symbol: "Ce",
        name: "Церий",
        atomicMass: 140.116,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>1</sup> 5d<sup>1</sup> 6s<sup>2</sup>",
        valenceStates: "III, IV",
        electronegativity: 1.12,
        density: "6.77 г/см³",
        meltingPoint: "795 °C",
        boilingPoint: "3443 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с желтоватым оттенком",
        discoveryYear: "1803",
        discoverer: "Йёнс Якоб Берцелиус и Вильгельм Хизингер; независимо Мартин Клапрот",
        nameOrigin: "В честь карликовой планеты Церера, открытой двумя годами ранее",
        applications: "Автокатализаторы, полировка стекла и линз (CeO₂), мишметалл, самоочищающиеся духовки, УФ-фильтры",
        facts: "Самый распространённый лантаноид. Оксид церия (CeO₂) — ключевой компонент автокатализаторов. Имеет переменную валентность (+3/+4). Пирофорный в виде порошка."
    },

    // 59 - Празеодим (Praseodymium)
    "Pr": {
        atomicNumber: 59,
        symbol: "Pr",
        name: "Празеодим",
        atomicMass: 140.908,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>3</sup> 6s<sup>2</sup>",
        valenceStates: "III, IV",
        electronegativity: 1.13,
        density: "6.77 г/см³",
        meltingPoint: "931 °C",
        boilingPoint: "3520 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с желтоватым оттенком",
        discoveryYear: "1885",
        discoverer: "Карл Ауэр фон Вельсбах",
        nameOrigin: "От греч. πράσιος (prasios) — светло-зелёный и δίδυμος (didymos) — близнец",
        applications: "Постоянные магниты (Pr-Nd-Fe-B), окраска стёкол и эмалей в жёлто-зелёный цвет, сварочные маски, легирование магниевых сплавов",
        facts: "Выделен из «дидима» — смеси, которую 40 лет считали отдельным элементом. Соли празеодима — характерного зелёного цвета. Используется совместно с неодимом в магнитах."
    },

    // 60 - Неодим (Neodymium)
    "Nd": {
        atomicNumber: 60,
        symbol: "Nd",
        name: "Неодим",
        atomicMass: 144.242,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>4</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.14,
        density: "7.01 г/см³",
        meltingPoint: "1021 °C",
        boilingPoint: "3074 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с розоватым оттенком",
        discoveryYear: "1885",
        discoverer: "Карл Ауэр фон Вельсбах",
        nameOrigin: "От греч. νέος (neos) — новый и δίδυμος (didymos) — близнец",
        applications: "Сверхмощные постоянные магниты (Nd₂Fe₁₄B), лазеры (Nd:YAG), окраска стёкол в фиолетовый цвет, электродвигатели, наушники",
        facts: "Неодимовые магниты — сильнейшие постоянные магниты. Nd:YAG-лазер — один из самых распространённых твердотельных лазеров. Критически важен для «зелёных» технологий (ветрогенераторы, электромобили)."
    },

    // 61 - Прометий (Promethium)
    "Pm": {
        atomicNumber: 61,
        symbol: "Pm",
        name: "Прометий",
        atomicMass: 145,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>5</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.13,
        density: "7.26 г/см³",
        meltingPoint: "1170 °C",
        boilingPoint: "3000 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1945",
        discoverer: "Джейкоб Маринский, Лоуренс Гленденин и Чарльз Кориэлл",
        nameOrigin: "В честь Прометея — титана, похитившего огонь у богов",
        applications: "Атомные батареи (кардиостимуляторы), люминесцентные краски, толщиномеры, источник бета-излучения",
        facts: "Единственный лантаноид без стабильных изотопов. Все изотопы радиоактивны. В природе образуется при спонтанном делении урана в ничтожных количествах (~600 г на всю Землю)."
    },

    // 62 - Самарий (Samarium)
    "Sm": {
        atomicNumber: 62,
        symbol: "Sm",
        name: "Самарий",
        atomicMass: 150.36,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>6</sup> 6s<sup>2</sup>",
        valenceStates: "II, III",
        electronegativity: 1.17,
        density: "7.52 г/см³",
        meltingPoint: "1072 °C",
        boilingPoint: "1794 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с желтоватым оттенком",
        discoveryYear: "1879",
        discoverer: "Поль Эмиль Лекок де Буабодран",
        nameOrigin: "В честь минерала самарскита, названного по имени горного инженера В.Е. Самарского-Быховца",
        applications: "Постоянные магниты (SmCo₅, Sm₂Co₁₇), регулирующие стержни реакторов, лекарство от рака (¹⁵³Sm), датирование горных пород",
        facts: "Первый элемент, названный в честь реального человека (Самарский-Быховец). Самарий-кобальтовые магниты работают при высоких температурах (до 300°C), где неодимовые теряют свойства."
    },

    // 63 - Европий (Europium)
    "Eu": {
        atomicNumber: 63,
        symbol: "Eu",
        name: "Европий",
        atomicMass: 151.964,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>7</sup> 6s<sup>2</sup>",
        valenceStates: "II, III",
        electronegativity: 1.2,
        density: "5.24 г/см³",
        meltingPoint: "822 °C",
        boilingPoint: "1529 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1901",
        discoverer: "Эжен-Анатоль Демарсе",
        nameOrigin: "В честь Европы",
        applications: "Люминофоры (красный цвет в телевизорах и мониторах), защита банкнот евро, лазеры, ядерные реакторы",
        facts: "Самый реакционноспособный лантаноид — на воздухе окисляется за дни. Люминесценция европия даёт ярко-красное свечение. Банкноты евро содержат европий для защиты от подделок."
    },

    // 64 - Гадолиний (Gadolinium)
    "Gd": {
        atomicNumber: 64,
        symbol: "Gd",
        name: "Гадолиний",
        atomicMass: 157.25,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>7</sup> 5d<sup>1</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.2,
        density: "7.90 г/см³",
        meltingPoint: "1313 °C",
        boilingPoint: "3273 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1880",
        discoverer: "Жан Шарль Галиссар де Мариньяк",
        nameOrigin: "В честь финского химика Юхана Гадолина, первооткрывателя редкоземельных элементов",
        applications: "Контрастные вещества для МРТ, регулирующие стержни реакторов, магнитное охлаждение, сплавы с улучшенной обрабатываемостью",
        facts: "Рекордсмен по захвату тепловых нейтронов среди стабильных элементов. Ферромагнетик при комнатной температуре (единственный среди лантаноидов). Точка Кюри — 20°C."
    },

    // 65 - Тербий (Terbium)
    "Tb": {
        atomicNumber: 65,
        symbol: "Tb",
        name: "Тербий",
        atomicMass: 158.925,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>9</sup> 6s<sup>2</sup>",
        valenceStates: "III, IV",
        electronegativity: 1.2,
        density: "8.23 г/см³",
        meltingPoint: "1356 °C",
        boilingPoint: "3230 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1843",
        discoverer: "Карл Густав Мосандер",
        nameOrigin: "От названия деревни Иттербю в Швеции",
        applications: "Люминофоры (зелёный цвет), магнитострикционные сплавы (Terfenol-D), твердотельные накопители, рентгеновские экраны",
        facts: "Один из четырёх элементов, названных в честь Иттербю (Y, Tb, Er, Yb). Terfenol-D (Tb-Dy-Fe) — рекордсмен по магнитострикции при комнатной температуре. Очень дорогой металл."
    },

    // 66 - Диспрозий (Dysprosium)
    "Dy": {
        atomicNumber: 66,
        symbol: "Dy",
        name: "Диспрозий",
        atomicMass: 162.5,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>10</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.22,
        density: "8.54 г/см³",
        meltingPoint: "1412 °C",
        boilingPoint: "2567 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с желтоватым оттенком",
        discoveryYear: "1886",
        discoverer: "Поль Эмиль Лекок де Буабодран",
        nameOrigin: "От греч. δυσπρόσιτος (dysprositos) — труднодоступный",
        applications: "Постоянные магниты (повышает коэрцитивность Nd-магнитов), регулирующие стержни, лазеры, магнитное охлаждение",
        facts: "Критически важен для высокотемпературных неодимовых магнитов. Добавка 6% Dy позволяет магнитам работать при 200°C. Высокое сечение захвата нейтронов."
    },

    // 67 - Гольмий (Holmium)
    "Ho": {
        atomicNumber: 67,
        symbol: "Ho",
        name: "Гольмий",
        atomicMass: 164.93,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>11</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.23,
        density: "8.79 г/см³",
        meltingPoint: "1474 °C",
        boilingPoint: "2700 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1878",
        discoverer: "Марк Делафонтен и Жак-Луи Соре; независимо Пер Теодор Клеве",
        nameOrigin: "От лат. Holmia — Стокгольм",
        applications: "Полюсные наконечники магнитов, лазеры (Ho:YAG для хирургии), регулирующие стержни, калибровка спектрометров",
        facts: "Рекордный магнитный момент среди всех элементов (10.6 μB). Ho:YAG-лазер используется в урологии и офтальмологии. Оксид гольмия имеет уникальный спектр — эталон для калибровки."
    },

    // 68 - Эрбий (Erbium)
    "Er": {
        atomicNumber: 68,
        symbol: "Er",
        name: "Эрбий",
        atomicMass: 167.259,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>12</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.24,
        density: "9.07 г/см³",
        meltingPoint: "1529 °C",
        boilingPoint: "2868 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1843",
        discoverer: "Карл Густав Мосандер",
        nameOrigin: "От названия деревни Иттербю в Швеции",
        applications: "Оптоволоконные усилители (EDFA), лазеры (Er:YAG для дерматологии), розовая окраска стекла и керамики, ядерные технологии",
        facts: "Эрбиевые усилители (EDFA) — основа дальней оптоволоконной связи, работают на 1550 нм. Er:YAG-лазер используется для шлифовки кожи. Соли эрбия — характерного розового цвета."
    },

    // 69 - Тулий (Thulium)
    "Tm": {
        atomicNumber: 69,
        symbol: "Tm",
        name: "Тулий",
        atomicMass: 168.934,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>13</sup> 6s<sup>2</sup>",
        valenceStates: "II, III",
        electronegativity: 1.25,
        density: "9.32 г/см³",
        meltingPoint: "1545 °C",
        boilingPoint: "1950 °C",
        state: "Твёрдое",
        color: "Серебристо-серый",
        discoveryYear: "1879",
        discoverer: "Пер Теодор Клеве",
        nameOrigin: "От Thule — древнего названия Скандинавии",
        applications: "Портативные рентгеновские аппараты (¹⁷⁰Tm), лазеры (Tm:YAG для хирургии), высокотемпературные сверхпроводники",
        facts: "Второй по редкости лантаноид после прометия. ¹⁷⁰Tm — источник рентгеновского излучения для портативных аппаратов. Tm:YAG-лазер хорошо поглощается водой — идеален для хирургии."
    },

    // 70 - Иттербий (Ytterbium)
    "Yb": {
        atomicNumber: 70,
        symbol: "Yb",
        name: "Иттербий",
        atomicMass: 173.045,
        period: 6,
        group: null,
        block: "f",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>14</sup> 6s<sup>2</sup>",
        valenceStates: "II, III",
        electronegativity: 1.1,
        density: "6.90 г/см³",
        meltingPoint: "824 °C",
        boilingPoint: "1196 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1878",
        discoverer: "Жан Шарль Галиссар де Мариньяк",
        nameOrigin: "От названия деревни Иттербю в Швеции",
        applications: "Волоконные лазеры высокой мощности (Yb:YAG), легирование нержавеющих сталей, атомные часы нового поколения, датчики давления",
        facts: "Четвёртый элемент, названный в честь Иттербю. Yb-волоконные лазеры — до 100 кВт мощности. Иттербиевые атомные часы точнее цезиевых. Мягкий металл — царапается ногтём."
    },

    // 71 - Лютеций (Lutetium)
    "Lu": {
        atomicNumber: 71,
        symbol: "Lu",
        name: "Лютеций",
        atomicMass: 174.967,
        period: 6,
        group: 3,
        block: "d",
        category: "Лантаноид",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>1</sup> 6s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.27,
        density: "9.84 г/см³",
        meltingPoint: "1663 °C",
        boilingPoint: "3402 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1907",
        discoverer: "Жорж Урбен; независимо Карл Ауэр фон Вельсбах",
        nameOrigin: "От лат. Lutetia — древнее название Парижа",
        applications: "ПЭТ-сканеры (детекторы Lu₂SiO₅:Ce), катализаторы нефтепереработки, датирование метеоритов (Lu-Hf метод)",
        facts: "Последний и самый тяжёлый лантаноид. Самый твёрдый и плотный из РЗЭ. Один из самых дорогих металлов (~$10 000/кг). Спор о приоритете открытия между Урбеном и Вельсбахом."
    },

    // 72 - Гафний (Hafnium)
    "Hf": {
        atomicNumber: 72,
        symbol: "Hf",
        name: "Гафний",
        atomicMass: 178.49,
        period: 6,
        group: 4,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>2</sup> 6s<sup>2</sup>",
        valenceStates: "IV",
        electronegativity: 1.3,
        density: "13.31 г/см³",
        meltingPoint: "2233 °C",
        boilingPoint: "4603 °C",
        state: "Твёрдое",
        color: "Серебристо-серый",
        discoveryYear: "1923",
        discoverer: "Дирк Костер и Дьёрдь де Хевеши",
        nameOrigin: "От лат. Hafnia — древнее название Копенгагена",
        applications: "Регулирующие стержни ядерных реакторов, жаропрочные сплавы, high-k диэлектрики в процессорах, плазменная резка",
        facts: "Предпоследний открытый стабильный элемент. Химически почти идентичен цирконию — их разделение крайне сложно. Intel и другие используют HfO₂ в транзисторах с 2007 года."
    },

    // 73 - Тантал (Tantalum)
    "Ta": {
        atomicNumber: 73,
        symbol: "Ta",
        name: "Тантал",
        atomicMass: 180.948,
        period: 6,
        group: 5,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>3</sup> 6s<sup>2</sup>",
        valenceStates: "V",
        electronegativity: 1.5,
        density: "16.69 г/см³",
        meltingPoint: "3017 °C",
        boilingPoint: "5458 °C",
        state: "Твёрдое",
        color: "Серо-голубой",
        discoveryYear: "1802",
        discoverer: "Андерс Густав Экеберг",
        nameOrigin: "В честь Тантала — персонажа греческой мифологии (из-за «неутолимой жажды» к кислотам)",
        applications: "Конденсаторы (электроника, смартфоны), хирургические импланты, жаропрочные сплавы, химическое оборудование",
        facts: "Исключительная коррозионная стойкость — не растворяется в кислотах (кроме HF+HNO₃). Биосовместим — используется в имплантах. «Конфликтный минерал» — добыча в ДР Конго связана с войнами."
    },

    // 74 - Вольфрам (Tungsten)
    "W": {
        atomicNumber: 74,
        symbol: "W",
        name: "Вольфрам",
        atomicMass: 183.84,
        period: 6,
        group: 6,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>4</sup> 6s<sup>2</sup>",
        valenceStates: "VI",
        electronegativity: 2.36,
        density: "19.25 г/см³",
        meltingPoint: "3422 °C",
        boilingPoint: "5555 °C",
        state: "Твёрдое",
        color: "Серо-стальной",
        discoveryYear: "1783",
        discoverer: "Братья Хуан Хосе и Фаусто Эльюар",
        nameOrigin: "Символ W от нем. Wolfram (волчьи сливки); русское название от того же корня",
        applications: "Нити накаливания, твёрдые сплавы (победит), электроды для сварки, бронебойные снаряды, радиационная защита",
        facts: "Самый тугоплавкий металл (Tпл = 3422°C). Второй по твёрдости после алмаза в виде карбида WC. Плотность как у золота — используется для подделок. 80% мировой добычи — Китай."
    },

    // 75 - Рений (Rhenium)
    "Re": {
        atomicNumber: 75,
        symbol: "Re",
        name: "Рений",
        atomicMass: 186.207,
        period: 6,
        group: 7,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>5</sup> 6s<sup>2</sup>",
        valenceStates: "VII, VI, IV",
        electronegativity: 1.9,
        density: "21.02 г/см³",
        meltingPoint: "3186 °C",
        boilingPoint: "5596 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1925",
        discoverer: "Вальтер Ноддак, Ида Ноддак и Отто Берг",
        nameOrigin: "От лат. Rhenus — река Рейн",
        applications: "Жаропрочные суперсплавы для турбин, катализаторы нефтепереработки, термопары, электроконтакты",
        facts: "Последний открытый стабильный элемент с природными изотопами. Второй по тугоплавкости после вольфрама. Самый редкий из нерадиоактивных элементов (~1 ppb в земной коре). Цена ~$3000/кг."
    },

    // 76 - Осмий (Osmium)
    "Os": {
        atomicNumber: 76,
        symbol: "Os",
        name: "Осмий",
        atomicMass: 190.23,
        period: 6,
        group: 8,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>6</sup> 6s<sup>2</sup>",
        valenceStates: "VIII, IV",
        electronegativity: 2.2,
        density: "22.59 г/см³",
        meltingPoint: "3033 °C",
        boilingPoint: "5012 °C",
        state: "Твёрдое",
        color: "Серебристо-голубоватый",
        discoveryYear: "1803",
        discoverer: "Смитсон Теннант",
        nameOrigin: "От греч. ὀσμή (osme) — запах (из-за резкого запаха OsO₄)",
        applications: "Наконечники перьев, иглы компасов, электроконтакты, катализаторы, сплавы с платиной для имплантов",
        facts: "Самый плотный элемент (22.59 г/см³). OsO₄ — крайне токсичен (поражает глаза и лёгкие). Имеет голубоватый оттенок — единственный металл с заметным цветом кроме золота и меди."
    },

    // 77 - Иридий (Iridium)
    "Ir": {
        atomicNumber: 77,
        symbol: "Ir",
        name: "Иридий",
        atomicMass: 192.217,
        period: 6,
        group: 9,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>7</sup> 6s<sup>2</sup>",
        valenceStates: "IV, III",
        electronegativity: 2.2,
        density: "22.56 г/см³",
        meltingPoint: "2446 °C",
        boilingPoint: "4428 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1803",
        discoverer: "Смитсон Теннант",
        nameOrigin: "От греч. ἶρις (iris) — радуга (из-за разноцветных солей)",
        applications: "Свечи зажигания, тигли для выращивания кристаллов, электроды, эталон метра (до 1960), наконечники перьев",
        facts: "Второй по плотности элемент после осмия. Самый коррозионностойкий металл. Иридиевая аномалия на границе мела и палеогена — свидетельство падения астероида, вызвавшего вымирание динозавров."
    },

    // 78 - Платина (Platinum)
    "Pt": {
        atomicNumber: 78,
        symbol: "Pt",
        name: "Платина",
        atomicMass: 195.084,
        period: 6,
        group: 10,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>9</sup> 6s<sup>1</sup>",
        valenceStates: "II, IV",
        electronegativity: 2.28,
        density: "21.45 г/см³",
        meltingPoint: "1768 °C",
        boilingPoint: "3825 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1735",
        discoverer: "Антонио де Ульоа (описал); использовалась в Южной Америке задолго до этого",
        nameOrigin: "От исп. platina — серебришко (уменьшительное от plata — серебро)",
        applications: "Автокатализаторы (40% производства), ювелирное дело, химическое оборудование, противораковые препараты (цисплатин), топливные элементы",
        facts: "Испанцы считали платину «незрелым серебром» и выбрасывали. Эталон килограмма был из платино-иридиевого сплава до 2019 года. Цисплатин — один из важнейших противораковых препаратов."
    },

    // 79 - Золото (Gold)
    "Au": {
        atomicNumber: 79,
        symbol: "Au",
        name: "Золото",
        atomicMass: 196.967,
        period: 6,
        group: 11,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>1</sup>",
        valenceStates: "I, III",
        electronegativity: 2.54,
        density: "19.3 г/см³",
        meltingPoint: "1064 °C",
        boilingPoint: "2856 °C",
        state: "Твёрдое",
        color: "Жёлтый",
        discoveryYear: "Известно с древности",
        discoverer: "Известно с древности (~6000 лет до н.э.)",
        nameOrigin: "Символ Au от лат. aurum (сияющий); русское «золото» от праславянского *zolto",
        applications: "Ювелирное дело, электроника (контакты, проводники), резервная валюта, стоматология, аэрокосмическая отрасль (защитные покрытия)",
        facts: "Один из 7 металлов древности. Не окисляется на воздухе. Всё добытое золото (~200 000 тонн) поместится в куб со стороной 22 м. Жёлтый цвет — результат релятивистских эффектов."
    },

    // 80 - Ртуть (Mercury)
    "Hg": {
        atomicNumber: 80,
        symbol: "Hg",
        name: "Ртуть",
        atomicMass: 200.592,
        period: 6,
        group: 12,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>2</sup>",
        valenceStates: "II, I",
        electronegativity: 2.0,
        density: "13.53 г/см³",
        meltingPoint: "−38.8 °C",
        boilingPoint: "356.7 °C",
        state: "Жидкое",
        color: "Серебристо-белый",
        discoveryYear: "Известна с древности",
        discoverer: "Известна с древности (~1500 лет до н.э.)",
        nameOrigin: "Символ Hg от лат. hydrargyrum (жидкое серебро); названа в честь планеты Меркурий",
        applications: "Термометры и барометры (исторически), люминесцентные лампы, амальгамы в стоматологии (устаревает), производство хлора",
        facts: "Единственный металл, жидкий при комнатной температуре. Токсична — вызывает болезнь Минамата. Легко испаряется — опасна в закрытых помещениях. Алхимики считали её «первоматерией» всех металлов."
    },

    // 81 - Таллий (Thallium)
    "Tl": {
        atomicNumber: 81,
        symbol: "Tl",
        name: "Таллий",
        atomicMass: 204.38,
        period: 6,
        group: 13,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>2</sup> 6p<sup>1</sup>",
        valenceStates: "III, I",
        electronegativity: 1.62,
        density: "11.85 г/см³",
        meltingPoint: "304 °C",
        boilingPoint: "1473 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с голубоватым оттенком",
        discoveryYear: "1861",
        discoverer: "Уильям Крукс",
        nameOrigin: "От греч. θαλλός (thallos) — зелёная ветвь (по яркой зелёной линии в спектре)",
        applications: "Детекторы инфракрасного излучения, сцинтилляторы (TlBr), высокотемпературные сверхпроводники, медицинская диагностика (²⁰¹Tl)",
        facts: "Крайне токсичен — «яд отравителей» (без вкуса и запаха). Соли таллия использовались как крысиный яд. Агата Кристи описала отравление таллием в романе «Вилла «Белый конь»»."
    },

    // 82 - Свинец (Lead)
    "Pb": {
        atomicNumber: 82,
        symbol: "Pb",
        name: "Свинец",
        atomicMass: 207.2,
        period: 6,
        group: 14,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>2</sup> 6p<sup>2</sup>",
        valenceStates: "IV, II",
        electronegativity: 2.33,
        density: "11.34 г/см³",
        meltingPoint: "327.5 °C",
        boilingPoint: "1749 °C",
        state: "Твёрдое",
        color: "Серо-голубой",
        discoveryYear: "Известен с древности",
        discoverer: "Известен с древности (~7000 лет до н.э.)",
        nameOrigin: "Символ Pb от лат. plumbum; русское «свинец» от праславянского корня",
        applications: "Аккумуляторы (80% производства), радиационная защита, припои, грузила, исторически — краски и бензин",
        facts: "Один из 7 металлов древности. Римляне использовали свинцовые трубы (plumbum → plumber). Тетраэтилсвинец в бензине — одна из крупнейших экологических катастроф XX века. ²⁰⁸Pb — самый тяжёлый стабильный изотоп."
    },

    // 83 - Висмут (Bismuth)
    "Bi": {
        atomicNumber: 83,
        symbol: "Bi",
        name: "Висмут",
        atomicMass: 208.98,
        period: 6,
        group: 15,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>2</sup> 6p<sup>3</sup>",
        valenceStates: "V, III",
        electronegativity: 2.02,
        density: "9.78 г/см³",
        meltingPoint: "271.4 °C",
        boilingPoint: "1564 °C",
        state: "Твёрдое",
        color: "Серебристо-розовый с радужной оксидной плёнкой",
        discoveryYear: "~1400 (как отдельный элемент — 1753)",
        discoverer: "Клод Жоффруа Младший (доказал отличие от свинца и олова)",
        nameOrigin: "От нем. Wismut, возможно от weiße Masse — белая масса",
        applications: "Лекарства (Пепто-Бисмол, Де-Нол), легкоплавкие сплавы (сплав Вуда), косметика, замена свинца в припоях",
        facts: "Долго считался самым тяжёлым стабильным элементом, пока в 2003 не обнаружили слабую радиоактивность (T₁/₂ = 1.9×10¹⁹ лет). Расширяется при затвердевании. Образует красивые радужные кристаллы-«хопперы»."
    },

    // 84 - Полоний (Polonium)
    "Po": {
        atomicNumber: 84,
        symbol: "Po",
        name: "Полоний",
        atomicMass: 209,
        period: 6,
        group: 16,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>2</sup> 6p<sup>4</sup>",
        valenceStates: "VI, IV, II",
        electronegativity: 2.0,
        density: "9.20 г/см³",
        meltingPoint: "254 °C",
        boilingPoint: "962 °C",
        state: "Твёрдое",
        color: "Серебристый",
        discoveryYear: "1898",
        discoverer: "Мария Склодовская-Кюри и Пьер Кюри",
        nameOrigin: "В честь Польши (лат. Polonia) — родины Марии Кюри",
        applications: "Устранение статического электричества, атомные батареи (космические аппараты «Луноход»), источник нейтронов (с бериллием)",
        facts: "Первый элемент, открытый по радиоактивности. Чрезвычайно токсичен — смертельная доза < 1 мкг. Использован для убийства Александра Литвиненко в 2006 году. Разогревается до 500°C собственным излучением."
    },

    // 85 - Астат (Astatine)
    "At": {
        atomicNumber: 85,
        symbol: "At",
        name: "Астат",
        atomicMass: 210,
        period: 6,
        group: 17,
        block: "p",
        category: "Галоген",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>2</sup> 6p<sup>5</sup>",
        valenceStates: "VII, V, III, I",
        electronegativity: 2.2,
        density: "~7 г/см³ (расчётная)",
        meltingPoint: "302 °C",
        boilingPoint: "337 °C",
        state: "Твёрдое",
        color: "Предположительно тёмный (металлический блеск)",
        discoveryYear: "1940",
        discoverer: "Дейл Корсон, Кеннет Маккензи и Эмилио Сегре",
        nameOrigin: "От греч. ἄστατος (astatos) — нестабильный",
        applications: "Потенциально — таргетная альфа-терапия рака (²¹¹At), исследования",
        facts: "Самый редкий природный элемент — в земной коре одновременно существует < 30 г. Самый короткоживущий галоген. Никто никогда не видел астат невооружённым глазом. Свойства предсказаны теоретически."
    },

    // 86 - Радон (Radon)
    "Rn": {
        atomicNumber: 86,
        symbol: "Rn",
        name: "Радон",
        atomicMass: 222,
        period: 6,
        group: 18,
        block: "p",
        category: "Благородный газ",
        electronConfig: "[Xe] 4f<sup>14</sup> 5d<sup>10</sup> 6s<sup>2</sup> 6p<sup>6</sup>",
        valenceStates: "0",
        electronegativity: 2.2,
        density: "9.73 г/л",
        meltingPoint: "−71 °C",
        boilingPoint: "−61.7 °C",
        state: "Газообразное",
        color: "Бесцветный",
        discoveryYear: "1900",
        discoverer: "Фридрих Эрнст Дорн",
        nameOrigin: "От названия радия, при распаде которого образуется",
        applications: "Радонотерапия (спорная), отслеживание утечек, прогнозирование землетрясений (исследования)",
        facts: "Вторая по значимости причина рака лёгких после курения. Накапливается в подвалах и шахтах. Самый тяжёлый газ. Радиоактивен — T₁/₂ (²²²Rn) = 3.8 дня. Единственный радиоактивный благородный газ с заметным временем жизни."
    },

    // 87 - Франций (Francium)
    "Fr": {
        atomicNumber: 87,
        symbol: "Fr",
        name: "Франций",
        atomicMass: 223,
        period: 7,
        group: 1,
        block: "s",
        category: "Щелочной металл",
        electronConfig: "[Rn] 7s<sup>1</sup>",
        valenceStates: "I",
        electronegativity: 0.79,
        density: "~2.48 г/см³ (расчётная)",
        meltingPoint: "~27 °C",
        boilingPoint: "~677 °C",
        state: "Твёрдое",
        color: "Предположительно серебристый",
        discoveryYear: "1939",
        discoverer: "Маргарита Перей",
        nameOrigin: "В честь Франции",
        applications: "Только научные исследования (атомные ловушки, спектроскопия)",
        facts: "Самый нестабильный из первых 103 элементов. В природе одновременно существует < 30 г на всю Землю. Самый электроположительный элемент. T₁/₂ (²²³Fr) = 22 минуты. Открыт последним из природных элементов."
    },

    // 88 - Радий (Radium)
    "Ra": {
        atomicNumber: 88,
        symbol: "Ra",
        name: "Радий",
        atomicMass: 226,
        period: 7,
        group: 2,
        block: "s",
        category: "Щёлочноземельный металл",
        electronConfig: "[Rn] 7s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: 0.9,
        density: "5.5 г/см³",
        meltingPoint: "700 °C",
        boilingPoint: "1737 °C",
        state: "Твёрдое",
        color: "Серебристо-белый (быстро темнеет)",
        discoveryYear: "1898",
        discoverer: "Мария Склодовская-Кюри и Пьер Кюри",
        nameOrigin: "От лат. radius — луч (из-за радиоактивного излучения)",
        applications: "Исторически — светящиеся краски, медицина; сейчас — источник радона, научные исследования",
        facts: "Светится в темноте голубым светом. «Радиевые девушки» — трагедия работниц, красивших циферблаты радиевой краской. В 1 г радия происходит 37 млрд распадов в секунду (1 Кюри). Нобелевская премия Кюри 1911 года."
    },

    // 89 - Актиний (Actinium)
    "Ac": {
        atomicNumber: 89,
        symbol: "Ac",
        name: "Актиний",
        atomicMass: 227,
        period: 7,
        group: 3,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 6d<sup>1</sup> 7s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.1,
        density: "10.07 г/см³",
        meltingPoint: "1050 °C",
        boilingPoint: "3200 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1899",
        discoverer: "Андре-Луи Дебьерн",
        nameOrigin: "От греч. ἀκτίς (aktis) — луч",
        applications: "Источник нейтронов (с бериллием), потенциально — таргетная альфа-терапия рака (²²⁵Ac), термоэлектрические генераторы",
        facts: "Родоначальник группы актиноидов. Светится в темноте голубым светом (интенсивнее радия). В 150 раз радиоактивнее радия. В природе — следовые количества в урановых рудах."
    },

    // 90 - Торий (Thorium)
    "Th": {
        atomicNumber: 90,
        symbol: "Th",
        name: "Торий",
        atomicMass: 232.038,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 6d<sup>2</sup> 7s<sup>2</sup>",
        valenceStates: "IV",
        electronegativity: 1.3,
        density: "11.72 г/см³",
        meltingPoint: "1750 °C",
        boilingPoint: "4788 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1829",
        discoverer: "Йёнс Якоб Берцелиус",
        nameOrigin: "В честь Тора — скандинавского бога грома",
        applications: "Ядерное топливо (ториевый цикл), газовые мантии (исторически), линзы с высоким преломлением, сварочные электроды",
        facts: "В 3-4 раза распространённее урана в земной коре. Ториевые реакторы — потенциально более безопасная альтернатива урановым. Радиоактивен, но слабо (T₁/₂ = 14 млрд лет). Газовые мантии Ауэра содержали 99% ThO₂."
    },

    // 91 - Протактиний (Protactinium)
    "Pa": {
        atomicNumber: 91,
        symbol: "Pa",
        name: "Протактиний",
        atomicMass: 231.036,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>2</sup> 6d<sup>1</sup> 7s<sup>2</sup>",
        valenceStates: "V, IV",
        electronegativity: 1.5,
        density: "15.37 г/см³",
        meltingPoint: "1572 °C",
        boilingPoint: "4000 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с металлическим блеском",
        discoveryYear: "1913 (²³⁴Pa); 1921 (²³¹Pa)",
        discoverer: "Казимир Фаянс и Освальд Гельмут Гёринг; Фредерик Содди и Джон Крэнстон; Отто Ган и Лиза Мейтнер",
        nameOrigin: "От греч. πρῶτος (protos) — первый + актиний (распадается в актиний)",
        applications: "Только научные исследования (крайне редок и дорог)",
        facts: "Один из самых редких и дорогих элементов (~$280 000/г). Высокотоксичен и радиоактивен. В природе ~2 ppm в урановых рудах. Химия изучена слабо из-за редкости и опасности."
    },

    // 92 - Уран (Uranium)
    "U": {
        atomicNumber: 92,
        symbol: "U",
        name: "Уран",
        atomicMass: 238.029,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>3</sup> 6d<sup>1</sup> 7s<sup>2</sup>",
        valenceStates: "VI, V, IV, III",
        electronegativity: 1.38,
        density: "19.1 г/см³",
        meltingPoint: "1135 °C",
        boilingPoint: "4131 °C",
        state: "Твёрдое",
        color: "Серебристо-белый с металлическим блеском",
        discoveryYear: "1789",
        discoverer: "Мартин Генрих Клапрот",
        nameOrigin: "В честь планеты Уран, открытой за 8 лет до этого",
        applications: "Ядерное топливо (АЭС), ядерное оружие, бронебойные снаряды (обеднённый уран), противовесы, окраска стекла и керамики",
        facts: "Последний природный элемент по атомному номеру. ²³⁵U — единственный природный делящийся изотоп (0.7%). Плотнее свинца на 70%. Урановое стекло флуоресцирует зелёным под УФ. Атомная бомба «Малыш» — урановая.",
        allotropes: {
            alpha: {
                name: "α-уран",
                density: "19.1 г/см³",
                structure: "Орторомбическая",
                properties: "Ковкий, анизотропный",
                alloFacts: "Стабилен до 660°C. Основная форма металлического урана."
            }
        },
        extraAllotropes: {
            beta: {
                name: "β-уран",
                density: "18.11 г/см³",
                structure: "Тетрагональная",
                properties: "Твёрдая и хрупкая фаза (660–760°C)",
                alloFacts: "Сложная кристаллическая структура."
            },
            gamma: {
                name: "γ-уран",
                density: "18.06 г/см³",
                structure: "ОЦК",
                properties: "Пластичная фаза (760–1132°C)",
                alloFacts: "Наиболее технологичная форма, стабилизируется легированием (молибденом)."
            }
        }
    },

    // 93 - Нептуний (Neptunium)
    "Np": {
        atomicNumber: 93,
        symbol: "Np",
        name: "Нептуний",
        atomicMass: 237,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>4</sup> 6d<sup>1</sup> 7s<sup>2</sup>",
        valenceStates: "VII, VI, V, IV, III",
        electronegativity: 1.36,
        density: "20.45 г/см³",
        meltingPoint: "644 °C",
        boilingPoint: "3902 °C",
        state: "Твёрдое",
        color: "Серебристый",
        discoveryYear: "1940",
        discoverer: "Эдвин Макмиллан и Филип Абельсон",
        nameOrigin: "В честь планеты Нептун (следующая за Ураном)",
        applications: "Детекторы нейтронов, прекурсор для получения ²³⁸Pu, научные исследования",
        facts: "Первый трансурановый элемент. Образуется в ядерных реакторах в значительных количествах. ²³⁷Np — основа нептуниевого ряда радиоактивного распада. Следовые количества найдены в урановых рудах."
    },

    // 94 - Плутоний (Plutonium)
    "Pu": {
        atomicNumber: 94,
        symbol: "Pu",
        name: "Плутоний",
        atomicMass: 244,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>6</sup> 7s<sup>2</sup>",
        valenceStates: "VI, V, IV, III",
        electronegativity: 1.28,
        density: "19.85 г/см³",
        meltingPoint: "640 °C",
        boilingPoint: "3228 °C",
        state: "Твёрдое",
        color: "Серебристый, тускнеет до тёмно-серого",
        discoveryYear: "1940",
        discoverer: "Гленн Сиборг, Эдвин Макмиллан, Джозеф Кеннеди и Артур Валь",
        nameOrigin: "В честь карликовой планеты Плутон (следующая за Нептуном)",
        applications: "Ядерное оружие, ядерное топливо (MOX), РИТЭГи для космических аппаратов (²³⁸Pu), кардиостимуляторы (исторически)",
        facts: "Самое токсичное вещество на Земле по массе. Имеет 6 аллотропных модификаций — рекорд среди элементов. Бомба «Толстяк» — плутониевая. ²³⁸Pu питает «Вояджеры» и марсоходы. Теплый на ощупь от собственного распада.",
        allotropes: {
            alpha: {
                name: "α-плутоний",
                density: "19.86 г/см³",
                structure: "Моноклинная",
                properties: "Твёрдый и хрупкий как чугун",
                alloFacts: "Стабилен при комнатной температуре. Плохо проводит тепло и электричество."
            },
            delta: {
                name: "δ-плутоний",
                density: "15.92 г/см³",
                structure: "ГЦК",
                properties: "Пластичный как алюминий",
                alloFacts: "Стабилен 310–452°C, но стабилизируется галлием при комнатной температуре (для ядерных зарядов)."
            }
        },
        extraAllotropes: {
            beta: {
                name: "β-плутоний",
                structure: "Моноклинная",
                properties: "Существует 122–207°C",
                alloFacts: "Сильно меняет объём при фазовом переходе."
            },
            gamma: {
                name: "γ-плутоний",
                structure: "Орторомбическая",
                properties: "Существует 207–315°C",
                alloFacts: "Ещё одна промежуточная фаза со сложной структурой."
            },
            deltaPrime: {
                name: "δ'-плутоний",
                structure: "Тетрагональная",
                properties: "Узкий диапазон 452–480°C",
                alloFacts: "Уникальная фаза, существует в узком температурном интервале."
            },
            epsilon: {
                name: "ε-плутоний",
                structure: "ОЦК",
                properties: "Высокотемпературная (480–640°C)",
                alloFacts: "Самая высокотемпературная твердая фаза перед плавлением."
            }
        }
    },

    // 95 - Америций (Americium)
    "Am": {
        atomicNumber: 95,
        symbol: "Am",
        name: "Америций",
        atomicMass: 243,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>7</sup> 7s<sup>2</sup>",
        valenceStates: "III, IV",
        electronegativity: 1.3,
        density: "13.67 г/см³",
        meltingPoint: "1176 °C",
        boilingPoint: "2011 °C",
        state: "Твёрдое",
        color: "Серебристо-белый",
        discoveryYear: "1944",
        discoverer: "Гленн Сиборг, Ральф Джеймс, Леон Морган и Альберт Гиорсо",
        nameOrigin: "В честь Америки (по аналогии с европием — в честь Европы)",
        applications: "Датчики дыма (²⁴¹Am), источники гамма-излучения, нейтронные источники (с бериллием)",
        facts: "Самый распространённый трансурановый элемент в быту — есть в каждом датчике дыма (~0.3 мкг). Открытие объявлено в детской радиопередаче до научной публикации. Аналог европия среди актиноидов."
    },

    // 96 - Кюрий (Curium)
    "Cm": {
        atomicNumber: 96,
        symbol: "Cm",
        name: "Кюрий",
        atomicMass: 247,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>7</sup> 6d<sup>1</sup> 7s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.3,
        density: "13.51 г/см³",
        meltingPoint: "1345 °C",
        boilingPoint: "3110 °C",
        state: "Твёрдое",
        color: "Серебристый",
        discoveryYear: "1944",
        discoverer: "Гленн Сиборг, Ральф Джеймс и Альберт Гиорсо",
        nameOrigin: "В честь Марии и Пьера Кюри",
        applications: "РИТЭГи для космических аппаратов, альфа-спектрометры на марсоходах (APXS), источник нейтронов",
        facts: "Настолько радиоактивен, что светится в темноте (фиолетовым). Марсоходы Spirit, Opportunity и Curiosity использовали ²⁴⁴Cm для анализа грунта. Аналог гадолиния среди актиноидов. 1 г выделяет ~3 Вт тепла."
    },

    // 97 - Берклий (Berkelium)
    "Bk": {
        atomicNumber: 97,
        symbol: "Bk",
        name: "Берклий",
        atomicMass: 247,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>9</sup> 7s<sup>2</sup>",
        valenceStates: "III, IV",
        electronegativity: 1.3,
        density: "14.78 г/см³",
        meltingPoint: "986 °C",
        boilingPoint: "2627 °C",
        state: "Твёрдое",
        color: "Серебристый",
        discoveryYear: "1949",
        discoverer: "Стэнли Томпсон, Альберт Гиорсо и Гленн Сиборг",
        nameOrigin: "В честь города Беркли (Калифорния), где находится лаборатория",
        applications: "Мишень для синтеза более тяжёлых элементов (оганесон!), научные исследования",
        facts: "Для синтеза оганесона (118) потребовалось 22 мг берклия — на накопление ушло 250 дней. Получено всего ~1 г за всю историю. Аналог тербия среди актиноидов. Стоимость ~$27 млн/г."
    },

    // 98 - Калифорний (Californium)
    "Cf": {
        atomicNumber: 98,
        symbol: "Cf",
        name: "Калифорний",
        atomicMass: 251,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>10</sup> 7s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.3,
        density: "15.1 г/см³",
        meltingPoint: "900 °C",
        boilingPoint: "1470 °C",
        state: "Твёрдое",
        color: "Серебристый",
        discoveryYear: "1950",
        discoverer: "Стэнли Томпсон, Кеннет Стрит, Альберт Гиорсо и Гленн Сиборг",
        nameOrigin: "В честь штата Калифорния и Калифорнийского университета",
        applications: "Запуск ядерных реакторов, нейтронография, поиск золота и воды, лечение рака (брахитерапия), детекторы взрывчатки",
        facts: "Сильнейший источник нейтронов среди всех изотопов (²⁵²Cf). 1 мкг испускает 170 млн нейтронов/сек. Стоимость ~$27 млн/г. Мировое производство ~0.5 г/год. Использовался для поиска утечек в ядерных реакторах."
    },

    // 99 - Эйнштейний (Einsteinium)
    "Es": {
        atomicNumber: 99,
        symbol: "Es",
        name: "Эйнштейний",
        atomicMass: 252,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>11</sup> 7s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.3,
        density: "8.84 г/см³",
        meltingPoint: "860 °C",
        boilingPoint: "996 °C",
        state: "Твёрдое",
        color: "Серебристый (предположительно)",
        discoveryYear: "1952",
        discoverer: "Альберт Гиорсо и др. (Беркли, Аргонн, Лос-Аламос)",
        nameOrigin: "В честь Альберта Эйнштейна",
        applications: "Только научные исследования, мишень для синтеза более тяжёлых элементов",
        facts: "Обнаружен в осадках первого термоядерного взрыва (Ivy Mike, 1952). Информация засекречена до 1955 года. Получено всего ~1 мг за всю историю. Быстро распадается — сложно изучать химию."
    },

    // 100 - Фермий (Fermium)
    "Fm": {
        atomicNumber: 100,
        symbol: "Fm",
        name: "Фермий",
        atomicMass: 257,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>12</sup> 7s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.3,
        density: "9.7 г/см³ (расчётная)",
        meltingPoint: "1527 °C",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1952",
        discoverer: "Альберт Гиорсо и др. (Беркли, Аргонн, Лос-Аламос)",
        nameOrigin: "В честь Энрико Ферми — создателя первого ядерного реактора",
        applications: "Только научные исследования",
        facts: "Обнаружен вместе с эйнштейнием в осадках взрыва «Ivy Mike». Последний элемент, который можно получить нейтронным облучением. ²⁵⁷Fm — T₁/₂ = 100 дней. Химические свойства изучены на считанных атомах."
    },

    // 101 - Менделевий (Mendelevium)
    "Md": {
        atomicNumber: 101,
        symbol: "Md",
        name: "Менделевий",
        atomicMass: 258,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>13</sup> 7s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: 1.3,
        density: "10.3 г/см³ (расчётная)",
        meltingPoint: "827 °C",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1955",
        discoverer: "Альберт Гиорсо, Гленн Сиборг, Грегори Чоппин, Бернард Харви и Стэнли Томпсон",
        nameOrigin: "В честь Дмитрия Ивановича Менделеева — создателя Периодической таблицы",
        applications: "Только научные исследования",
        facts: "Первый элемент, полученный синтезом «атом за атомом». Назван в честь Менделеева, чтобы увековечить его имя в его же таблице. ²⁵⁸Md имеет T₁/₂ = 51.5 дней."
    },

    // 102 - Нобелий (Nobelium)
    "No": {
        atomicNumber: 102,
        symbol: "No",
        name: "Нобелий",
        atomicMass: 259,
        period: 7,
        group: null,
        block: "f",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>14</sup> 7s<sup>2</sup>",
        valenceStates: "II, III",
        electronegativity: 1.3,
        density: "9.9 г/см³ (расчётная)",
        meltingPoint: "827 °C",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1966",
        discoverer: "ОИЯИ (Дубна) — Г. Флёров; Беркли — А. Гиорсо",
        nameOrigin: "В честь Альфреда Нобеля",
        applications: "Только научные исследования",
        facts: "Предпоследний актиноид. Долгое время был предметом спора об открытии между США, Швецией и СССР. В растворах устойчив в степени окисления +2, в отличие от других актиноидов."
    },

    // 103 - Лоуренсий (Lawrencium)
    "Lr": {
        atomicNumber: 103,
        symbol: "Lr",
        name: "Лоуренсий",
        atomicMass: 266,
        period: 7,
        group: 3,
        block: "d",
        category: "Актиноид",
        electronConfig: "[Rn] 5f<sup>14</sup> 7s<sup>2</sup> 7p<sup>1</sup>",
        valenceStates: "III",
        electronegativity: 1.3,
        density: "14.4 г/см³ (расчётная)",
        meltingPoint: "1627 °C",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1961",
        discoverer: "Альберт Гиорсо, Торбьёрн Сиккеланд, Альмон Ларш и Роберт Латимер",
        nameOrigin: "В честь Эрнеста Лоуренса — изобретателя циклотрона",
        applications: "Только научные исследования",
        facts: "Последний актиноид. Его электронная конфигурация (7s²7p¹) отличается от ожидаемой (6d¹), что делает его первым p-элементом 7-го периода, но химически он аналог лютеция. Время жизни ²⁶⁶Lr ~11 часов."
    },

    // 104 - Резерфордий (Rutherfordium)
    "Rf": {
        atomicNumber: 104,
        symbol: "Rf",
        name: "Резерфордий",
        atomicMass: 267,
        period: 7,
        group: 4,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>2</sup> 7s<sup>2</sup>",
        valenceStates: "IV",
        electronegativity: "неизвестна",
        density: "23.2 г/см³ (расчётная)",
        meltingPoint: "2100 °C (расчётная)",
        boilingPoint: "5500 °C (расчётная)",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1964 (Дубна), 1969 (Беркли)",
        discoverer: "ОИЯИ (Г. Флёров) и Беркли (А. Гиорсо)",
        nameOrigin: "В честь Эрнеста Резерфорда",
        applications: "Только научные исследования",
        facts: "Первый трансактиноид. Химический аналог гафния. Долгое время назывался «курчатовием» (Ku) в советской литературе. Период полураспада самого стабильного изотопа ~1.3 часа."
    },

    // 105 - Дубний (Dubnium)
    "Db": {
        atomicNumber: 105,
        symbol: "Db",
        name: "Дубний",
        atomicMass: 268,
        period: 7,
        group: 5,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>3</sup> 7s<sup>2</sup>",
        valenceStates: "V",
        electronegativity: "неизвестна",
        density: "29.3 г/см³ (расчётная)",
        meltingPoint: "неизвестна",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1968 (Дубна), 1970 (Беркли)",
        discoverer: "ОИЯИ (Г. Флёров) и Беркли (А. Гиорсо)",
        nameOrigin: "В честь наукограда Дубны (Россия)",
        applications: "Только научные исследования",
        facts: "В США предлагалось название «ганий» (Ha), в СССР — «нильсборий» (Ns). Окончательное название утверждено только в 1997 году. Аналог тантала. В растворах ведет себя иначе, чем тантал, из-за релятивистских эффектов."
    },

    // 106 - Сиборгий (Seaborgium)
    "Sg": {
        atomicNumber: 106,
        symbol: "Sg",
        name: "Сиборгий",
        atomicMass: 269,
        period: 7,
        group: 6,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>4</sup> 7s<sup>2</sup>",
        valenceStates: "VI",
        electronegativity: "неизвестна",
        density: "35.0 г/см³ (расчётная)",
        meltingPoint: "неизвестна",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1974",
        discoverer: "Беркли (А. Гиорсо) и ОИЯИ (Ю. Оганесян)",
        nameOrigin: "В честь Гленна Сиборга",
        applications: "Только научные исследования",
        facts: "Первый элемент, названный в честь живущего человека (на тот момент). Это вызвало много споров в IUPAC. Аналог вольфрама. Оксид SgO₂Cl₂ — первое летучее соединение 106-го элемента."
    },

    // 107 - Борий (Bohrium)
    "Bh": {
        atomicNumber: 107,
        symbol: "Bh",
        name: "Борий",
        atomicMass: 270,
        period: 7,
        group: 7,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>5</sup> 7s<sup>2</sup>",
        valenceStates: "VII",
        electronegativity: "неизвестна",
        density: "37.1 г/см³ (расчётная)",
        meltingPoint: "неизвестна",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1981",
        discoverer: "GSI (Дармштадт, Германия) — П. Армбрустер и Г. Мюнценберг",
        nameOrigin: "В честь Нильса Бора",
        applications: "Только научные исследования",
        facts: "Аналог рения. Образует летучий оксихлорид BhO₃Cl. Эксперименты с химией бория крайне сложны, так как живут атомы секунды."
    },

    // 108 - Хассий (Hassium)
    "Hs": {
        atomicNumber: 108,
        symbol: "Hs",
        name: "Хассий",
        atomicMass: 277,
        period: 7,
        group: 8,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>6</sup> 7s<sup>2</sup>",
        valenceStates: "VIII",
        electronegativity: "неизвестна",
        density: "41 г/см³ (расчётная)",
        meltingPoint: "неизвестна",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1984",
        discoverer: "GSI (Дармштадт, Германия)",
        nameOrigin: "От лат. Hassia — Гессен (земля в Германии)",
        applications: "Только научные исследования",
        facts: "Ожидается, что это самый плотный элемент (41 г/см³), но измерить это невозможно. Аналог осмия. Образует летучий тетраоксид HsO₄."
    },

    // 109 - Мейтнерий (Meitnerium)
    "Mt": {
        atomicNumber: 109,
        symbol: "Mt",
        name: "Мейтнерий",
        atomicMass: 278,
        period: 7,
        group: 9,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>7</sup> 7s<sup>2</sup>",
        valenceStates: "III",
        electronegativity: "неизвестна",
        density: "37.4 г/см³ (расчётная)",
        meltingPoint: "неизвестна",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1982",
        discoverer: "GSI (Дармштадт, Германия)",
        nameOrigin: "В честь Лизы Мейтнер",
        applications: "Только научные исследования",
        facts: "Назван в честь физика Лизы Мейтнер, соавтора открытия деления урана. Химические свойства почти неизвестны, предполагается аналог иридия."
    },

    // 110 - Дармштадтий (Darmstadtium)
    "Ds": {
        atomicNumber: 110,
        symbol: "Ds",
        name: "Дармштадтий",
        atomicMass: 281,
        period: 7,
        group: 10,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>9</sup> 7s<sup>1</sup>",
        valenceStates: "II",
        electronegativity: "неизвестна",
        density: "34.8 г/см³ (расчётная)",
        meltingPoint: "неизвестна",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый)",
        discoveryYear: "1994",
        discoverer: "GSI (Дармштадт, Германия)",
        nameOrigin: "В честь города Дармштадт",
        applications: "Только научные исследования",
        facts: "Аналог платины. Синтезирован бомбардировкой свинца никелем. Живёт миллисекунды (изотоп ²⁸¹Ds — 11 секунд)."
    },

    // 111 - Рентгений (Roentgenium)
    "Rg": {
        atomicNumber: 111,
        symbol: "Rg",
        name: "Рентгений",
        atomicMass: 282,
        period: 7,
        group: 11,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>1</sup>",
        valenceStates: "I",
        electronegativity: "неизвестна",
        density: "28.7 г/см³ (расчётная)",
        meltingPoint: "неизвестна",
        boilingPoint: "неизвестна",
        state: "Твёрдое",
        color: "Неизвестен (предположительно серебристый или золотистый)",
        discoveryYear: "1994",
        discoverer: "GSI (Дармштадт, Германия)",
        nameOrigin: "В честь Вильгельма Конрада Рентгена",
        applications: "Только научные исследования",
        facts: "Аналог золота. Теоретически может быть благородным металлом, но проверить это сложно. Первоначально имел временное название унунуний (Uuu)."
    },

    // 112 - Коперниций (Copernicium)
    "Cn": {
        atomicNumber: 112,
        symbol: "Cn",
        name: "Коперниций",
        atomicMass: 285,
        period: 7,
        group: 12,
        block: "d",
        category: "Переходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>2</sup>",
        valenceStates: "II",
        electronegativity: "неизвестна",
        density: "23.7 г/см³ (расчётная)",
        meltingPoint: "10 °C (предсказана)",
        boilingPoint: "67 °C (предсказана)",
        state: "Газообразное (предположительно)",
        color: "Неизвестен",
        discoveryYear: "1996",
        discoverer: "GSI (Дармштадт, Германия)",
        nameOrigin: "В честь Николая Коперника",
        applications: "Только научные исследования",
        facts: "Предполагается, что это летучая жидкость или газ при комнатной температуре (из-за релятивистских эффектов). Аналог ртути. Первый атом обнаружен 9 февраля 1996 года в 22:37."
    },

    // 113 - Нихоний (Nihonium)
    "Nh": {
        atomicNumber: 113,
        symbol: "Nh",
        name: "Нихоний",
        atomicMass: 286,
        period: 7,
        group: 13,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>2</sup> 7p<sup>1</sup>",
        valenceStates: "III, I",
        electronegativity: "неизвестна",
        density: "16 г/см³ (расчётная)",
        meltingPoint: "430 °C (предсказана)",
        boilingPoint: "1130 °C (предсказана)",
        state: "Твёрдое",
        color: "Неизвестен",
        discoveryYear: "2003",
        discoverer: "RIKEN (Япония, К. Морита), ОИЯИ и Ливермор",
        nameOrigin: "В честь Японии (Nihon)",
        applications: "Только научные исследования",
        facts: "Первый элемент, открытый в Азии. Официально признан IUPAC в 2015 году. Аналог таллия, но может быть менее реакционноспособным."
    },

    // 114 - Флеровий (Flerovium)
    "Fl": {
        atomicNumber: 114,
        symbol: "Fl",
        name: "Флеровий",
        atomicMass: 289,
        period: 7,
        group: 14,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>2</sup> 7p<sup>2</sup>",
        valenceStates: "IV, II",
        electronegativity: "неизвестна",
        density: "14 г/см³ (расчётная)",
        meltingPoint: "70 °C (предсказана)",
        boilingPoint: "150 °C (предсказана)",
        state: "Твёрдое (возможно газ)",
        color: "Неизвестен",
        discoveryYear: "1998",
        discoverer: "ОИЯИ (Дубна) и Ливерморская лаборатория",
        nameOrigin: "В честь Лаборатории ядерных реакций им. Г.Н. Флёрова",
        applications: "Только научные исследования",
        facts: "Находится на «острове стабильности» — ожидается, что его изотопы могут жить дольше других сверхтяжёлых. Химически может вести себя как благородный газ, а не как свинец."
    },

    // 115 - Московий (Moscovium)
    "Mc": {
        atomicNumber: 115,
        symbol: "Mc",
        name: "Московий",
        atomicMass: 290,
        period: 7,
        group: 15,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>2</sup> 7p<sup>3</sup>",
        valenceStates: "V, III, I",
        electronegativity: "неизвестна",
        density: "13.5 г/см³ (расчётная)",
        meltingPoint: "400 °C (предсказана)",
        boilingPoint: "1100 °C (предсказана)",
        state: "Твёрдое",
        color: "Неизвестен",
        discoveryYear: "2003",
        discoverer: "ОИЯИ (Дубна) и Ливерморская лаборатория",
        nameOrigin: "В честь Московской области",
        applications: "Только научные исследования",
        facts: "Аналог висмута. Очень короткоживущий (T₁/₂ ~0.65 сек). В поп-культуре «Элемент 115» часто упоминается в связи с НЛО и антигравитацией (лазариум), но в реальности он крайне нестабилен."
    },

    // 116 - Ливерморий (Livermorium)
    "Lv": {
        atomicNumber: 116,
        symbol: "Lv",
        name: "Ливерморий",
        atomicMass: 293,
        period: 7,
        group: 16,
        block: "p",
        category: "Постпереходный металл",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>2</sup> 7p<sup>4</sup>",
        valenceStates: "VI, IV, II",
        electronegativity: "неизвестна",
        density: "12.9 г/см³ (расчётная)",
        meltingPoint: "364–507 °C (предсказана)",
        boilingPoint: "762–862 °C (предсказана)",
        state: "Твёрдое",
        color: "Неизвестен",
        discoveryYear: "2000",
        discoverer: "ОИЯИ (Дубна) и Ливерморская лаборатория",
        nameOrigin: "В честь Ливерморской национальной лаборатории (США)",
        applications: "Только научные исследования",
        facts: "Аналог полония. Получен путем слияния ядер кальция-48 и кюрия-248. Всего зарегистрировано несколько десятков атомов этого элемента."
    },

    // 117 - Теннессин (Tennessine)
    "Ts": {
        atomicNumber: 117,
        symbol: "Ts",
        name: "Теннессин",
        atomicMass: 294,
        period: 7,
        group: 17,
        block: "p",
        category: "Галоген",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>2</sup> 7p<sup>5</sup>",
        valenceStates: "VII, V, III, I",
        electronegativity: "неизвестна",
        density: "7.1–7.3 г/см³ (расчётная)",
        meltingPoint: "350–550 °C (предсказана)",
        boilingPoint: "610 °C (предсказана)",
        state: "Твёрдое (предположительно)",
        color: "Неизвестен (возможно тёмный металл)",
        discoveryYear: "2010",
        discoverer: "ОИЯИ (Дубна), Ок-Ридж, Ливермор, Вандербильт",
        nameOrigin: "В честь штата Теннесси (США)",
        applications: "Только научные исследования",
        facts: "Аналог астата, но вряд ли проявляет свойства галогенов. Второй искусственный элемент (после калифорния), названный в честь штата США. Для его синтеза нужен был редчайший берклий-249."
    },

    // 118 - Оганесон (Oganesson)
    "Og": {
        atomicNumber: 118,
        symbol: "Og",
        name: "Оганесон",
        atomicMass: 294,
        period: 7,
        group: 18,
        block: "p",
        category: "Благородный газ",
        electronConfig: "[Rn] 5f<sup>14</sup> 6d<sup>10</sup> 7s<sup>2</sup> 7p<sup>6</sup>",
        valenceStates: "0",
        electronegativity: "неизвестна",
        density: "4.9–5.1 г/см³ (тв., расчётная)",
        meltingPoint: "50–80 °C (предсказана)",
        boilingPoint: "80 ± 30 °C (предсказана)",
        state: "Твёрдое (предположительно)",
        color: "Неизвестен",
        discoveryYear: "2002",
        discoverer: "ОИЯИ (Дубна) и Ливерморская лаборатория",
        nameOrigin: "В честь Юрия Цолаковича Оганесяна",
        applications: "Только научные исследования",
        facts: "Единственный элемент, названный в честь живущего человека, который это застал (Сиборг умер до официального утверждения). Расчёт показывает, что это не газ, а твердое вещество при 20°C из-за релятивистских эффектов. Завершает 7-й период."
    }
};



============================================================
ФАЙЛ: .\js\icons.js
============================================================

// SVG Спрайт иконок (автоматически сгенерирован из icons/*.svg)
const iconsSVG = `
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
    <symbol id="icon-calc" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="4" y="2" width="16" height="20" rx="2"/>
            <rect x="8" y="6" width="8" height="4" rx="1"/>
            <circle cx="8" cy="14" r="1" fill="currentColor" stroke="none"/>
            <circle cx="12" cy="14" r="1" fill="currentColor" stroke="none"/>
            <circle cx="16" cy="14" r="1" fill="currentColor" stroke="none"/>
            <circle cx="8" cy="18" r="1" fill="currentColor" stroke="none"/>
            <circle cx="12" cy="18" r="1" fill="currentColor" stroke="none"/>
            <circle cx="16" cy="18" r="1" fill="currentColor" stroke="none"/>
    </symbol>

    <symbol id="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="4"/>
            <path d="M12 2v2"/>
            <path d="M12 20v2"/>
            <path d="M4.93 4.93l1.41 1.41"/>
            <path d="M17.66 17.66l1.41 1.41"/>
            <path d="M2 12h2"/>
            <path d="M20 12h2"/>
            <path d="M6.34 17.66l-1.41 1.41"/>
            <path d="M19.07 4.93l-1.41 1.41"/>
    </symbol>

    <symbol id="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
    </symbol>

    <symbol id="icon-particles" viewBox="0 0 24 24" fill="currentColor" stroke="none">
        <circle cx="12" cy="12" r="2.5"/>
            <circle cx="6" cy="6" r="1.5"/>
            <circle cx="18" cy="7" r="2"/>
            <circle cx="17" cy="17" r="1.5"/>
            <circle cx="7" cy="17" r="2"/>
            <circle cx="4" cy="12" r="1"/>
            <circle cx="20" cy="12" r="1"/>
            <circle cx="12" cy="4" r="1"/>
            <circle cx="12" cy="20" r="1.5"/>
    </symbol>

    <symbol id="icon-menu" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="4" y1="6" x2="20" y2="6"/>
            <line x1="4" y1="12" x2="20" y2="12"/>
            <line x1="4" y1="18" x2="20" y2="18"/>
    </symbol>

    <symbol id="icon-close" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.85" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"/>
            <line x1="6" y1="6" x2="18" y2="18"/>
    </symbol>

    <symbol id="icon-filter" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
    </symbol>

    <symbol id="icon-search" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.85" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="7.5"/>
            <path d="M20.5 20.5 16 16"/>
    </symbol>

    <symbol id="icon-palette" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.85" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 21a9 9 0 1 1 8.7-11.2 2.8 2.8 0 0 1-2.7 3.5h-1.8a1.9 1.9 0 0 0 0 3.8h.4a2.6 2.6 0 0 1 0 5.2H12z"/>
            <circle cx="7.8" cy="10.4" r="1"/>
            <circle cx="10.7" cy="7.6" r="1"/>
            <circle cx="14.8" cy="7.9" r="1"/>
            <circle cx="16.6" cy="11.6" r="1"/>
    </symbol>

    <symbol id="icon-bolt" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.85" stroke-linecap="round" stroke-linejoin="round">
        <path d="M13 2 3 14h8l-1 8 11-12h-8z"/>
    </symbol>

    <symbol id="icon-info" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.85" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="9"/>
            <line x1="12" y1="16" x2="12" y2="11.5"/>
            <circle cx="12" cy="8.2" r="0.9" fill="currentColor" stroke="none"/>
    </symbol>

</svg>
`;

// Вставляем в начало body
document.body.insertAdjacentHTML('afterbegin', iconsSVG);


============================================================
ФАЙЛ: .\js\init.js
============================================================

// =========================================
// INIT.JS — Централизованная инициализация всех модулей
// =========================================

// Ждем, пока DOM будет полностью загружен
document.addEventListener('DOMContentLoaded', async function() {
    console.log('Starting application initialization...');

    // Регистрируем все модули для инициализации
    if (window.ChemLoader) {
        // Регистрация модуля скроллколапса
        window.ChemLoader.registerModule('Scroll Collapse', async function() {
            await new Promise(resolve => setTimeout(resolve, 150));
            // Пытаемся вызвать init() если она существует в scroll-collapse.js
            if (typeof init === 'function') {
                init();
            }
            console.log('Scroll collapse module initialized');
        });

        // Регистрация других модулей приложения
        // Добавьте другие модули по мере необходимости

        // Запускаем инициализацию всех зарегистрированных модулей
        console.log('Starting modules initialization...');
        await window.ChemLoader.initializeModules();
        console.log('All modules initialized');
    } else {
        console.warn('ChemLoader not available, initializing modules directly...');
        // Если лоадер недоступен, инициализируем модули напрямую
        if (typeof init === 'function') {
            setTimeout(init, 150);
        }
    }
});

// Также добавим возможность ручной инициализации
window.manualInit = async function() {
    if (window.ChemLoader) {
        await window.ChemLoader.initializeModules();
    }
};

// Функция для показа лоадера при работе с модулями
window.showLoadingForModule = function(moduleName, action) {
    return new Promise(async (resolve) => {
        if (window.ChemLoader) {
            // Показываем лоадер с сообщением
            window.ChemLoader.updateProgress(0);

            // Выполняем действие
            const result = await action();

            // Через некоторое время скрываем лоадер
            setTimeout(() => {
                if (window.ChemLoader) {
                    window.ChemLoader.hide();
                }
                resolve(result);
            }, 500);
        } else {
            // Если лоадер недоступен, просто выполняем действие
            const result = await action();
            resolve(result);
        }
    });
};

// Функция для инициализации фильтров с показом лоадера
window.initializeSolubilityFilters = function() {
    return window.showLoadingForModule('Solubility Filters', async () => {
        console.log('initializeSolubilityFilters: Starting with window.isColorMode:', window.isColorMode);
        // Небольшая задержка для уверенности, что DOM готов
        await new Promise(resolve => setTimeout(resolve, 100));
        // Инициализация фильтров
        if (typeof updateFiltersForSolubility === 'function') {
            console.log('initializeSolubilityFilters: About to call updateFiltersForSolubility, window.isColorMode:', window.isColorMode);
            updateFiltersForSolubility();
            console.log('Solubility filters module initialized');
        } else {
            console.error('updateFiltersForSolubility function not found in initializeSolubilityFilters');
        }
        return true;
    });
};

============================================================
ФАЙЛ: .\js\loader.js
============================================================

// =========================================
// LOADER.JS — Анимация загрузки с химическими формулами
// =========================================

(function () {
    'use strict';

    // === БАЗА ФОРМУЛ ===
    // Из таблицы растворимости + известные вещества
    const chemicalFormulas = [
        // Кислоты
        { formula: 'H₂SO₄', name: 'Серная кислота' },
        { formula: 'HNO₃', name: 'Азотная кислота' },
        { formula: 'HCl', name: 'Соляная кислота' },
        { formula: 'H₃PO₄', name: 'Фосфорная кислота' },
        { formula: 'H₂CO₃', name: 'Угольная кислота' },
        { formula: 'CH₃COOH', name: 'Уксусная кислота' },
        { formula: 'HF', name: 'Плавиковая кислота' },
        { formula: 'HBr', name: 'Бромоводородная' },
        { formula: 'H₂S', name: 'Сероводород' },
        { formula: 'HCN', name: 'Синильная кислота' },

        // Основания
        { formula: 'NaOH', name: 'Едкий натр' },
        { formula: 'KOH', name: 'Едкое кали' },
        { formula: 'Ca(OH)₂', name: 'Гашёная известь' },
        { formula: 'Ba(OH)₂', name: 'Баритовая вода' },
        { formula: 'Al(OH)₃', name: 'Гидроксид алюминия' },
        { formula: 'Fe(OH)₃', name: 'Ржавчина' },
        { formula: 'Cu(OH)₂', name: 'Гидроксид меди' },
        { formula: 'Mg(OH)₂', name: 'Молоко магнезии' },
        { formula: 'Zn(OH)₂', name: 'Гидроксид цинка' },
        { formula: 'NH₄OH', name: 'Нашатырный спирт' },

        // Соли — хлориды
        { formula: 'NaCl', name: 'Поваренная соль' },
        { formula: 'KCl', name: 'Хлорид калия' },
        { formula: 'CaCl₂', name: 'Хлорид кальция' },
        { formula: 'MgCl₂', name: 'Бишофит' },
        { formula: 'FeCl₃', name: 'Хлорид железа' },
        { formula: 'AlCl₃', name: 'Хлорид алюминия' },
        { formula: 'ZnCl₂', name: 'Хлорид цинка' },
        { formula: 'AgCl', name: 'Хлорид серебра' },
        { formula: 'NH₄Cl', name: 'Нашатырь' },

        // Соли — сульфаты
        { formula: 'CuSO₄', name: 'Медный купорос' },
        { formula: 'FeSO₄', name: 'Железный купорос' },
        { formula: 'ZnSO₄', name: 'Цинковый купорос' },
        { formula: 'MgSO₄', name: 'Английская соль' },
        { formula: 'BaSO₄', name: 'Барит' },
        { formula: 'CaSO₄', name: 'Гипс' },
        { formula: 'Na₂SO₄', name: 'Глауберова соль' },
        { formula: 'K₂SO₄', name: 'Сульфат калия' },
        { formula: 'Al₂(SO₄)₃', name: 'Сульфат алюминия' },

        // Соли — нитраты
        { formula: 'KNO₃', name: 'Калийная селитра' },
        { formula: 'NaNO₃', name: 'Чилийская селитра' },
        { formula: 'AgNO₃', name: 'Ляпис' },
        { formula: 'Ca(NO₃)₂', name: 'Кальциевая селитра' },
        { formula: 'Pb(NO₃)₂', name: 'Нитрат свинца' },
        { formula: 'Cu(NO₃)₂', name: 'Нитрат меди' },
        { formula: 'Fe(NO₃)₃', name: 'Нитрат железа' },
        { formula: 'NH₃NO₃', name: 'Аммиачная селитра' },

        // Соли — карбонаты
        { formula: 'CaCO₃', name: 'Мел' },
        { formula: 'Na₂CO₃', name: 'Кальцинированная сода' },
        { formula: 'NaHCO₃', name: 'Пищевая сода' },
        { formula: 'K₂CO₃', name: 'Поташ' },
        { formula: 'MgCO₃', name: 'Магнезит' },
        { formula: 'BaCO₃', name: 'Витерит' },
        { formula: 'PbCO₃', name: 'Церуссит' },
        { formula: 'ZnCO₃', name: 'Смитсонит' },

        // Соли — другие
        { formula: 'KMnO₄', name: 'Марганцовка' },
        { formula: 'K₂Cr₂O₇', name: 'Хромпик' },
        { formula: 'K₂CrO₄', name: 'Хромат калия' },
        { formula: 'Na₂S', name: 'Сульфид натрия' },
        { formula: 'FeS', name: 'Пирит' },
        { formula: 'CuS', name: 'Ковеллин' },
        { formula: 'PbS', name: 'Галенит' },
        { formula: 'ZnS', name: 'Сфалерит' },
        { formula: 'Ag₂S', name: 'Аргентит' },
        { formula: 'Na₃PO₄', name: 'Фосфат натрия' },
        { formula: 'Ca₃(PO₄)₂', name: 'Фосфорит' },

        // Оксиды
        { formula: 'H₂O', name: 'Вода' },
        { formula: 'CO₂', name: 'Углекислый газ' },
        { formula: 'SO₂', name: 'Сернистый газ' },
        { formula: 'SO₃', name: 'Серный ангидрид' },
        { formula: 'NO₂', name: 'Бурый газ' },
        { formula: 'N₂O', name: 'Веселящий газ' },
        { formula: 'CO', name: 'Угарный газ' },
        { formula: 'Fe₂O₃', name: 'Гематит' },
        { formula: 'Fe₃O₄', name: 'Магнетит' },
        { formula: 'Al₂O₃', name: 'Корунд' },
        { formula: 'SiO₂', name: 'Кварц' },
        { formula: 'CaO', name: 'Негашёная известь' },
        { formula: 'MgO', name: 'Жжёная магнезия' },
        { formula: 'ZnO', name: 'Цинковые белила' },
        { formula: 'CuO', name: 'Оксид меди' },
        { formula: 'TiO₂', name: 'Титановые белила' },

        // Органика
        { formula: 'C₂H₅OH', name: 'Этиловый спирт' },
        { formula: 'CH₃OH', name: 'Метиловый спирт' },
        { formula: 'C₆H₁₂O₆', name: 'Глюкоза' },
        { formula: 'C₁₂H₂₂O₁₁', name: 'Сахароза' },
        { formula: 'CH₄', name: 'Метан' },
        { formula: 'C₂H₆', name: 'Этан' },
        { formula: 'C₃H₈', name: 'Пропан' },
        { formula: 'C₂H₄', name: 'Этилен' },
        { formula: 'C₂H₂', name: 'Ацетилен' },
        { formula: 'C₆H₆', name: 'Бензол' },
        { formula: 'C₆H₅OH', name: 'Фенол' },
        { formula: 'HCHO', name: 'Формальдегид' },
        { formula: 'CH₃CHO', name: 'Ацетальдегид' },
        { formula: '(CH₃)₂CO', name: 'Ацетон' },

        // Газы
        { formula: 'NH₃', name: 'Аммиак' },
        { formula: 'Cl₂', name: 'Хлор' },
        { formula: 'O₃', name: 'Озон' },
        { formula: 'H₂', name: 'Водород' },
        { formula: 'O₂', name: 'Кислород' },
        { formula: 'N₂', name: 'Азот' },
    ];

    // === ПЕРЕМЕННЫЕ ===
    let currentFormulaIndex = 0;
    let formulaInterval = null;
    let progressValue = 0;
    let isLoaderActive = true;

    // === СОЗДАНИЕ HTML СТРУКТУРЫ ===
    function createLoaderHTML() {
        const loader = document.createElement('div');
        loader.id = 'loading-screen';

        loader.innerHTML = `
            <!-- Частицы фона -->
            <div class="loader-particles" id="loader-particles"></div>
            
            <!-- Формула -->
            <div class="formula-container">
                <div class="loader-orbits">
                    <div class="orbit-ring orbit-ring-1"><div class="orbit-dot"></div></div>
                    <div class="orbit-ring orbit-ring-2"><div class="orbit-dot"></div></div>
                    <div class="orbit-ring orbit-ring-3"><div class="orbit-dot"></div></div>
                </div>
                
                <div class="formula-box">
                    <div class="formula-text formula-typing" id="formula-display"></div>
                </div>
                <div class="formula-name" id="formula-name"></div>
            </div>
            
            <!-- Прогресс -->
            <div class="loader-progress-section">
                <div class="loader-progress-bar">
                    <div class="loader-progress-fill" id="loader-progress-fill"></div>
                </div>
                <div class="loader-progress-text">Загрузка модулей</div>
                <div class="loader-progress-percent" id="loader-progress-percent">0%</div>
            </div>
        `;

        document.body.insertBefore(loader, document.body.firstChild);

        // Создаём частицы
        createParticles();

        // Показываем первую формулу
        showRandomFormula();

        // Запускаем смену формул
        startFormulaRotation();
    }

    // === СОЗДАНИЕ ЧАСТИЦ ===
    function createParticles() {
        const container = document.getElementById('loader-particles');
        if (!container) return;

        const particleCount = window.innerWidth < 600 ? 15 : 30;

        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'loader-particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (10 + Math.random() * 10) + 's';
            particle.style.width = particle.style.height = (2 + Math.random() * 4) + 'px';
            container.appendChild(particle);
        }
    }

    // === ПОКАЗАТЬ СЛУЧАЙНУЮ ФОРМУЛУ ===
    function showRandomFormula() {
        const formulaEl = document.getElementById('formula-display');
        const nameEl = document.getElementById('formula-name');

        if (!formulaEl || !nameEl) return;

        // Выбираем случайную формулу
        const randomIndex = Math.floor(Math.random() * chemicalFormulas.length);
        const compound = chemicalFormulas[randomIndex];

        // Сбрасываем анимацию
        formulaEl.style.animation = 'none';
        nameEl.style.animation = 'none';

        // Форсируем reflow
        void formulaEl.offsetWidth;
        void nameEl.offsetWidth;

        // Устанавливаем формулу
        formulaEl.textContent = compound.formula;
        nameEl.textContent = compound.name;

        // Вычисляем длительность печати (50мс на символ)
        const charCount = compound.formula.length;
        const typingDuration = Math.max(0.8, charCount * 0.08);

        // Устанавливаем CSS переменные
        formulaEl.style.setProperty('--chars', charCount);
        formulaEl.style.setProperty('--typing-duration', typingDuration + 's');

        // Запускаем анимации
        formulaEl.style.animation = `
            loader-typing ${typingDuration}s steps(${charCount}, end) forwards,
            loader-blink 0.7s step-end infinite,
            gradient-shift 3s linear infinite
        `;
        nameEl.style.animation = `loader-fade-in 0.5s ease-out ${typingDuration * 0.7}s forwards`;
    }

    // === РОТАЦИЯ ФОРМУЛ ===
    function startFormulaRotation() {
        formulaInterval = setInterval(() => {
            if (isLoaderActive) {
                showRandomFormula();
            }
        }, 3000);
    }

    // === ОБНОВЛЕНИЕ ПРОГРЕССА ===
    function updateProgress(percent) {
        const fill = document.getElementById('loader-progress-fill');
        const text = document.getElementById('loader-progress-percent');

        progressValue = Math.min(100, Math.max(0, percent));

        if (fill) fill.style.width = progressValue + '%';
        if (text) text.textContent = Math.round(progressValue) + '%';
    }

    // === СКРЫТИЕ ЛОАДЕРА ===
    function hideLoader() {
        isLoaderActive = false;

        if (formulaInterval) {
            clearInterval(formulaInterval);
            formulaInterval = null;
        }

        const loader = document.getElementById('loading-screen');
        if (!loader) return;

        // Устанавливаем 100%
        updateProgress(100);

        // Анимация исчезновения
        setTimeout(() => {
            loader.classList.add('fade-out');

            setTimeout(() => {
                loader.classList.add('hidden');
                // Можно удалить элемент для экономии памяти
                // loader.remove();
            }, 500);
        }, 300);
    }

    // === СИСТЕМА ИНИЦИАЛИЗАЦИИ МОДУЛЕЙ ===
    const modulesQueue = [];
    let initializedModules = 0;
    let totalModules = 0;

    // Функция для регистрации модуля
    function registerModule(name, initFunction) {
        modulesQueue.push({ name, initFunction });
        totalModules++;
        updateProgress(0); // Обновляем прогресс
    }

    // Функция для инициализации модулей
    function showLoader() {
        const loader = document.getElementById('loading-screen');
        if (!loader) return;

        loader.classList.remove('hidden', 'fade-out');
        loader.style.display = 'flex'; // Гарантируем отображение
        isLoaderActive = true;

        // Сбрасываем прогресс
        updateProgress(0);
        const progressText = document.querySelector('.loader-progress-text');
        if (progressText) progressText.textContent = 'Генерация...';

        // Запускаем анимацию, если она остановлена
        if (!formulaInterval) {
            showRandomFormula();
            startFormulaRotation();
        }
    }

    async function initializeModules() {
        if (modulesQueue.length === 0) {
            // Если нет зарегистрированных модулей, просто скрываем лоадер
            setTimeout(hideLoader, 500);
            return;
        }

        for (const module of modulesQueue) {
            try {
                console.log(`Initializing module: ${module.name}`);
                await module.initFunction();
                initializedModules++;

                // Обновляем прогресс
                const progress = (initializedModules / totalModules) * 100;
                updateProgress(progress);

                console.log(`${module.name} initialized successfully`);
            } catch (error) {
                console.error(`Error initializing module ${module.name}:`, error);
            }
        }

        // Скрываем лоадер после инициализации всех модулей
        setTimeout(hideLoader, 500);
    }

    // === ЭКСПОРТ ФУНКЦИЙ ===
    window.ChemLoader = {
        updateProgress: updateProgress,
        hide: hideLoader,
        show: showLoader,
        showFormula: showRandomFormula,
        registerModule: registerModule,
        initializeModules: initializeModules
    };

    // === ИНИЦИАЛИЗАЦИЯ ===
    // Создаём лоадер сразу при загрузке скрипта
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createLoaderHTML);
    } else {
        createLoaderHTML();
    }

})();


============================================================
ФАЙЛ: .\js\particles.js
============================================================

const canvas = document.getElementById('particles-canvas');
const ctx = canvas.getContext('2d');

let particlesArray = [];
let specificAtomsArray = [];

// Настройки
let particlesCount = window.innerWidth < 768 ? 15 : 80;
let atomsCount = window.innerWidth < 768 ? 10 : 25;
let connectionDistance = 120;
let mouseRadius = 120;
let mouseRadiusRepel = 90;
let mouseForce = 0.6;
let interactionMode = 'repel';
let maxVelocity = 1.4;
let damping = 0.98;
let separationRadius = 22;
let separationStrength = 0.2;
let separationMaxImpulse = 1.1;
let collisionKillDistance = 3.2;
let collisionKillChanceBase = 0.14;

let wave = { active: false, x: 0, y: 0, radius: 0, maxRadius: 0, toDark: false, ending: false, endTime: 0 };
let mouse = { x: 0, y: 0, active: false };
let spawnBurstCount = 2;

// Wallpaper mode settings
let wallpaperMode = false;
let fpsCap = 60;
let lastFrameTime = 0;
const frameInterval = 1000 / 60; // Default 60 FPS

// === Инициализация ===
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    updateInteractionSettings();
    initParticles();
    if (specificAtomsArray.length > 0) {
        const lastAtom = specificAtomsArray[0];
        window.spawnAtom(lastAtom.atomicNumber, lastAtom.period);
    }
});

// === Глобальные функции ===

window.startParticleWave = function(x, y, isToDark) {
    wave.active = true;
    wave.ending = false; // Сбрасываем флаг завершения
    wave.x = x;
    wave.y = y;
    wave.radius = 0;
    wave.toDark = isToDark;
    wave.maxRadius = Math.hypot(canvas.width, canvas.height) + 100;
};

window.spawnAtom = function(atomicNumber, period) {
    setTimeout(() => {
        createSpecificAtoms(atomicNumber, period);
    }, 50);
};

window.clearAtom = function() {
    specificAtomsArray = [];
};

/**
 * Enable/disable wallpaper mode optimizations
 * Reduces FPS to save resources when running as desktop wallpaper
 */
window.setWallpaperMode = function(enabled) {
    wallpaperMode = enabled;

    if (enabled) {
        fpsCap = 30; // Reduce to 30 FPS for wallpaper mode
        console.log('[Particles] Wallpaper mode enabled: FPS capped at 30');
    } else {
        fpsCap = 60;
        console.log('[Particles] Wallpaper mode disabled: FPS restored to 60');
    }
};

// Also expose via particleSystem for compatibility
window.particleSystem = {
    setWallpaperMode: window.setWallpaperMode
};

function updateInteractionSettings() {
    const isMobile = window.innerWidth < 768;
    mouseRadius = isMobile ? 80 : 120;
    mouseRadiusRepel = isMobile ? 55 : 90;
    mouseForce = isMobile ? 0.35 : 0.6;
}

function updateMousePosition(x, y) {
    mouse.x = x;
    mouse.y = y;
    mouse.active = true;
}

window.addEventListener('mousemove', (event) => {
    updateMousePosition(event.clientX, event.clientY);
});

window.addEventListener('mouseleave', () => {
    mouse.active = false;
});

window.addEventListener('touchmove', (event) => {
    if (!event.touches || event.touches.length === 0) return;
    const touch = event.touches[0];
    updateMousePosition(touch.clientX, touch.clientY);
}, { passive: true });

window.addEventListener('touchend', () => {
    mouse.active = false;
});

function isClickOnUi(target) {
    if (!target) return false;
    return Boolean(target.closest(
        '.element, .modal, .modal-content, .electron-config-content, .advanced-modal-content, ' +
        '.below-table-content, .fab, .fab-option, .chem-toggle, #theme-toggle, button, a, input, textarea, select, label'
    ));
}

function spawnParticlesAt(x, y, count) {
    if (specificAtomsArray.length > 0) return;
    const spawnCount = Math.max(1, count || spawnBurstCount);
    for (let i = 0; i < spawnCount; i++) {
        const particle = new Particle(x, y);
        particlesArray.push(particle);
    }
    if (particlesArray.length > particlesCount * 3) {
        particlesArray.splice(0, particlesArray.length - particlesCount * 3);
    }
}

window.addEventListener('mousedown', (event) => {
    if (event.button !== 0) return;
    if (isClickOnUi(event.target)) return;
    spawnParticlesAt(event.clientX, event.clientY, spawnBurstCount);
});

function applyMouseInteraction(particle) {
    if (!mouse.active) return;

    const dx = particle.x - mouse.x;
    const dy = particle.y - mouse.y;
    const distanceSq = dx * dx + dy * dy;
    const activeRadius = interactionMode === 'repel' ? mouseRadiusRepel : mouseRadius;
    const radiusSq = activeRadius * activeRadius;

    if (distanceSq === 0 || distanceSq > radiusSq) return;

    const distance = Math.sqrt(distanceSq);
    const strength = mouseForce * (1 - distance / activeRadius);
    let forceX = 0;
    let forceY = 0;

    if (interactionMode === 'attract') {
        forceX = (-dx / distance) * strength;
        forceY = (-dy / distance) * strength;
    } else if (interactionMode === 'vortex') {
        forceX = (-dy / distance) * strength;
        forceY = (dx / distance) * strength;
    } else {
        forceX = (dx / distance) * strength;
        forceY = (dy / distance) * strength;
    }

    particle.directionX += forceX;
    particle.directionY += forceY;
}

function createSpecificAtoms(atomicNumber, period) {
    specificAtomsArray = [];

    const modalContent = document.querySelector('.modal-content');
    let spawnArea = { x: 0, y: 0, w: canvas.width, h: canvas.height };

    if (modalContent && window.getComputedStyle(modalContent).display !== 'none' && window.innerWidth > 1024) {
        const rect = modalContent.getBoundingClientRect();
        const spaceLeft = rect.left;
        const spaceRight = canvas.width - rect.right;

        if (spaceRight > spaceLeft) {
            spawnArea = { x: rect.right, y: 0, w: spaceRight, h: canvas.height };
        } else {
            spawnArea = { x: 0, y: 0, w: spaceLeft, h: canvas.height };
        }
    }

    for (let i = 0; i < atomsCount; i++) {
        specificAtomsArray.push(new SpecificAtom(atomicNumber, period, spawnArea));
    }
}

// === Классы ===

// Класс сложного атома (Элемент)
class SpecificAtom {
    constructor(atomicNumber, period, area) {
        this.atomicNumber = parseInt(atomicNumber);
        this.period = parseInt(period);

        // Позиция
        this.x = area.x + Math.random() * area.w;
        this.y = area.y + Math.random() * area.h;
        this.bounds = area;

        // Медленный дрейф
        this.directionX = (Math.random() * 0.3) - 0.15;
        this.directionY = (Math.random() * 0.3) - 0.15;

        this.scale = window.innerWidth < 768 ? 0.8 : 1.3;
        this.baseRadius = 18 * this.scale;
        this.gap = 10 * this.scale;

        // === РАСЧЕТ ЭЛЕКТРОНОВ ПО ОБОЛОЧКАМ ===
        this.shellElectronCounts = [];
        let electronsLeft = this.atomicNumber;

        for (let i = 1; i <= this.period; i++) {
            let capacity = 2 * i * i; // Максимум по формуле 2n²
            let count = 0;

            if (i === this.period) {
                // Последний слой забирает всё, что осталось
                count = electronsLeft;
            } else {
                // Внутренние слои
                count = Math.min(electronsLeft, capacity);

                // Визуальная коррекция для K, Ca и т.д. (правило октета для предпоследнего слоя)
                // Если это предпоследний слой и он может вместить больше 8, но мы не хотим перегружать
                // (обычно предпоследний слой держит 8 перед тем как заполняется следующий s-подуровень)
                if (i === this.period - 1 && capacity > 8) {
                    count = 8;
                }
            }

            // Если вдруг логика дала сбой (transition metals сложнее), берем минимум
            if (count > electronsLeft) count = electronsLeft;

            this.shellElectronCounts.push(count);
            electronsLeft -= count;
        }
    }

    update() {
        if (this.x > this.bounds.x + this.bounds.w || this.x < this.bounds.x) this.directionX = -this.directionX;
        if (this.y > this.bounds.y + this.bounds.h || this.y < this.bounds.y) this.directionY = -this.directionY;
        this.x += this.directionX;
        this.y += this.directionY;
    }

    draw() {
        const nucleusSize = 4 * this.scale;
        ctx.beginPath();
        ctx.arc(this.x, this.y, nucleusSize, 0, Math.PI * 2);

        const isDark = document.body.classList.contains('dark-theme');
        ctx.fillStyle = isDark ? '#ff4081' : '#d32f2f';
        ctx.fill();

        const orbitColor = isDark ? 'rgba(255, 255, 255, 0.4)' : 'rgba(0, 0, 0, 0.4)';
        const electronColor = isDark ? '#00e5ff' : '#1976D2';

        // Рисуем орбиты
        for (let i = 1; i <= this.period; i++) {
            const radius = this.baseRadius + (i * this.gap);
            const rotationAngle = (Math.PI / this.period) * i + this.x;

            ctx.beginPath();
            ctx.ellipse(this.x, this.y, radius, radius * 0.6, rotationAngle, 0, Math.PI * 2);
            ctx.strokeStyle = orbitColor;
            ctx.lineWidth = 1;
            ctx.stroke();

            // === РИСУЕМ ПРАВИЛЬНОЕ КОЛИЧЕСТВО ЭЛЕКТРОНОВ ===
            // Берем число из заранее рассчитанного массива
            // (i-1 потому что массив с 0, а слои с 1)
            let electrons = this.shellElectronCounts[i - 1] || 0;

            const time = Date.now() * 0.0005;

            for (let e = 0; e < electrons; e++) {
                const offset = (Math.PI * 2 / electrons) * e;
                const angle = (time * (3/i)) + offset;

                let ex = radius * Math.cos(angle);
                let ey = (radius * 0.6) * Math.sin(angle);

                let rotX = ex * Math.cos(rotationAngle) - ey * Math.sin(rotationAngle);
                let rotY = ex * Math.sin(rotationAngle) + ey * Math.cos(rotationAngle);

                ctx.beginPath();
                ctx.arc(this.x + rotX, this.y + rotY, 2 * this.scale, 0, Math.PI * 2);
                ctx.fillStyle = electronColor;
                ctx.fill();
            }
        }
    }
}

// Класс обычной точки (Фон)
class Particle {
    constructor(x, y) {
        this.x = typeof x === 'number' ? x : Math.random() * canvas.width;
        this.y = typeof y === 'number' ? y : Math.random() * canvas.height;
        this.directionX = (Math.random() * 0.4) - 0.2;
        this.directionY = (Math.random() * 0.4) - 0.2;
        this.size = Math.random() * 2 + 1;
    }

    update() {
        applyMouseInteraction(this);

        this.directionX *= damping;
        this.directionY *= damping;

        const speed = Math.hypot(this.directionX, this.directionY);
        if (speed > maxVelocity) {
            const scale = maxVelocity / speed;
            this.directionX *= scale;
            this.directionY *= scale;
        }

        if (speed < 0.05) {
            this.directionX += (Math.random() * 0.04) - 0.02;
            this.directionY += (Math.random() * 0.04) - 0.02;
        }

        if (this.x > canvas.width || this.x < 0) this.directionX = -this.directionX;
        if (this.y > canvas.height || this.y < 0) this.directionY = -this.directionY;
        this.x += this.directionX;
        this.y += this.directionY;
    }

    getColor() {
        const colorLight = 'rgba(0, 0, 0, 0.3)';
        const colorDark = 'rgba(255, 255, 255, 0.5)';

        // Если волна активна, используем цвета волны
        if (wave.active) {
            const dx = this.x - wave.x;
            const dy = this.y - wave.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const insideWave = dist < wave.radius;
            return (wave.toDark === insideWave) ? colorDark : colorLight;
        } else {
            // Если волна закончилась, возвращаем цвет в зависимости от темы
            return document.body.classList.contains('dark-theme') ? colorDark : colorLight;
        }
    }

    // Метод для принудительного обновления цвета
    updateColor() {
        // В данном случае, поскольку цвет зависит от состояния DOM,
        // нам просто нужно перерисовать частицу
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = this.getColor();
        ctx.fill();
    }
}

function overcrowdKillThreshold() {
    return Math.max(160, particlesCount * 2.5);
}

function applyParticleSeparationAndCull() {
    const count = particlesArray.length;
    if (count < 2) return;

    const cellSize = separationRadius;
    const grid = new Map();
    const toRemove = new Set();

    const killThreshold = overcrowdKillThreshold();
    const killEnabled = count > killThreshold;
    const excess = killEnabled ? (count - killThreshold) : 0;
    const killChance = killEnabled
        ? Math.min(0.45, collisionKillChanceBase + (excess / 1200))
        : 0;
    const separationRadiusSq = separationRadius * separationRadius;
    const killDistanceSq = collisionKillDistance * collisionKillDistance;

    for (let i = 0; i < count; i++) {
        const particle = particlesArray[i];
        const cellX = Math.floor(particle.x / cellSize);
        const cellY = Math.floor(particle.y / cellSize);

        for (let offsetX = -1; offsetX <= 1; offsetX++) {
            for (let offsetY = -1; offsetY <= 1; offsetY++) {
                const key = `${cellX + offsetX},${cellY + offsetY}`;
                const bucket = grid.get(key);
                if (!bucket) continue;

                for (let b = 0; b < bucket.length; b++) {
                    const j = bucket[b];
                    if (j >= i) continue;
                    if (toRemove.has(i) || toRemove.has(j)) continue;

                    const other = particlesArray[j];
                    let dx = particle.x - other.x;
                    let dy = particle.y - other.y;
                    let distanceSq = dx * dx + dy * dy;

                    if (killEnabled && distanceSq < killDistanceSq && Math.random() < killChance) {
                        const killIndex = Math.random() < 0.5 ? i : j;
                        toRemove.add(killIndex);
                        continue;
                    }

                    if (distanceSq === 0) {
                        dx = (Math.random() - 0.5) * 0.01;
                        dy = (Math.random() - 0.5) * 0.01;
                        distanceSq = dx * dx + dy * dy;
                    }

                    if (distanceSq < separationRadiusSq) {
                        const distance = Math.sqrt(distanceSq);
                        const nx = dx / distance;
                        const ny = dy / distance;
                        let impulse = separationStrength * (1 - distance / separationRadius);
                        if (impulse > separationMaxImpulse) impulse = separationMaxImpulse;

                        particle.directionX += nx * impulse;
                        particle.directionY += ny * impulse;
                        other.directionX -= nx * impulse;
                        other.directionY -= ny * impulse;
                    }
                }
            }
        }

        const ownKey = `${cellX},${cellY}`;
        if (!grid.has(ownKey)) {
            grid.set(ownKey, [i]);
        } else {
            grid.get(ownKey).push(i);
        }
    }

    if (toRemove.size > 0) {
        const indices = Array.from(toRemove);
        indices.sort((a, b) => b - a);
        for (let k = 0; k < indices.length; k++) {
            particlesArray.splice(indices[k], 1);
        }
    }
}

function initParticles() {
    particlesArray = [];
    for (let i = 0; i < particlesCount; i++) {
        particlesArray.push(new Particle());
    }

    // Force redraw after initialization to ensure proper colors
    redrawParticles();
}

function redrawParticles() {
    // Trigger a redraw to ensure particles have correct colors based on theme
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw all particles
    for (let i = 0; i < particlesArray.length; i++) {
        particlesArray[i].draw();
    }

    // Draw connections between particles
    for (let i = 0; i < particlesArray.length; i++) {
        for (let j = i + 1; j < particlesArray.length; j++) {
            let dx = particlesArray[i].x - particlesArray[j].x;
            let dy = particlesArray[i].y - particlesArray[j].y;
            let distance = dx*dx + dy*dy;

            if (distance < (connectionDistance * connectionDistance)) {
                ctx.strokeStyle = particlesArray[i].getColor();
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(particlesArray[i].x, particlesArray[i].y);
                ctx.lineTo(particlesArray[j].x, particlesArray[j].y);
                ctx.stroke();
            }
        }
    }
}

function animate(currentTime) {
    requestAnimationFrame(animate);

    // FPS limiting for wallpaper mode
    if (wallpaperMode) {
        const targetInterval = 1000 / fpsCap;
        if (currentTime - lastFrameTime < targetInterval) {
            return;
        }
        lastFrameTime = currentTime;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (wave.active) {
        wave.radius += 25;
        if (wave.radius > wave.maxRadius) {
            // Вместо мгновенного отключения волны, начинаем фазу завершения
            wave.ending = true;
            wave.endTime = currentTime + 100; // 100ms для плавного перехода
        }
    }

    // Проверяем, нужно ли завершить волну
    if (wave.ending && currentTime > wave.endTime) {
        wave.active = false;
        wave.ending = false;
    }

    if (specificAtomsArray.length > 0) {
        for (let i = 0; i < specificAtomsArray.length; i++) {
            specificAtomsArray[i].update();
            specificAtomsArray[i].draw();
        }
    } else {
        applyParticleSeparationAndCull();
        for (let i = 0; i < particlesArray.length; i++) {
            particlesArray[i].update();
            particlesArray[i].draw();
        }

        // Draw connections between particles
        for (let i = 0; i < particlesArray.length; i++) {
            for (let j = i + 1; j < particlesArray.length; j++) {
                let dx = particlesArray[i].x - particlesArray[j].x;
                let dy = particlesArray[i].y - particlesArray[j].y;
                let distance = dx*dx + dy*dy;

                if (distance < (connectionDistance * connectionDistance)) {
                    ctx.strokeStyle = particlesArray[i].getColor();
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(particlesArray[i].x, particlesArray[i].y);
                    ctx.lineTo(particlesArray[j].x, particlesArray[j].y);
                    ctx.stroke();
                }
            }
        }
    }
}


// На мобильных устройствах устанавливаем z-index выше, чтобы частицы были видны
if (window.innerWidth <= 1024) {
    canvas.style.zIndex = '1';
    canvas.style.pointerEvents = 'none';
}

// Экспортируем функцию перерисовки частиц для использования в других модулях
window.redrawParticles = redrawParticles;

// Функция для обновления цветов частиц при изменении темы
window.updateParticleColors = function() {
    redrawParticles(); // Перерисовываем с новыми цветами
};

// Экспортируем функцию инициализации частиц для использования в других модулях
window.initParticles = initParticles;

initParticles();
updateInteractionSettings();

// После полной загрузки DOM обновляем цвета частиц
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        setTimeout(updateParticleColors, 100); // Небольшая задержка для завершения инициализации темы
    });
} else {
    setTimeout(updateParticleColors, 100);
}

// Наблюдатель за изменениями класса темы
const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
            // Классы элемента изменились, возможно, изменилась тема
            if (typeof updateParticleColors === 'function') {
                setTimeout(updateParticleColors, 50);
            }
        }
    });
});

// Начинаем наблюдение за изменениями классов в body
observer.observe(document.body, {
    attributes: true,
    attributeFilter: ['class']
});

animate();


============================================================
ФАЙЛ: .\js\scroll-collapse.js
============================================================

/* =========================================
   SCROLL-COLLAPSE.JS — Логика виртуального скролла
   ========================================= */

(function() {
    'use strict';

    // Конфигурация
    const CONFIG = {
        THRESHOLD_DESKTOP: 300,  // Порог для десктопа (px)
        THRESHOLD_MOBILE: 200,   // Порог для мобильных (px)
        MIN_SCALE_DESKTOP: 0.6,  // Минимальный масштаб на десктопе
        MIN_SCALE_MOBILE: 0.5,   // Минимальный масштаб на мобильных
        MAX_SCALE: 1.0,          // Максимальный масштаб
    };

    // Состояние
    let virtualScrollY = 0;
    let isScrollUnlocked = false;
    let rafId = null;

    // Элементы DOM
    const tableContainer = document.querySelector('.periodic-table-container');
    const body = document.body;

    // Определение мобильного устройства
    function isMobile() {
        return window.innerWidth < 768;
    }

    // Получение текущего порога
    function getThreshold() {
        return isMobile() ? CONFIG.THRESHOLD_MOBILE : CONFIG.THRESHOLD_DESKTOP;
    }

    // Получение минимального масштаба
    function getMinScale() {
        return isMobile() ? CONFIG.MIN_SCALE_MOBILE : CONFIG.MIN_SCALE_DESKTOP;
    }

    // Обработка виртуального скролла
    function handleVirtualScroll(deltaY) {
        // Если любой из активных элементов открыт, не обрабатываем скролл
        if (document.body.classList.contains('balancer-active') ||
            document.body.classList.contains('solubility-open') ||
            document.body.classList.contains('calc-active') ||
            document.body.classList.contains('reactions-open') ||
            document.body.classList.contains('modal-open') ||
            (document.getElementById('filters-panel') && document.getElementById('filters-panel').classList.contains('active'))) {
            return;
        }

        if (isScrollUnlocked) return; // Если скролл разблокирован, не обрабатываем

        virtualScrollY += deltaY;
        virtualScrollY = Math.max(0, virtualScrollY); // Не даем уйти в минус

        const threshold = getThreshold();

        console.log('[Scroll-Collapse] Virtual scroll:', {
            virtualScrollY,
            threshold,
            willUnlock: virtualScrollY >= threshold
        });

        if (virtualScrollY >= threshold) {
            console.log('[Scroll-Collapse] 🔓 Разблокировка скролла!');
            unlockScroll();
        } else {
            updateTableScale();
        }
    }

    // Обновление масштаба таблицы
    function updateTableScale() {
        if (rafId) {
            cancelAnimationFrame(rafId);
        }

        rafId = requestAnimationFrame(() => {
            const threshold = getThreshold();
            const minScale = getMinScale();
            const progress = Math.min(virtualScrollY / threshold, 1);
            const scale = CONFIG.MAX_SCALE - (progress * (CONFIG.MAX_SCALE - minScale));

            console.log('[Scroll-Collapse] Update scale:', {
                progress: (progress * 100).toFixed(1) + '%',
                scale: scale.toFixed(2)
            });

            tableContainer.style.transform = `scale(${scale})`;
            rafId = null;
        });
    }

    // Разблокировка реального скролла
    function unlockScroll() {
        if (isScrollUnlocked) return;

        isScrollUnlocked = true;
        body.classList.remove('scroll-locked');
        body.classList.add('scroll-unlocked');
        tableContainer.classList.add('scroll-collapsed');

        const minScale = getMinScale();
        tableContainer.style.transform = `scale(${minScale})`;
    }

    // Блокировка скролла (возврат к начальному состоянию)
    function lockScroll() {
        if (!isScrollUnlocked) return;

        isScrollUnlocked = false;
        virtualScrollY = 0;
        body.classList.remove('scroll-unlocked');
        body.classList.add('scroll-locked');
        tableContainer.classList.remove('scroll-collapsed');
        tableContainer.style.transform = 'scale(1)';

        // Прокручиваем страницу наверх
        window.scrollTo(0, 0);
    }

    // Обработка колесика мыши (для десктопа)
    function handleWheel(event) {
        // Если любой из активных элементов открыт, не обрабатываем скролл
        if (document.body.classList.contains('balancer-active') ||
            document.body.classList.contains('solubility-open') ||
            document.body.classList.contains('calc-active') ||
            document.body.classList.contains('reactions-open') ||
            document.body.classList.contains('modal-open') ||
            (document.getElementById('filters-panel') && document.getElementById('filters-panel').classList.contains('active'))) {
            return;
        }

        console.log('[Scroll-Collapse] Wheel event:', {
            deltaY: event.deltaY,
            virtualScrollY,
            threshold: getThreshold(),
            isScrollUnlocked
        });

        if (!isScrollUnlocked && virtualScrollY < getThreshold()) {
            event.preventDefault();
            handleVirtualScroll(event.deltaY);
        }
    }

    // Обработка тач-событий (для мобильных)
    let touchStartY = 0;
    let lastTouchY = 0;

    function handleTouchStart(event) {
        // Если любой из активных элементов открыт, не обрабатываем тач-события
        if (document.body.classList.contains('balancer-active') ||
            document.body.classList.contains('solubility-open') ||
            document.body.classList.contains('calc-active') ||
            document.body.classList.contains('reactions-open') ||
            document.body.classList.contains('modal-open') ||
            (document.getElementById('filters-panel') && document.getElementById('filters-panel').classList.contains('active'))) {
            return;
        }

        if (!isScrollUnlocked) {
            touchStartY = event.touches[0].clientY;
            lastTouchY = touchStartY;
        }
    }

    function handleTouchMove(event) {
        // Если любой из активных элементов открыт, не обрабатываем тач-события
        if (document.body.classList.contains('balancer-active') ||
            document.body.classList.contains('solubility-open') ||
            document.body.classList.contains('calc-active') ||
            document.body.classList.contains('reactions-open') ||
            document.body.classList.contains('modal-open') ||
            (document.getElementById('filters-panel') && document.getElementById('filters-panel').classList.contains('active'))) {
            return;
        }

        if (!isScrollUnlocked && virtualScrollY < getThreshold()) {
            const currentY = event.touches[0].clientY;
            const deltaY = lastTouchY - currentY; // Инвертируем для правильного направления
            lastTouchY = currentY;

            if (deltaY > 0) { // Свайп вверх
                // Проверяем, можно ли предотвратить действие по умолчанию
                if (event.cancelable) {
                    event.preventDefault();
                }
                handleVirtualScroll(deltaY * 2); // Умножаем для более быстрой реакции
            }
        }
    }

    // Обработка реального скролла страницы
    function handlePageScroll() {
        // Если любой из активных элементов открыт, не блокируем скролл
        if (document.body.classList.contains('balancer-active') ||
            document.body.classList.contains('solubility-open') ||
            document.body.classList.contains('calc-active') ||
            document.body.classList.contains('reactions-open') ||
            document.body.classList.contains('modal-open') ||
            (document.getElementById('filters-panel') && document.getElementById('filters-panel').classList.contains('active'))) {
            return;
        }

        if (isScrollUnlocked && window.scrollY === 0) {
            // Если пользователь прокрутил в самый верх, блокируем скролл
            lockScroll();
        }
    }

    // Инициализация
    function init() {
        console.log('[Scroll-Collapse] Начало инициализации...');

        // Check if the device is Mobile (width <= 1024px) OR if running in Electron (check existence of window.electronAPI)
        if (window.innerWidth <= 1024 || window.electronAPI) {
            console.log('[Scroll-Collapse] Mobile or Electron detected - disabling scroll collapse and hiding footer');

            // Force the page to stay locked (overflow: hidden on body)
            document.body.style.overflow = 'hidden';

            // Ensure .below-table-content is hidden (display: none)
            const belowTableContent = document.querySelector('.below-table-content');
            if (belowTableContent) {
                belowTableContent.style.display = 'none';
            }

            // Return early - don't initialize scroll logic
            return;
        }

        if (!tableContainer) {
            console.error('[Scroll-Collapse] Контейнер .periodic-table-container не найден!');
            console.log('[Scroll-Collapse] Доступные элементы:', document.body.children);
            return;
        }

        console.log('[Scroll-Collapse] Контейнер найден:', tableContainer);

        // Устанавливаем начальное состояние
        body.classList.add('scroll-locked');
        console.log('[Scroll-Collapse] Класс scroll-locked добавлен');

        // Обработчики событий
        window.addEventListener('wheel', handleWheel, { passive: false });
        window.addEventListener('touchstart', handleTouchStart, { passive: true });
        window.addEventListener('touchmove', handleTouchMove, { passive: false });
        window.addEventListener('scroll', handlePageScroll, { passive: true });

        console.log('[Scroll-Collapse] Event listeners добавлены');

        // Обработка изменения размера окна
        window.addEventListener('resize', () => {
            if (!isScrollUnlocked) {
                updateTableScale();
            }
        });

        console.log('[Scroll-Collapse] ✅ Система инициализирована успешно!');
        console.log('[Scroll-Collapse] Порог:', getThreshold(), 'px');
        console.log('[Scroll-Collapse] Мин. масштаб:', getMinScale());
    }

    // Запуск при загрузке DOM
    if (document.readyState === 'loading') {
        console.log('[Scroll-Collapse] Ожидание DOMContentLoaded...');
        document.addEventListener('DOMContentLoaded', init);
    } else {
        console.log('[Scroll-Collapse] DOM уже загружен, запуск init()');
        init();
    }

    // Функции для отключения и включения системы скроллколапса
    // Они доступны глобально, чтобы другие модули могли их использовать
    window.disableScrollCollapseSystem = function() {
        // Disable scroll-collapse functionality
        const tableContainer = document.querySelector('.periodic-table-container');
        if (tableContainer) {
            tableContainer.classList.add('scroll-locked'); // Add class to prevent scaling
        }

        // Hide below-table-content
        const belowTableContent = document.querySelector('.below-table-content');
        if (belowTableContent) {
            belowTableContent.style.display = 'none';
        }

        // Prevent scroll-collapse event listeners from working
        const scrollCollapseListeners = document.body.getAttribute('data-scroll-collapse-disabled');
        if (!scrollCollapseListeners) {
            document.body.setAttribute('data-scroll-collapse-disabled', 'true');
        }
    };

    window.restoreScrollCollapseSystem = function() {
        // Re-enable scroll-collapse functionality
        const tableContainer = document.querySelector('.periodic-table-container');
        if (tableContainer) {
            tableContainer.classList.remove('scroll-locked'); // Remove class that prevented scaling
        }

        // Show below-table-content if appropriate
        const belowTableContent = document.querySelector('.below-table-content');
        if (belowTableContent) {
            // Only show if scroll-collapse is unlocked (depends on your implementation)
            // For now, we'll restore the default behavior
            belowTableContent.style.display = '';
        }

        // Allow scroll-collapse event listeners to work again
        document.body.removeAttribute('data-scroll-collapse-disabled');
    };
})();


============================================================
ФАЙЛ: .\js\scrypt.js
============================================================

﻿// =========================================
// MAIN LOADER FILE - OPTIMIZED LOADING
// v2.2 - loader only
// =========================================

// === CRITICAL SCRIPTS (load immediately) ===
const criticalScripts = [
    'js/icons.js',
    'js/elements.js',
    'js/utils.js',
    'js/modules/mobile-layout.js'
];

// === CORE SCRIPTS (after DOMContentLoaded) ===
const coreScripts = [
    'js/particles.js',
    'js/modules/modal.js',
    'js/modules/electron-config.js',
    'js/modules/theme.js',
    'js/modules/theme-toggle.js',
    'js/modules/search-filters.js',
    'js/modules/ui.js',
    'js/reactions-db.js',
    'js/modules/reactions.js',
    'js/scroll-collapse.js',
    'js/wallpaper-handler.js',
    'js/bad-apple.js',
    // Nodemap
    'js/nodemap/nodemap-parser.js',
    'js/nodemap/nodemap-layout.js',
    'js/nodemap/nodemap-canvas.js',
    'js/nodemap/nodemap-flow-data.js',
    'js/nodemap/nodemap-flow-layout.js',
    'js/nodemap/nodemap-flow-canvas.js',
    'js/nodemap/nodemap-modal.js',
    'js/nodemap/nodemap-init.js',
    // Extras
    'js/fab-animation.js'
];

// Runtime logic (must load even if some core scripts fail)
const coreAlways = [
    'js/modules/app-runtime.js'
];

// Optional external libraries (do not block the app)
const optionalScripts = [
    'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js',
    'https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/mhchem.min.js',
    'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js'
];

// Core scripts that depend on optional libs
const coreAfterOptional = [
    'js/modules/latex-export.js?v=2026-02-14-5'
];

// Loading progress
let totalScripts = 0;
let loadedScripts = 0;

function updateProgress(percent) {
    if (window.ChemLoader) {
        window.ChemLoader.updateProgress(percent);
        if (percent >= 100) {
            setTimeout(() => {
                window.ChemLoader.hide();
            }, 500);
        }
    }
}

function loadScript(src) {
    return new Promise((resolve, reject) => {
        if (document.querySelector(`script[src="${src}"]`)) {
            resolve();
            return;
        }

        const script = document.createElement('script');
        script.src = src;
        script.onload = () => {
            loadedScripts++;
            updateProgress((loadedScripts / totalScripts) * 100);
            resolve();
        };
        script.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(script);
    });
}

async function loadScripts(scripts) {
    for (const src of scripts) {
        await loadScript(src);
    }
}

function loadScriptSafe(src) {
    return new Promise((resolve) => {
        if (document.querySelector(`script[src="${src}"]`)) {
            resolve();
            return;
        }

        const script = document.createElement('script');
        script.src = src;
        script.onload = () => {
            loadedScripts++;
            updateProgress((loadedScripts / totalScripts) * 100);
            resolve();
        };
        script.onerror = () => {
            console.warn(`Optional script failed to load: ${src}`);
            loadedScripts++;
            updateProgress((loadedScripts / totalScripts) * 100);
            resolve();
        };
        document.head.appendChild(script);
    });
}

async function loadScriptsSafe(scripts) {
    for (const src of scripts) {
        await loadScriptSafe(src);
    }
}

window.loadScript = loadScript;
window.loadScripts = loadScripts;

const BAD_APPLE_PHRASE = 'badapple';
const BAD_APPLE_CONTEXT_PERIODIC = 'periodic';
const BAD_APPLE_CONTEXT_SOLUBILITY = 'solubility';
let badAppleTypedBuffer = '';
let badApplePlayerInstance = null;
let badApplePlayerContext = BAD_APPLE_CONTEXT_PERIODIC;
let badAppleHotkeyAttached = false;
let badAppleSolubilityScaleState = null;

function getBadAppleAudioElement() {
    return (
        document.querySelector('[data-bad-apple-audio]') ||
        document.querySelector('#bad-apple-audio') ||
        document.querySelector('audio[data-track="bad-apple"]')
    );
}

function resolveBadApplePayload(context) {
    if (context === BAD_APPLE_CONTEXT_SOLUBILITY) {
        if (window.BAD_APPLE_PAYLOAD_SOLUBILITY) {
            return window.BAD_APPLE_PAYLOAD_SOLUBILITY;
        }
        if (window.BAD_APPLE_PAYLOAD) {
            return window.BAD_APPLE_PAYLOAD;
        }
    } else if (window.BAD_APPLE_PAYLOAD) {
        return window.BAD_APPLE_PAYLOAD;
    }

    if (window.BadApplePlayer && typeof window.BadApplePlayer.createDemoPayload === 'function') {
        const dimensions = context === BAD_APPLE_CONTEXT_SOLUBILITY
            ? { width: 24, height: 22 }
            : { width: 18, height: 10 };
        return window.BadApplePlayer.createDemoPayload({
            ...dimensions,
            fps: 12,
            durationSeconds: 8
        });
    }

    return null;
}

function isSolubilityModalVisible() {
    const modal = document.getElementById('solubility-modal');
    if (!modal) {
        return false;
    }
    return getComputedStyle(modal).display !== 'none';
}

function restoreInlineStyle(element, styleValue) {
    if (!element) {
        return;
    }
    if (styleValue === null || styleValue === undefined) {
        element.removeAttribute('style');
        return;
    }
    element.setAttribute('style', styleValue);
}

function clearBadAppleSolubilityScale() {
    if (!badAppleSolubilityScaleState) {
        return;
    }
    restoreInlineStyle(badAppleSolubilityScaleState.wrapper, badAppleSolubilityScaleState.wrapperStyle);
    restoreInlineStyle(badAppleSolubilityScaleState.table, badAppleSolubilityScaleState.tableStyle);
    badAppleSolubilityScaleState = null;
}

function fitSolubilityTableToViewport() {
    const modal = document.getElementById('solubility-modal');
    const wrapper = modal ? modal.querySelector('.solubility-wrapper') : null;
    const table = document.getElementById('solubility-table');

    if (!modal || !wrapper || !table || getComputedStyle(modal).display === 'none') {
        return false;
    }

    if (table.querySelectorAll('tbody td').length === 0 && typeof window.renderSolubilityTable === 'function') {
        window.renderSolubilityTable();
    }

    const tableWidth = table.scrollWidth;
    const tableHeight = table.scrollHeight;
    const availableWidth = wrapper.clientWidth;
    const availableHeight = wrapper.clientHeight;

    if (tableWidth <= 0 || tableHeight <= 0 || availableWidth <= 0 || availableHeight <= 0) {
        return false;
    }

    const scale = Math.min(1, availableWidth / tableWidth, availableHeight / tableHeight);
    const safeScale = Math.max(0.2, scale);

    clearBadAppleSolubilityScale();
    badAppleSolubilityScaleState = {
        wrapper,
        table,
        wrapperStyle: wrapper.getAttribute('style'),
        tableStyle: table.getAttribute('style')
    };

    wrapper.style.overflow = 'hidden';
    wrapper.style.display = 'flex';
    wrapper.style.alignItems = 'flex-start';
    wrapper.style.justifyContent = 'flex-start';
    wrapper.scrollLeft = 0;
    wrapper.scrollTop = 0;

    table.style.transformOrigin = 'top left';
    table.style.transform = `scale(${safeScale})`;
    table.style.willChange = 'transform';

    return true;
}

function buildSampleIndices(total, target) {
    if (total <= 0 || target <= 0) {
        return [];
    }
    if (target === 1) {
        return [Math.floor((total - 1) / 2)];
    }
    const indices = [];
    for (let index = 0; index < target; index += 1) {
        const ratio = index / (target - 1);
        indices.push(Math.round(ratio * (total - 1)));
    }
    return indices;
}

function buildSolubilityGridMap(width, height) {
    const table = document.getElementById('solubility-table');
    if (!table) {
        return null;
    }

    if (table.querySelectorAll('tbody td').length === 0 && typeof window.renderSolubilityTable === 'function') {
        window.renderSolubilityTable();
    }

    const rowNodes = Array.from(table.querySelectorAll('tbody tr'));
    if (!rowNodes.length) {
        return null;
    }

    const cellRows = rowNodes.map((row) => Array.from(row.querySelectorAll('td')));
    const rowCount = cellRows.length;
    const colCount = cellRows.reduce((max, row) => Math.max(max, row.length), 0);

    if (!rowCount || !colCount) {
        return null;
    }

    const rowIndices = buildSampleIndices(rowCount, height);
    const colIndices = buildSampleIndices(colCount, width);

    return rowIndices.map((rowIdx) => {
        const sourceRow = cellRows[rowIdx] || [];
        const lastCell = sourceRow[sourceRow.length - 1] || null;
        return colIndices.map((colIdx) => sourceRow[colIdx] || lastCell);
    });
}

function ensureBadApplePlayer(options) {
    const opts = options || {};
    const requestedContext = opts.context || BAD_APPLE_CONTEXT_PERIODIC;
    const forceRecreate = Boolean(opts.forceRecreate);

    if (typeof window.BadApplePlayer !== 'function') {
        return null;
    }

    const payload = resolveBadApplePayload(requestedContext);
    if (!payload) {
        return null;
    }

    const normalizedPayload = window.BadApplePlayer.normalizePayload(payload);
    const width = normalizedPayload.width;
    const height = normalizedPayload.height;

    let context = requestedContext;
    let gridMap = window.PERIODIC_SELECTOR_GRID_18X10;

    if (requestedContext === BAD_APPLE_CONTEXT_SOLUBILITY) {
        const solubilityGridMap = buildSolubilityGridMap(width, height);
        if (solubilityGridMap) {
            gridMap = solubilityGridMap;
        } else {
            console.warn('Bad Apple solubility mode is unavailable: no solubility cells found.');
            return null;
        }
    }

    const canReuse = badApplePlayerInstance &&
        badApplePlayerContext === context &&
        !forceRecreate;

    if (canReuse) {
        return badApplePlayerInstance;
    }

    if (badApplePlayerInstance) {
        badApplePlayerInstance.stop({ restore: true, reset: true });
        badApplePlayerInstance = null;
    }

    badApplePlayerInstance = new window.BadApplePlayer({
        payload: normalizedPayload,
        gridMap,
        audio: getBadAppleAudioElement(),
        onColor: '#111111',
        offColor: '#f5f5f5',
        onFinish: () => {
            clearBadAppleSolubilityScale();
        }
    });
    badApplePlayerContext = context;

    return badApplePlayerInstance;
}

function startBadApplePlayback(options) {
    const opts = options || {};
    const preferSolubility = Boolean(opts.preferSolubility);
    const shouldUseSolubility = preferSolubility || isSolubilityModalVisible();
    const context = shouldUseSolubility
        ? BAD_APPLE_CONTEXT_SOLUBILITY
        : BAD_APPLE_CONTEXT_PERIODIC;

    clearBadAppleSolubilityScale();
    if (context === BAD_APPLE_CONTEXT_SOLUBILITY) {
        fitSolubilityTableToViewport();
    }

    const player = ensureBadApplePlayer({
        context,
        forceRecreate: context === BAD_APPLE_CONTEXT_SOLUBILITY
    });
    if (!player) {
        console.warn('BadApplePlayer is not ready.');
        clearBadAppleSolubilityScale();
        return;
    }

    player.stop({ restore: true, reset: true });
    player.play({ restart: true });
}

function stopBadApplePlayback() {
    if (!badApplePlayerInstance) {
        clearBadAppleSolubilityScale();
        return;
    }
    badApplePlayerInstance.stop({ restore: true, reset: true });
    clearBadAppleSolubilityScale();
}

function isTypingContext(target) {
    if (!target || typeof target !== 'object') {
        return false;
    }
    if (target.isContentEditable) {
        return true;
    }
    const tagName = String(target.tagName || '').toUpperCase();
    return tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT';
}

function handleBadAppleKeydown(event) {
    if (event.key === 'Escape') {
        stopBadApplePlayback();
        badAppleTypedBuffer = '';
        return;
    }

    if (event.altKey || event.ctrlKey || event.metaKey) {
        return;
    }

    const target = event.target;
    const isSolubilitySearchInput = target && target.id === 'solubility-search-input';
    const key = String(event.key || '').toLowerCase();

    if (isSolubilitySearchInput) {
        if (!/^[a-z]$/.test(key)) {
            badAppleTypedBuffer = '';
            return;
        }

        badAppleTypedBuffer = (badAppleTypedBuffer + key).slice(-BAD_APPLE_PHRASE.length);
        if (badAppleTypedBuffer === BAD_APPLE_PHRASE) {
            badAppleTypedBuffer = '';
            event.preventDefault();
            target.value = '';
            target.dispatchEvent(new Event('input', { bubbles: true }));
            startBadApplePlayback({ preferSolubility: true });
        }
        return;
    }

    if (isTypingContext(event.target)) {
        return;
    }

    if (!/^[a-z]$/.test(key)) {
        badAppleTypedBuffer = '';
        return;
    }

    badAppleTypedBuffer = (badAppleTypedBuffer + key).slice(-BAD_APPLE_PHRASE.length);
    if (badAppleTypedBuffer === BAD_APPLE_PHRASE) {
        badAppleTypedBuffer = '';
        startBadApplePlayback({ preferSolubility: isSolubilityModalVisible() });
    }
}

function initBadAppleHotkey() {
    if (badAppleHotkeyAttached) {
        return;
    }
    document.addEventListener('keydown', handleBadAppleKeydown);
    badAppleHotkeyAttached = true;
    window.startBadApple = startBadApplePlayback;
    window.stopBadApple = stopBadApplePlayback;
}

async function init() {
    try {
        totalScripts = criticalScripts.length + coreScripts.length + coreAlways.length + optionalScripts.length + coreAfterOptional.length;
        loadedScripts = 0;

        await loadScriptsSafe(criticalScripts);

        const runCore = async () => {
            await loadScriptsSafe(coreScripts);
            await loadScriptsSafe(coreAlways);
            await loadScriptsSafe(optionalScripts);
            await loadScriptsSafe(coreAfterOptional);
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', runCore);
        } else {
            await runCore();
        }
    } catch (error) {
        console.error('Loader error:', error);
        updateProgress(100);
    }
}

initBadAppleHotkey();
init();


============================================================
ФАЙЛ: .\js\utils.js
============================================================

/**
 * Утилиты для определения типа устройства
 */

// Функция для определения типа устройства
function getDeviceType() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    
    // Проверка на iOS
    const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
    
    // Проверка на iPhone
    const isIPhone = /iPhone/.test(userAgent) && !window.MSStream;
    
    // Проверка на iPad
    const isIPad = /iPad/.test(userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    
    // Проверка на Android
    const isAndroid = /android/i.test(userAgent);
    
    // Проверка на Windows
    const isWindows = /Win/.test(userAgent);
    
    // Проверка на Mac (не iOS)
    const isMac = /Mac/.test(userAgent) && !isIOS;
    
    // Проверка на Mobile (любое мобильное устройство)
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    
    // Проверка на Touch Device
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    
    return {
        isIOS,
        isIPhone,
        isIPad,
        isAndroid,
        isWindows,
        isMac,
        isMobile,
        isTouchDevice
    };
}

// Функция для добавления классов устройства к body
function addDeviceClassToBody() {
    const device = getDeviceType();
    const body = document.body;
    
    // Удаляем старые классы
    body.classList.remove(
        'device-ios', 
        'device-iphone', 
        'device-ipad', 
        'device-android', 
        'device-windows', 
        'device-mac',
        'device-mobile',
        'device-touch'
    );
    
    // Добавляем новые классы в зависимости от устройства
    if (device.isIOS) body.classList.add('device-ios');
    if (device.isIPhone) body.classList.add('device-iphone');
    if (device.isIPad) body.classList.add('device-ipad');
    if (device.isAndroid) body.classList.add('device-android');
    if (device.isWindows) body.classList.add('device-windows');
    if (device.isMac) body.classList.add('device-mac');
    if (device.isMobile) body.classList.add('device-mobile');
    if (device.isTouchDevice) body.classList.add('device-touch');
}

// Инициализация при загрузке DOM
document.addEventListener('DOMContentLoaded', function() {
    addDeviceClassToBody();
});

// Экспорт функций для использования в других модулях
window.DeviceUtils = {
    getDeviceType,
    addDeviceClassToBody
};

============================================================
ФАЙЛ: .\js\wallpaper-handler.js
============================================================

/* =========================================
   WALLPAPER-HANDLER.JS — Обработка установки обоев
   ========================================= */

(function() {
    'use strict';

    // Проверяем наличие Electron API
    function isElectronAvailable() {
        return typeof window !== 'undefined' &&
               window.electronAPI &&
               typeof window.electronAPI.setAsWallpaper === 'function';
    }

    // Показываем уведомление
    function showNotification(message, type = 'success') {
        // Создаем элемент уведомления
        const notification = document.createElement('div');
        notification.className = `wallpaper-notification wallpaper-notification-${type}`;
        notification.textContent = message;

        // Добавляем стили если их еще нет
        if (!document.getElementById('wallpaper-notification-styles')) {
            const style = document.createElement('style');
            style.id = 'wallpaper-notification-styles';
            style.textContent = `
                .wallpaper-notification {
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    padding: 20px 40px;
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    border-radius: 12px;
                    font-size: 18px;
                    z-index: 10000;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                    animation: fadeInOut 3s ease-in-out;
                    pointer-events: none;
                }

                .wallpaper-notification-success {
                    border-left: 4px solid #4CAF50;
                }

                .wallpaper-notification-error {
                    border-left: 4px solid #f44336;
                }

                .wallpaper-notification-info {
                    border-left: 4px solid #2196F3;
                }

                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                    10% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    90% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                }
            `;
            document.head.appendChild(style);
        }

        // Добавляем уведомление в DOM
        document.body.appendChild(notification);

        // Удаляем через 3 секунды
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }

    // Главная функция установки обоев
    window.handleSetWallpaper = async function() {
        console.log('[Wallpaper Handler] Попытка установки обоев...');

        // Проверяем доступность Electron API
        if (!isElectronAvailable()) {
            showNotification(
                'Эта функция доступна только в Electron приложении',
                'info'
            );
            console.warn('[Wallpaper Handler] Electron API недоступен');
            return;
        }

        try {
            // Показываем индикатор загрузки
            showNotification('Создание обоев...', 'info');

            // Вызываем Electron API
            const result = await window.electronAPI.setAsWallpaper();

            if (result.success) {
                console.log('[Wallpaper Handler] Успех!', result);
                showNotification('Обои успешно установлены!', 'success');
            } else {
                console.error('[Wallpaper Handler] Ошибка:', result.message);
                showNotification(result.message || 'Не удалось установить обои', 'error');
            }
        } catch (error) {
            console.error('[Wallpaper Handler] Исключение:', error);
            showNotification('Произошла ошибка при установке обоев', 'error');
        }
    };

    // Скрываем кнопку если не Electron
    function initWallpaperButton() {
        const wallpaperOption = document.getElementById('wallpaper-option');

        if (wallpaperOption && !isElectronAvailable()) {
            // Скрываем кнопку в браузере
            wallpaperOption.style.display = 'none';
            console.log('[Wallpaper Handler] Кнопка скрыта (не Electron)');
        } else if (wallpaperOption) {
            console.log('[Wallpaper Handler] Кнопка активна (Electron режим)');
        }
    }

    // Инициализация
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initWallpaperButton);
    } else {
        initWallpaperButton();
    }

    console.log('[Wallpaper Handler] Модуль загружен');

})();


============================================================
ФАЙЛ: .\js\modules\app-runtime.js
============================================================

﻿// =========================================
// APP RUNTIME (moved out of index.html and scrypt.js)
// =========================================

// Fallback for preload CSS in Chrome
(function () {
    var links = document.querySelectorAll('link[rel="preload"][as="style"]');
    links.forEach(function (link) {
        if (link.rel !== 'stylesheet') {
            link.rel = 'stylesheet';
        }
    });
})();

// Service Worker
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
            .then(reg => console.log('SW зарегистрирован!', reg))
            .catch(err => console.log('Ошибка SW:', err));
    });
}

// Live Wallpaper & Settings Script (Electron only)
(function () {
    if (!window.electronAPI) {
        console.log('[Live Wallpaper] Not running in Electron, features disabled');
        return;
    }

    console.log('[Live Wallpaper] Electron detected, initializing...');

    const liveWallpaperOption = document.getElementById('live-wallpaper-option');
    const settingsOption = document.getElementById('settings-option');
    const statusSpan = document.getElementById('wallpaper-status');
    const liveWallpaperBtn = document.getElementById('live-wallpaper-btn');

    if (liveWallpaperOption) liveWallpaperOption.style.display = 'flex';
    if (settingsOption) settingsOption.style.display = 'flex';

    let isWallpaperActive = false;

    window.electronAPI.isLiveWallpaperActive().then(active => {
        isWallpaperActive = active;
        updateWallpaperUI();
    });

    window.toggleLiveWallpaper = async function () {
        if (liveWallpaperBtn) liveWallpaperBtn.disabled = true;

        try {
            let result;

            if (!isWallpaperActive) {
                result = await window.electronAPI.enableLiveWallpaper();
            } else {
                result = await window.electronAPI.disableLiveWallpaper();
            }

            if (result.success) {
                isWallpaperActive = !isWallpaperActive;
                updateWallpaperUI();
                showAppNotification(result.message, 'success');
            } else {
                showAppNotification(result.message, 'error');
            }
        } catch (error) {
            console.error('[Wallpaper] Error:', error);
            showAppNotification('Не удалось переключить обои', 'error');
        } finally {
            if (liveWallpaperBtn) liveWallpaperBtn.disabled = false;
        }
    };

    function updateWallpaperUI() {
        if (statusSpan) {
            if (isWallpaperActive) {
                statusSpan.textContent = 'ON';
                statusSpan.classList.add('active');
            } else {
                statusSpan.textContent = 'OFF';
                statusSpan.classList.remove('active');
            }
        }
        if (liveWallpaperBtn) {
            if (isWallpaperActive) {
                liveWallpaperBtn.classList.add('active');
            } else {
                liveWallpaperBtn.classList.remove('active');
            }
        }
        applyWallpaperOptimizations(isWallpaperActive);
    }

    function applyWallpaperOptimizations(enabled) {
        if (document.body) {
            document.body.classList.toggle('wallpaper-optimized', enabled);
        }
        if (typeof window.setWallpaperMode === 'function') {
            window.setWallpaperMode(enabled);
        }
    }

    window.openSettingsModal = function () {
        const modal = document.getElementById('settings-modal');
        if (modal) {
            modal.style.display = 'block';
            loadSettingsState();
        }
    };

    window.closeSettingsModal = function () {
        const modal = document.getElementById('settings-modal');
        if (modal) {
            modal.style.display = 'none';
        }
    };

    async function loadSettingsState() {
        const autostartCheckbox = document.getElementById('autostart-checkbox');
        if (autostartCheckbox && window.electronAPI.isAutostartEnabled) {
            const enabled = await window.electronAPI.isAutostartEnabled();
            autostartCheckbox.checked = enabled;
        }

        const appInfoText = document.getElementById('app-info-text');
        if (appInfoText && window.electronAPI.getAppInfo) {
            const info = await window.electronAPI.getAppInfo();
            if (info) {
                appInfoText.textContent = `${info.name} v${info.version} (${info.platform} ${info.arch})`;
            }
        }
    }

    const autostartCheckbox = document.getElementById('autostart-checkbox');
    if (autostartCheckbox) {
        autostartCheckbox.addEventListener('change', async (e) => {
            const result = await window.electronAPI.setAutostart(e.target.checked);
            if (!result.success) {
                showAppNotification('Не удалось изменить настройку автозапуска', 'error');
                e.target.checked = !e.target.checked;
            } else {
                showAppNotification(
                    e.target.checked ? 'Автозапуск включён' : 'Автозапуск отключён',
                    'success'
                );
            }
        });
    }

    const settingsModal = document.getElementById('settings-modal');
    if (settingsModal) {
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                closeSettingsModal();
            }
        });
    }

    function showAppNotification(message, type) {
        const existing = document.querySelectorAll('.app-notification');
        existing.forEach(n => n.remove());

        const notification = document.createElement('div');
        notification.className = `app-notification ${type}`;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }, 4000);
    }

    console.log('[Live Wallpaper] Initialized successfully');
})();

// === Lazy modules ===
const lazyModules = {
    solubility: [
        'js/solubility/data.js',
        'js/solubility/colors.js',
        'js/solubility/solubility-table.js',
        'js/solubility/filters.js',
        'js/solubility/search.js',
        'js/solubility/modal.js',
        'js/solubility/advanced-modal.js'
    ],
    calculator: [
        'js/modules/calculator.js'
    ],
    balancer: [
        'js/modules/balancer.js'
    ]
};

let solubilityLoaded = false;
let calculatorLoaded = false;
let isBalancerLoading = false;

async function loadSolubility() {
    if (solubilityLoaded) return;
    try {
        if (!window.loadScripts) throw new Error('loadScripts is not available');
        await window.loadScripts(lazyModules.solubility);
        solubilityLoaded = true;
        if (typeof renderSolubilityTable === 'function') renderSolubilityTable();
    } catch (error) {
        console.error('Ошибка загрузки растворимости:', error);
    }
}

async function loadCalculator() {
    if (calculatorLoaded) return;
    try {
        if (!window.loadScripts) throw new Error('loadScripts is not available');
        await window.loadScripts(lazyModules.calculator);
        calculatorLoaded = true;
        if (typeof initCalculator === 'function') initCalculator();
    } catch (error) {
        console.error('Ошибка загрузки калькулятора:', error);
    }
}

window.closeBalancerPanel = function (event) {
    if (typeof window.closeBalancer === 'function') {
        window.closeBalancer(event);
    }
};

window.toggleBalancerPanel = async function (event) {
    if (window.loadBalancer) await window.loadBalancer();
    if (typeof window.toggleBalancer === 'function') {
        window.toggleBalancer(event);
    }
};

window.loadBalancer = async function () {
    if (window.balancerLoaded) return;
    if (isBalancerLoading) return;
    isBalancerLoading = true;

    try {
        if (!window.loadScripts) throw new Error('loadScripts is not available');
        await window.loadScripts(lazyModules.balancer);
        window.balancerLoaded = true;
    } catch (error) {
        console.error('Ошибка загрузки балансера:', error);
    } finally {
        isBalancerLoading = false;
    }
};

window.loadSolubility = loadSolubility;
window.loadCalculator = loadCalculator;

function initApp() {
    if (typeof initTheme === 'function') initTheme();
    if (typeof initModal === 'function') initModal();
    if (typeof initElectronConfig === 'function') initElectronConfig();
    if (typeof initSearch === 'function') initSearch();
    if (typeof initUI === 'function') initUI();

    console.log('Приложение загружено');

    if (window.ChemLoader) {
        window.ChemLoader.hide();
    }
}

initApp();
console.log('72 версия');


============================================================
ФАЙЛ: .\js\modules\balancer.js
============================================================

// =========================================
// MODULE: EQUATION BALANCER
// =========================================
const BALANCER_ANIM_MS = 360;

/**
 * Close balancer panel
 */

window.closeBalancer = function (event) {
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }

    const panel = document.getElementById('balancer-panel');
    if (!panel) return;

    if (panel.classList.contains('active')) {
        if (panel.classList.contains('closing')) return;
        panel.classList.add('closing');
        document.body.classList.remove('balancer-active');
        setTimeout(() => {
            panel.classList.remove('active', 'closing');

            // Open FAB on mobile after balancer closes
            if (window.innerWidth <= 1024) {
                const fab = document.getElementById('fab-container');
                if (fab) {
                    fab.style.display = ''; // Ensure visible
                    fab.classList.add('active'); // Expand
                }
            }
        }, BALANCER_ANIM_MS);
    } else {
        panel.classList.remove('active', 'closing');
        document.body.classList.remove('balancer-active');
    }
    if (window.mobileLayout && typeof window.mobileLayout.resetTransform === 'function') {
        window.mobileLayout.resetTransform();
    }

    // Continue with other cleanup immediately (or wait? usually immediate is fine for non-visuals)

    // Restore scroll position if saved
    const savedScrollY = document.body.dataset.savedScrollY;
    if (savedScrollY !== undefined) {
        window.scrollTo({ top: parseInt(savedScrollY), behavior: 'instant' });
        delete document.body.dataset.savedScrollY;
    }

    // Show FAB on mobile
    const fab = document.getElementById('fab-container');
    if (window.innerWidth <= 1024 && fab) {
        fab.style.display = '';
    }

    // Restore scroll-collapse system when balancer is closed
    window.restoreScrollCollapseSystem();

    if (typeof resetFabPosition === 'function') resetFabPosition();
};

/**
 * Check if balancer is active
 */
window.isBalancerActive = function () {
    const panel = document.getElementById('balancer-panel');
    return panel && panel.classList.contains('active');
};

/**
 * Toggle balancer panel
 */
window.toggleBalancer = async function (event) {
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }

    const panel = document.getElementById('balancer-panel');
    const fab = document.getElementById('fab-container');

    if (!panel) return;

    // If open - close
    if (panel.classList.contains('active')) {
        window.closeBalancer(event);
        return;
    }

    // Check for conflicts
    const isElementModalOpen = document.body.classList.contains('modal-open');
    const isSolubilityOpen = document.body.classList.contains('solubility-open');
    const filtersPanel = document.getElementById('filters-panel');
    const isFiltersOpen = filtersPanel && filtersPanel.classList.contains('active');
    const isCalcOpen = document.body.classList.contains('calc-active');

    if (isElementModalOpen || isSolubilityOpen || isFiltersOpen || isCalcOpen) return;

    // Save scroll position
    document.body.dataset.savedScrollY = window.scrollY || window.pageYOffset;

    // On mobile: scroll to top immediately
    if (window.innerWidth <= 1024) {
        window.scrollTo({ top: 0, behavior: 'instant' });
    }

    // Open panel
    if (window.innerWidth <= 1024 && fab) {
        fab.classList.remove('active');
    }

    panel.classList.remove('closing');
    panel.classList.add('active');
    document.body.classList.add('balancer-active');
    if (window.mobileLayout && typeof window.mobileLayout.applyTransform === 'function') {
        setTimeout(() => window.mobileLayout.applyTransform(), 50);
    }

    // Disable scroll-collapse system and hide below-table-content
    window.disableScrollCollapseSystem();

    // Position on PC
    if (window.innerWidth > 1024 && typeof positionBalancerPC === 'function') {
        // Use setTimeout with a longer delay to ensure all animations/transitions complete
        setTimeout(positionBalancerPC, 100);
    }

    // Show loader initially
    const resultDiv = document.getElementById('balancer-result');
    if (resultDiv) {
        resultDiv.innerHTML = '<span class="placeholder-text">Уравнение появится здесь</span>';
    }
};

window.performBalance = function () {
    const input = document.getElementById('balancer-input');
    const resultDiv = document.getElementById('balancer-result');
    const errorDiv = document.getElementById('balancer-error');

    if (!input || !resultDiv) return;

    errorDiv.style.display = 'none';
    resultDiv.innerHTML = '<span class="placeholder-text">Вычисляю...</span>';

    setTimeout(() => {
        try {
            const query = input.value;
            if (!query.trim()) throw new Error("Введите уравнение");

            const balanced = balanceEquation(query);

            const formatted = formatChemicalHTML(balanced);
            resultDiv.innerHTML = formatted;

        } catch (e) {
            resultDiv.innerHTML = '';
            errorDiv.textContent = e.message.replace(/^Error:\s*/, '');
            errorDiv.style.display = 'block';
        }
    }, 50);
};

// Keep backwards compatibility aliases
window.toggleBalancerRealModule = window.toggleBalancer;
window.closeBalancerRealModule = window.closeBalancer;
window.toggleBalancerPanel = window.toggleBalancer;
window.closeBalancerPanel = window.closeBalancer;

window.fillBalance = function (equation) {
    const input = document.getElementById('balancer-input');
    if (input) {
        input.value = equation;
        performBalance();
    }
};

function positionBalancerPC() {
    if (window.innerWidth <= 1024) return;

    console.log('positionBalancerPC called');

    const panel = document.getElementById('balancer-panel');

    // Check if the table is scaled due to scroll-collapse
    const tableContainer = document.querySelector('.periodic-table-container');
    console.log('Table container:', tableContainer);
    console.log('Has scroll-collapsed class:', tableContainer && tableContainer.classList.contains('scroll-collapsed'));

    if (tableContainer && tableContainer.classList.contains('scroll-collapsed')) {
        console.log('Table is collapsed, showing in default position');
        // If table is collapsed, show balancer in default position (bottom-right)
        panel.style.position = 'fixed';
        panel.style.left = 'auto';  // Explicitly reset to avoid CSS conflicts
        panel.style.top = 'auto';   // Explicitly reset to avoid CSS conflicts
        panel.style.right = '20px';
        panel.style.bottom = '20px';
        panel.style.width = '320px';
        panel.style.maxHeight = '400px';
        panel.style.height = 'auto';
        panel.style.zIndex = '1000';
        panel.style.display = 'flex';
        panel.style.flexDirection = 'column';
        return;
    }

    // If table is not collapsed, position next to element K
    const elH = document.getElementById('H');
    const elK = document.getElementById('K');
    const elAl = document.getElementById('Al');
    const elMg = document.getElementById('Mg');

    console.log('Elements found:', { elH: !!elH, elK: !!elK, elAl: !!elAl, elMg: !!elMg });

    if (!elH || !elK || !elAl || !panel) {
        console.warn('Required elements not found');
        return;
    }

    const hRect = elH.getBoundingClientRect();
    const kRect = elK.getBoundingClientRect();
    const alRect = elAl.getBoundingClientRect();
    const mgRect = elMg ? elMg.getBoundingClientRect() : null;

    console.log('Element H rectangle:', {
        x: hRect.x, y: hRect.y,
        left: hRect.left, top: hRect.top,
        right: hRect.right, bottom: hRect.bottom,
        width: hRect.width, height: hRect.height
    });

    console.log('Element K rectangle:', {
        x: kRect.x, y: kRect.y,
        left: kRect.left, top: kRect.top,
        right: kRect.right, bottom: kRect.bottom,
        width: kRect.width, height: kRect.height
    });

    console.log('Element Al rectangle:', {
        x: alRect.x, y: alRect.y,
        left: alRect.left, top: alRect.top,
        right: alRect.right, bottom: alRect.bottom,
        width: alRect.width, height: alRect.height
    });

    if (mgRect) {
        console.log('Element Mg rectangle:', {
            x: mgRect.x, y: mgRect.y,
            left: mgRect.left, top: mgRect.top,
            right: mgRect.right, bottom: mgRect.bottom,
            width: mgRect.width, height: mgRect.height
        });
    } else {
        console.log('Element Mg not found, using fallback calculation');
    }

    // Calculate positions based on current view (accounting for any transforms)
    const mgRight = mgRect ? mgRect.right : (hRect.right + 80);
    const alLeft = alRect.left;
    const totalSpace = alLeft - mgRight; // Общее доступное пространство

    // Позиционируем панель в пустом пространстве таблицы:
    // - Слева: после Mg (2-й столбец)
    // - Справа: перед Al (13-й столбец)  
    // - Сверху: на уровне H (1-й ряд)
    // - Снизу: над K (4-й ряд)

    // Равные отступы со всех сторон
    const gap = Math.max(2, Math.round(hRect.width * 0.04));

    // Горизонтальные границы
    const panelLeft = Math.ceil(mgRight + gap);
    const panelRightLimit = Math.floor(alLeft - gap);
    const panelWidth = Math.max(0, panelRightLimit - panelLeft);

    // Вертикальные границы (равные отступы сверху и снизу)
    const extraTop = Math.min(10, Math.max(0, hRect.top - 6));
    let panelTop = hRect.top + gap - extraTop;
    let panelHeight = kRect.top - hRect.top - (gap * 2) + extraTop;
    const availableAbove = Math.max(0, Math.floor(hRect.top - 8));

    // Устанавливаем панель
    panel.style.position = 'fixed';
    panel.style.boxSizing = 'border-box';  // Важно! Ширина включает border
    panel.style.left = panelLeft + 'px';
    panel.style.top = panelTop + 'px';
    panel.style.right = 'auto';
    panel.style.bottom = 'auto';
    panel.style.width = panelWidth + 'px';
    panel.style.height = panelHeight + 'px';
    panel.style.maxHeight = panelHeight + 'px';
    panel.style.minHeight = '0';  // Отключаем min-height из CSS
    panel.style.zIndex = '1000';
    panel.style.display = 'flex';
    panel.style.flexDirection = 'column';

    console.log('Panel positioning:', {
        panelTop: panelTop,
        panelLeft: panelLeft,
        panelWidth: panelWidth,
        panelHeight: panelHeight,
        gap: gap
    });

    setTimeout(() => {
        const header = panel.querySelector('.calc-header');
        const content = panel.querySelector('.balancer-content');
        const inputRow = panel.querySelector('.balancer-input-row');
        const result = panel.querySelector('#balancer-result');
        const examples = panel.querySelector('.balancer-examples');

        if (header && content && inputRow && result) {
            const contentStyles = getComputedStyle(content);
            const paddingY = parseFloat(contentStyles.paddingTop) + parseFloat(contentStyles.paddingBottom);
            const gapY = parseFloat(contentStyles.rowGap || contentStyles.gap || 0);
            const minContent = inputRow.offsetHeight + result.offsetHeight + paddingY + gapY + 8;
            const minPanelHeight = header.offsetHeight + minContent + 8;

            if (panelHeight < minPanelHeight) {
                const extraTop = Math.min(availableAbove, Math.ceil(minPanelHeight - panelHeight));
                if (extraTop > 0) {
                    panelHeight += extraTop;
                    panelTop -= extraTop;
                    panel.style.top = panelTop + 'px';
                    panel.style.height = panelHeight + 'px';
                    panel.style.maxHeight = panelHeight + 'px';
                }
            }

            if (examples && examples.style.display === 'none') {
                examples.style.display = '';
            }
        }
    }, 90);

    // Также логируем реальные размеры панели после установки стилей
    setTimeout(() => {
        console.log('Actual panel dimensions after styling:', {
            offsetHeight: panel.offsetHeight,
            clientHeight: panel.clientHeight,
            scrollHeight: panel.scrollHeight,
            computedStyles: {
                height: getComputedStyle(panel).height,
                maxHeight: getComputedStyle(panel).maxHeight
            }
        });

        // Логируем размеры внутренних элементов
        const header = panel.querySelector('.calc-header');
        const inputRow = panel.querySelector('.balancer-input-row');
        const result = panel.querySelector('#balancer-result');
        const examples = panel.querySelector('.balancer-examples');

        if (header) {
            console.log('Header dimensions:', {
                offsetHeight: header.offsetHeight,
                clientHeight: header.clientHeight
            });
        }

        if (inputRow) {
            console.log('Input row dimensions:', {
                offsetHeight: inputRow.offsetHeight,
                clientHeight: inputRow.clientHeight
            });
        }

        if (result) {
            console.log('Result dimensions:', {
                offsetHeight: result.offsetHeight,
                clientHeight: result.clientHeight
            });
        }

        if (examples) {
            console.log('Examples dimensions:', {
                offsetHeight: examples.offsetHeight,
                clientHeight: examples.clientHeight
            });
        }
    }, 100);
}

window.addEventListener('resize', () => {
    const panel = document.getElementById('balancer-panel');
    if (panel && panel.classList.contains('active') && window.innerWidth > 1024) {
        // Use setTimeout with a longer delay to ensure all animations/transitions complete
        setTimeout(positionBalancerPC, 100);
    }
});


// --- МАТЕМАТИЧЕСКОЕ ЯДРО (БЕЗ ИЗМЕНЕНИЙ) ---

function balanceEquation(formulaStr) {
    formulaStr = normalizeInput(formulaStr);

    const parts = formulaStr.split(/=|->|→/);
    if (parts.length !== 2) throw new Error("Используйте знак '=' или '->'");

    const reactants = parseSide(parts[0]);
    const products = parseSide(parts[1]);

    if (reactants.length === 0 || products.length === 0) throw new Error("Проверьте формулу");

    const allCompounds = [...reactants, ...products];
    const allElements = new Set();

    allCompounds.forEach(comp => {
        Object.keys(comp.elements).forEach(el => allElements.add(el));
    });

    const elemsList = Array.from(allElements);
    if (elemsList.length === 0) throw new Error("Элементы не найдены");

    const matrix = [];
    elemsList.forEach(el => {
        const row = [];
        reactants.forEach(comp => row.push(comp.elements[el] || 0));
        products.forEach(comp => row.push(-(comp.elements[el] || 0)));
        matrix.push(row);
    });

    const coeffs = bruteForceSolver(matrix, allCompounds.length);
    if (!coeffs) throw new Error("Не удалось уравнять. Проверьте индексы.");

    let resultStr = "";

    for (let i = 0; i < reactants.length; i++) {
        const c = coeffs[i];
        resultStr += (i > 0 ? " + " : "") + (c > 1 ? `<span class='coeff'>${c}</span>` : "") + reactants[i].original;
    }

    resultStr += " = ";

    for (let i = 0; i < products.length; i++) {
        const c = coeffs[reactants.length + i];
        resultStr += (i > 0 ? " + " : "") + (c > 1 ? `<span class='coeff'>${c}</span>` : "") + products[i].original;
    }

    return resultStr;
}

function normalizeInput(str) {
    const map = {
        'А': 'A', 'а': 'a', 'В': 'B', 'С': 'C', 'с': 'c',
        'Е': 'E', 'е': 'e', 'Н': 'H', 'К': 'K', 'к': 'k',
        'М': 'M', 'м': 'm', 'О': 'O', 'о': 'o', '0': 'O',
        'Р': 'P', 'р': 'p', 'Т': 'T', 'т': 't', 'Х': 'X', 'х': 'x', 'У': 'Y', 'у': 'y'
    };
    return str.split('').map(char => map[char] || char).join('');
}

function parseSide(sideStr) {
    if (!sideStr) return [];
    return sideStr.split("+").map(s => {
        s = s.trim();
        if (!s) return null;
        return { original: s, elements: parseFormula(s) };
    }).filter(item => item !== null);
}

function parseFormula(formula) {
    formula = formula.replace(/\s+/g, '');
    const elements = {};
    let i = 0;
    const len = formula.length;
    const stack = [{}];

    while (i < len) {
        const char = formula[i];
        if (char === '(' || char === '[') {
            stack.push({});
            i++;
        }
        else if (char === ')' || char === ']') {
            if (stack.length > 1) {
                const top = stack.pop();
                i++;
                let numStr = "";
                while (i < len && /\d/.test(formula[i])) {
                    numStr += formula[i];
                    i++;
                }
                const multiplier = numStr ? parseInt(numStr) : 1;
                const parent = stack[stack.length - 1];
                for (let el in top) {
                    parent[el] = (parent[el] || 0) + top[el] * multiplier;
                }
            } else { i++; }
        }
        else if (/[A-Z]/.test(char)) {
            let name = char;
            i++;
            if (i < len && /[a-z]/.test(formula[i])) {
                name += formula[i];
                i++;
            }
            let numStr = "";
            while (i < len && /\d/.test(formula[i])) {
                numStr += formula[i];
                i++;
            }
            const count = numStr ? parseInt(numStr) : 1;
            const current = stack[stack.length - 1];
            current[name] = (current[name] || 0) + count;
        }
        else { i++; }
    }
    while (stack.length > 1) {
        const top = stack.pop();
        const parent = stack[stack.length - 1];
        for (let el in top) parent[el] = (parent[el] || 0) + top[el];
    }
    return stack[0];
}

function bruteForceSolver(matrix, n) {
    const MAX_COEFF = 15;
    const coeffs = new Array(n).fill(1);
    while (true) {
        let valid = true;
        for (let r = 0; r < matrix.length; r++) {
            let sum = 0;
            for (let c = 0; c < n; c++) {
                sum += matrix[r][c] * coeffs[c];
            }
            if (sum !== 0) { valid = false; break; }
        }
        if (valid) return coeffs;
        let i = 0;
        while (i < n) {
            coeffs[i]++;
            if (coeffs[i] <= MAX_COEFF) break;
            else { coeffs[i] = 1; i++; }
        }
        if (i === n) return null;
    }
}

function formatChemicalHTML(str) {
    return str.replace(/([a-zA-Z\)\]])(\d+)/g, '$1<sub>$2</sub>');
}


============================================================
ФАЙЛ: .\js\modules\calculator.js
============================================================

// =========================================
// МОДУЛЬ: КАЛЬКУЛЯТОР МОЛЯРНОЙ МАССЫ
// =========================================

const dropZone = document.getElementById('drop-zone');
let calcAtoms = []; // Здесь храним состав формулы: [{symbol: 'H', count: 2, mass: 1}, ...]

// Делаем элементы таблицы перетаскиваемыми (Desktop + Mobile)
document.querySelectorAll('.element').forEach(el => {
    el.setAttribute('draggable', 'true');

    // Desktop: Drag & Drop
    el.addEventListener('dragstart', (e) => {
        const symbol = el.dataset.symbol || '';
        e.dataTransfer.setData('symbol', symbol);
        // Safari/Chromium fallback: some engines reliably transfer only text/plain.
        e.dataTransfer.setData('text/plain', symbol);
        e.dataTransfer.effectAllowed = 'copy';
        el.style.opacity = '0.5';
    });

    el.addEventListener('dragend', () => {
        el.style.opacity = '1';
    });

    // Mobile: Touch events
    let touchData = {
        symbol: null,
        startTime: 0,
        startX: 0,
        startY: 0,
        isScrolling: false
    };

    // Порог движения для определения скролла (в пикселях)
    const SCROLL_THRESHOLD = 10;

    el.addEventListener('touchstart', function (e) {
        const calcPanel = document.getElementById('calc-panel');
        if (!calcPanel.classList.contains('active')) {
            return;
        }

        const touch = e.touches[0];
        touchData.symbol = this.dataset.symbol;
        touchData.startTime = Date.now();
        touchData.startX = touch.clientX;
        touchData.startY = touch.clientY;
        touchData.isScrolling = false;

        this.style.opacity = '0.5';
    });

    el.addEventListener('touchmove', function (e) {
        const calcPanel = document.getElementById('calc-panel');
        if (!calcPanel.classList.contains('active') || !touchData.symbol) {
            return;
        }

        const touch = e.touches[0];

        // Проверяем, сдвинулся ли палец достаточно для скролла
        const deltaX = Math.abs(touch.clientX - touchData.startX);
        const deltaY = Math.abs(touch.clientY - touchData.startY);

        if (deltaX > SCROLL_THRESHOLD || deltaY > SCROLL_THRESHOLD) {
            touchData.isScrolling = true;
            // Возвращаем нормальную прозрачность если это скролл
            this.style.opacity = '1';
        }

        // Подсветка drop-zone только если это не скролл
        if (!touchData.isScrolling) {
            const dropZoneEl = document.getElementById('drop-zone');
            if (!dropZoneEl) return;
            const dropZoneRect = dropZoneEl.getBoundingClientRect();

            if (
                touch.clientX >= dropZoneRect.left &&
                touch.clientX <= dropZoneRect.right &&
                touch.clientY >= dropZoneRect.top &&
                touch.clientY <= dropZoneRect.bottom
            ) {
                dropZoneEl.classList.add('drag-over');
            } else {
                dropZoneEl.classList.remove('drag-over');
            }
        }
    });

    el.addEventListener('touchend', function (e) {
        this.style.opacity = '1';

        const calcPanel = document.getElementById('calc-panel');
        const dropZoneEl = document.getElementById('drop-zone');
        if (!dropZoneEl) return;

        if (!calcPanel.classList.contains('active') || !touchData.symbol) {
            touchData.symbol = null;
            return;
        }

        // Если это был скролл — не добавляем элемент
        if (touchData.isScrolling) {
            touchData.symbol = null;
            touchData.isScrolling = false;
            dropZoneEl.classList.remove('drag-over');
            return;
        }

        const touch = e.changedTouches[0];
        const dropZoneRect = dropZoneEl.getBoundingClientRect();

        const isOverDropZone = (
            touch.clientX >= dropZoneRect.left &&
            touch.clientX <= dropZoneRect.right &&
            touch.clientY >= dropZoneRect.top &&
            touch.clientY <= dropZoneRect.bottom
        );

        const tapDuration = Date.now() - touchData.startTime;

        // Добавляем только если:
        // 1. Палец над drop-zone, ИЛИ
        // 2. Короткий тап (<400мс) БЕЗ движения
        if (isOverDropZone || tapDuration < 400) {
            addAtomToCalculator(touchData.symbol);
        }

        touchData.symbol = null;
        touchData.isScrolling = false;
        dropZoneEl.classList.remove('drag-over');
    });
});

// Настройка зоны сброса
if (dropZone) {
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('drag-over');
    });

    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('drag-over');
    });

    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('drag-over');

        const symbol = e.dataTransfer.getData('symbol') || e.dataTransfer.getData('text/plain');
        if (symbol) {
            addAtomToCalculator(symbol);
        }
    });
}

// Добавление атома в список
function addAtomToCalculator(symbol) {
    let mass = 0;

    // 1. ОКРУГЛЕНИЕ МАСС (кроме хлора)
    if (symbol === 'Cl') {
        mass = 35.5;
    } else {
        const element = elementsData[symbol];
        if (element && element.atomicMass) {
            const rawMass = String(element.atomicMass);
            // Убираем скобки и округляем до целого
            mass = Math.round(parseFloat(rawMass.replace('[', '').replace(']', '')));
        }
    }

    const existingAtom = calcAtoms.find(a => a.symbol === symbol);

    if (existingAtom) {
        // Если атом есть, увеличиваем на 1 (целое число)
        changeQuantity(existingAtom, 1);
    } else {
        const atomObj = {
            id: Date.now(),
            symbol: symbol,
            mass: mass,
            count: 1 // По умолчанию 1
        };
        calcAtoms.push(atomObj);

        const placeholder = document.querySelector('.drop-placeholder');
        if (placeholder) placeholder.style.display = 'none';

        renderAtomUI(atomObj);
        updateTotalMass();
    }
}

// Отрисовка UI элемента в калькуляторе
function renderAtomUI(atomObj) {
    const dropZone = document.getElementById('drop-zone');
    const atomDiv = document.createElement('div');
    atomDiv.className = 'calc-atom';
    atomDiv.dataset.id = atomObj.id;

    // Упрощенная верстка: Символ | Кнопка-Инпут-Кнопка | Крестик
    atomDiv.innerHTML = `
        <span class="calc-atom-symbol">${atomObj.symbol}</span>
        <div class="calc-controls">
            <button class="calc-btn-minus" type="button">−</button>
            <input type="number" class="calc-atom-count" value="${atomObj.count}" min="0.1" step="any">
            <button class="calc-btn-plus" type="button">+</button>
        </div>
        <span class="calc-atom-remove">&times;</span>
    `;

    dropZone.appendChild(atomDiv);

    // --- ОБРАБОТЧИКИ ---

    const input = atomDiv.querySelector('input');

    // 1. Ручной ввод (разрешаем дробные, минимум 0.1)
    input.onchange = (e) => {
        let val = parseFloat(e.target.value);
        // Если ввели некорректное значение или < 0.1, сбрасываем на 1
        if (isNaN(val) || val < 0.1) val = 1;

        atomObj.count = val;
        input.value = val;
        updateTotalMass();
    };

    // 2. Кнопка Минус (СТРОГО ЦЕЛЫЕ, МИНИМУМ 1)
    atomDiv.querySelector('.calc-btn-minus').onclick = () => {
        let current = atomObj.count;
        let newVal;

        // Если текущее число дробное, округляем вниз
        // Если целое — отнимаем 1
        if (Math.floor(current) === current) {
            newVal = current - 1;
        } else {
            newVal = Math.floor(current);
        }

        // Минимум 1
        if (newVal < 1) newVal = 1;

        atomObj.count = newVal;
        input.value = newVal;
        updateTotalMass();
    };

    // 3. Кнопка Плюс (СТРОГО ЦЕЛЫЕ)
    atomDiv.querySelector('.calc-btn-plus').onclick = () => {
        let current = atomObj.count;
        let newVal;

        // Если дробное, округляем вверх
        // Если целое — прибавляем 1
        if (Math.floor(current) === current) {
            newVal = current + 1;
        } else {
            newVal = Math.ceil(current);
        }

        atomObj.count = newVal;
        input.value = newVal;
        updateTotalMass();
    };

    // 4. Удаление
    atomDiv.querySelector('.calc-atom-remove').onclick = () => {
        calcAtoms = calcAtoms.filter(a => a.id !== atomObj.id);
        atomDiv.remove();
        if (calcAtoms.length === 0) {
            const placeholder = document.querySelector('.drop-placeholder');
            if (placeholder) placeholder.style.display = 'flex';
        }
        updateTotalMass();
    };
}

// Вспомогательная функция для обновления массы при добавлении дубликата
function changeQuantity(atomObj, change) {
    // Тут просто +1 к существующему (целые числа)
    let newVal = atomObj.count + change;
    // На всякий случай проверка минимума
    if (newVal < 1) newVal = 1;

    atomObj.count = newVal;

    // Обновляем инпут в DOM
    const atomDiv = document.querySelector(`.calc-atom[data-id="${atomObj.id}"]`);
    if (atomDiv) {
        const input = atomDiv.querySelector('input');
        input.value = newVal;
    }

    updateTotalMass();
}

// Подсчет общей массы
function updateTotalMass() {
    let total = 0;
    calcAtoms.forEach(atom => {
        total += atom.mass * atom.count;
    });

    // Округляем итог до сотых (на случай дробных коэффициентов)
    total = parseFloat(total.toFixed(2));

    const resultEl = document.querySelector('.mass-value');
    if (resultEl) {
        resultEl.innerHTML = `${total} <span class="unit">г/моль</span>`;
    }
}

// Очистка
function clearCalculator() {
    calcAtoms = [];
    const atoms = dropZone.querySelectorAll('.calc-atom');
    atoms.forEach(el => el.remove());

    const placeholder = dropZone.querySelector('.drop-placeholder');
    if (placeholder) placeholder.style.display = 'block';

    updateTotalMass();
}

// Переключение калькулятора
function toggleCalc(event) {
    const PANEL_ANIM_MS = 360;
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }

    const calcPanel = document.getElementById('calc-panel');
    const fab = document.getElementById('fab-container');
    const themeToggle = document.getElementById('theme-toggle');
    if (!calcPanel) return;

    // Закрытие панели всегда должно срабатывать.
    if (calcPanel.classList.contains('active')) {
        if (calcPanel.classList.contains('closing')) return;
        calcPanel.classList.add('closing');
        document.body.classList.remove('calc-active');
        if (themeToggle) themeToggle.style.display = '';
        resetFabPosition();
        setTimeout(() => {
            calcPanel.classList.remove('active', 'closing');
            if (window.innerWidth <= 1024 && fab) {
                fab.classList.add('active');
            }
        }, PANEL_ANIM_MS);
        return;
    }

    const isElementModalOpen = document.body.classList.contains('modal-open');
    const isBalancerOpen = document.body.classList.contains('balancer-active');
    const isSolubilityOpen = document.body.classList.contains('solubility-open');
    const isReactionsOpen = document.body.classList.contains('reactions-open');
    const filtersPanel = document.getElementById('filters-panel');
    const isFiltersOpen = filtersPanel && filtersPanel.classList.contains('active');
    if (isElementModalOpen || isBalancerOpen || isSolubilityOpen || isReactionsOpen || isFiltersOpen) {
        return;
    }

    // При открытии калькулятора скрываем FAB меню только на мобильных устройствах
    if (window.innerWidth <= 1024 && fab) {
        fab.classList.remove('active');
        if (themeToggle) themeToggle.style.display = 'none';
    } else if (themeToggle) {
        themeToggle.style.display = '';
    }

    calcPanel.classList.remove('closing');
    calcPanel.classList.add('active');
    document.body.classList.add('calc-active');

    if (window.innerWidth > 1024) {
        positionCalculatorPC();
    } else {
        resetCalculatorPosition();
    }
}

// Позиционирование калькулятора на ПК
function positionCalculatorPC() {
    if (window.innerWidth <= 1024) return;

    const calcPanel = document.getElementById('calc-panel');
    const mg = document.getElementById('Mg');
    const al = document.getElementById('Al');
    const h = document.getElementById('H');
    const k = document.getElementById('K');

    if (!mg || !al || !h || !k || !calcPanel) return;

    const mgRect = mg.getBoundingClientRect();
    const alRect = al.getBoundingClientRect();
    const hRect = h.getBoundingClientRect();
    const kRect = k.getBoundingClientRect();

    const gap = Math.max(2, Math.round(hRect.width * 0.04));
    const left = Math.ceil(mgRect.right + gap);
    const right = Math.floor(alRect.left - gap);
    const width = Math.max(0, right - left);
    const top = Math.round(hRect.top + gap);
    const height = Math.max(0, Math.round(kRect.top - hRect.top - (gap * 2)));

    calcPanel.style.left = left + 'px';
    calcPanel.style.top = top + 'px';
    calcPanel.style.width = width + 'px';
    calcPanel.style.height = height + 'px';
}

function resetCalculatorPosition() {
    const calcPanel = document.getElementById('calc-panel');
    if (!calcPanel) return;

    calcPanel.style.left = '';
    calcPanel.style.top = '';
    calcPanel.style.width = '';
    calcPanel.style.height = '';
}

// Перепозиционирование при ресайзе
window.addEventListener('resize', () => {
    const calcPanel = document.getElementById('calc-panel');

    if (calcPanel && calcPanel.classList.contains('active')) {
        if (window.innerWidth > 1024) {
            positionCalculatorPC();
        } else {
            resetCalculatorPosition();
        }
    } else {
        resetFabPosition();
    }
});


============================================================
ФАЙЛ: .\js\modules\electron-config.js
============================================================

// =========================================
// ELECTRON-CONFIG.JS - Electron configuration modal
// =========================================

const electronConfigModal = document.getElementById('electron-config-modal');
const electronConfigClose = document.getElementById('electron-config-close');
const electronConfigHeading = document.getElementById('electron-config-heading');
const electronConfigSubtitle = document.getElementById('electron-config-subtitle');
const electronConfigSymbol = document.getElementById('electron-config-symbol');
const electronConfigNumber = document.getElementById('electron-config-number');
const electronConfigCharge = document.getElementById('electron-config-charge');
const electronConfigMass = document.getElementById('electron-config-mass');
const electronConfigShells = document.getElementById('electron-config-shells');
const electronConfigOrbitals = document.getElementById('electron-config-orbitals');
const electronConfigValence = document.getElementById('electron-config-valence');
const electronConfigShort = document.getElementById('electron-config-short');
const electronConfigFull = document.getElementById('electron-config-full');
const electronConfigOuterShell = document.getElementById('electron-config-outer-shell');
const electronConfigValenceElectrons = document.getElementById('electron-config-valence-electrons');
const ELECTRON_CONFIG_ANIM_MS = 360;

const orbitalCapacityMap = {
    s: 1,
    p: 3,
    d: 5,
    f: 7
};

const nobleGasConfigs = {
    He: '1s2',
    Ne: '1s2 2s2 2p6',
    Ar: '1s2 2s2 2p6 3s2 3p6',
    Kr: '1s2 2s2 2p6 3s2 3p6 4s2 3d10 4p6',
    Xe: '1s2 2s2 2p6 3s2 3p6 4s2 3d10 4p6 5s2 4d10 5p6',
    Rn: '1s2 2s2 2p6 3s2 3p6 4s2 3d10 4p6 5s2 4d10 5p6 6s2 4f14 5d10 6p6',
    Og: '1s2 2s2 2p6 3s2 3p6 4s2 3d10 4p6 5s2 4d10 5p6 6s2 4f14 5d10 6p6 7s2 5f14 6d10 7p6'
};

const nobleGasAtomicNumbers = [
    { symbol: 'He', atomicNumber: 2 },
    { symbol: 'Ne', atomicNumber: 10 },
    { symbol: 'Ar', atomicNumber: 18 },
    { symbol: 'Kr', atomicNumber: 36 },
    { symbol: 'Xe', atomicNumber: 54 },
    { symbol: 'Rn', atomicNumber: 86 },
    { symbol: 'Og', atomicNumber: 118 }
];

const aufbauOrder = [
    { n: 1, l: 's', cap: 2 },
    { n: 2, l: 's', cap: 2 },
    { n: 2, l: 'p', cap: 6 },
    { n: 3, l: 's', cap: 2 },
    { n: 3, l: 'p', cap: 6 },
    { n: 4, l: 's', cap: 2 },
    { n: 3, l: 'd', cap: 10 },
    { n: 4, l: 'p', cap: 6 },
    { n: 5, l: 's', cap: 2 },
    { n: 4, l: 'd', cap: 10 },
    { n: 5, l: 'p', cap: 6 },
    { n: 6, l: 's', cap: 2 },
    { n: 4, l: 'f', cap: 14 },
    { n: 5, l: 'd', cap: 10 },
    { n: 6, l: 'p', cap: 6 },
    { n: 7, l: 's', cap: 2 },
    { n: 5, l: 'f', cap: 14 },
    { n: 6, l: 'd', cap: 10 },
    { n: 7, l: 'p', cap: 6 }
];

const exceptionConfigs = {
    24: { from: { n: 4, l: 's', delta: -1 }, to: { n: 3, l: 'd', delta: 1 } },
    29: { from: { n: 4, l: 's', delta: -1 }, to: { n: 3, l: 'd', delta: 1 } },
    41: { from: { n: 5, l: 's', delta: -1 }, to: { n: 4, l: 'd', delta: 1 } },
    42: { from: { n: 5, l: 's', delta: -1 }, to: { n: 4, l: 'd', delta: 1 } },
    44: { from: { n: 5, l: 's', delta: -1 }, to: { n: 4, l: 'd', delta: 1 } },
    45: { from: { n: 5, l: 's', delta: -1 }, to: { n: 4, l: 'd', delta: 1 } },
    46: { from: { n: 5, l: 's', delta: -2 }, to: { n: 4, l: 'd', delta: 2 } },
    47: { from: { n: 5, l: 's', delta: -1 }, to: { n: 4, l: 'd', delta: 1 } },
    57: { from: { n: 5, l: 'd', delta: -1 }, to: { n: 4, l: 'f', delta: 1 } },
    64: { from: { n: 6, l: 's', delta: -1 }, to: { n: 5, l: 'd', delta: 1 } },
    78: { from: { n: 6, l: 's', delta: -1 }, to: { n: 5, l: 'd', delta: 1 } },
    79: { from: { n: 6, l: 's', delta: -1 }, to: { n: 5, l: 'd', delta: 1 } }
};

function normalizeConfigString(config) {
    if (!config) return '';

    let normalized = String(config)
        .replace(/&nbsp;/g, ' ')
        .replace(/<sup>(\d+)<\/sup>/g, '$1')
        .replace(/\s+/g, ' ')
        .trim();

    normalized = normalized.replace(/[¹²³⁴⁵⁶⁷⁸⁹⁰]/g, (match) => {
        const map = {
            '⁰': '0',
            '¹': '1',
            '²': '2',
            '³': '3',
            '⁴': '4',
            '⁵': '5',
            '⁶': '6',
            '⁷': '7',
            '⁸': '8',
            '⁹': '9'
        };
        return map[match] || match;
    });

    return normalized;
}

function formatConfig(orbitals) {
    if (!Array.isArray(orbitals) || orbitals.length === 0) return '-';
    return orbitals.map(item => `${item.n}${item.l}<sup>${item.electrons}</sup>`).join(' ');
}

function applyExceptionConfig(orbitals, atomicNumber) {
    const adjustment = exceptionConfigs[atomicNumber];
    if (!adjustment) return orbitals;

    const updated = orbitals.map(item => ({ ...item }));
    const from = updated.find(item => item.n === adjustment.from.n && item.l === adjustment.from.l);
    const to = updated.find(item => item.n === adjustment.to.n && item.l === adjustment.to.l);

    if (!from || !to) return orbitals;

    from.electrons = Math.max(0, from.electrons + adjustment.from.delta);
    to.electrons = Math.max(0, to.electrons + adjustment.to.delta);

    return updated;
}

function buildOrbitalsFromAtomicNumber(atomicNumber) {
    let remaining = atomicNumber;
    const orbitals = [];

    for (const entry of aufbauOrder) {
        if (remaining <= 0) break;
        const electrons = Math.min(remaining, entry.cap);
        orbitals.push({ n: entry.n, l: entry.l, electrons });
        remaining -= electrons;
    }

    return applyExceptionConfig(orbitals, atomicNumber);
}

function buildShellDistribution(orbitals) {
    const shellMap = {};
    orbitals.forEach(item => {
        shellMap[item.n] = (shellMap[item.n] || 0) + item.electrons;
    });

    return Object.keys(shellMap)
        .map(key => Number(key))
        .sort((a, b) => a - b)
        .map(key => shellMap[key]);
}

function buildShortConfig(orbitals, atomicNumber) {
    let remainingOrbitals = orbitals.map(item => ({ ...item }));
    let nobleGas = null;

    for (const item of nobleGasAtomicNumbers) {
        if (item.atomicNumber <= atomicNumber) {
            nobleGas = item;
        }
    }

    if (nobleGas) {
        let remaining = nobleGas.atomicNumber;
        const trimmed = [];

        for (const orbital of remainingOrbitals) {
            if (remaining <= 0) {
                trimmed.push({ ...orbital });
                continue;
            }
            if (remaining >= orbital.electrons) {
                remaining -= orbital.electrons;
            } else {
                trimmed.push({ ...orbital, electrons: orbital.electrons - remaining });
                remaining = 0;
            }
        }

        remainingOrbitals = trimmed;
    }

    const suffix = formatConfig(remainingOrbitals);
    if (!nobleGas || suffix === '-') return formatConfig(orbitals);
    return `[${nobleGas.symbol}] ${suffix}`;
}

function expandNobleGasConfig(config) {
    const normalized = normalizeConfigString(config);
    if (!normalized) return '';

    return normalized.replace(/\[([A-Za-z]{1,2})\]/g, (match, symbol) => {
        return nobleGasConfigs[symbol] || match;
    });
}

function parseElectronConfig(config) {
    const expanded = expandNobleGasConfig(config);
    if (!expanded) {
        return { orbitals: [], shellDistribution: [] };
    }

    const orbitals = [];
    const shellMap = {};
    const regex = /(\d+)([spdf])(\d+)/g;
    let match;

    while ((match = regex.exec(expanded)) !== null) {
        const n = Number(match[1]);
        const l = match[2];
        const electrons = Number(match[3]);
        orbitals.push({ n, l, electrons });
        shellMap[n] = (shellMap[n] || 0) + electrons;
    }

    const shellDistribution = Object.keys(shellMap)
        .map(key => Number(key))
        .sort((a, b) => a - b)
        .map(key => shellMap[key]);

    return { orbitals, shellDistribution };
}

function buildDerivedConfig(data) {
    const configSource = data.electronConfigFull || data.electronConfig || '';
    const parsed = parseElectronConfig(configSource);
    let orbitals = Array.isArray(data.orbitals) && data.orbitals.length > 0
        ? data.orbitals
        : parsed.orbitals;

    if ((!orbitals || orbitals.length === 0) && data.atomicNumber) {
        orbitals = buildOrbitalsFromAtomicNumber(Number(data.atomicNumber));
    }

    const shellDistribution = Array.isArray(data.shellDistribution) && data.shellDistribution.length > 0
        ? data.shellDistribution
        : buildShellDistribution(orbitals);

    const fullConfig = data.electronConfigFull || formatConfig(orbitals) || data.electronConfig || '-';
    const shortConfig = data.electronConfigShort || data.electronConfig || buildShortConfig(orbitals, Number(data.atomicNumber));

    return {
        orbitals,
        shellDistribution,
        fullConfig,
        shortConfig
    };
}

function getOuterShellInfo(shellDistribution) {
    if (!Array.isArray(shellDistribution) || shellDistribution.length === 0) {
        return { count: '-', level: 0 };
    }
    const level = shellDistribution.length;
    const count = shellDistribution[level - 1];
    return { count, level };
}

function getValenceElectrons(data, derived) {
    const block = data.block;
    const orbitals = derived.orbitals;
    if (!block || !Array.isArray(orbitals) || orbitals.length === 0) return '-';

    const maxN = Math.max(...orbitals.map(o => o.n));

    if (block === 's' || block === 'p') {
        // Валентные = электроны на внешнем уровне
        return orbitals
            .filter(o => o.n === maxN)
            .reduce((sum, o) => sum + o.electrons, 0);
    }

    if (block === 'd') {
        // Внешние s + незавершённые d предпоследнего уровня
        const outerS = orbitals
            .filter(o => o.n === maxN && o.l === 's')
            .reduce((sum, o) => sum + o.electrons, 0);
        const innerD = orbitals
            .filter(o => o.n === maxN - 1 && o.l === 'd')
            .reduce((sum, o) => sum + o.electrons, 0);
        return outerS + innerD;
    }

    if (block === 'f') {
        // Внешние s + незавершённые f
        const outerS = orbitals
            .filter(o => o.n === maxN && o.l === 's')
            .reduce((sum, o) => sum + o.electrons, 0);
        const innerF = orbitals
            .filter(o => o.l === 'f')
            .reduce((sum, o) => sum + o.electrons, 0);
        return outerS + innerF;
    }

    return '-';
}

function buildShells(shellDistribution) {
    if (!Array.isArray(shellDistribution) || shellDistribution.length === 0) {
        return '-';
    }

    return shellDistribution.map((count, index) =>
        `<div class="shell-level">
            <span class="shell-number">${index + 1}</span>
            <span class="shell-electrons">${count}e⁻</span>
        </div>`
    ).join('');
}

function getOrbitalCapacity(type) {
    return orbitalCapacityMap[type] || 0;
}

function splitElectrons(electrons, capacity) {
    const boxes = Array.from({ length: capacity }, () => 0);
    if (electrons <= 0 || capacity === 0) return boxes;

    const firstPass = Math.min(electrons, capacity);
    for (let i = 0; i < firstPass; i += 1) {
        boxes[i] = 1;
    }

    let remaining = electrons - firstPass;
    let index = 0;
    while (remaining > 0 && capacity > 0) {
        boxes[index] += 1;
        remaining -= 1;
        index = (index + 1) % capacity;
    }

    return boxes;
}

function renderOrbitalRow(orbital, index) {
    const capacity = getOrbitalCapacity(orbital.l);
    const boxes = splitElectrons(orbital.electrons, capacity);
    const label = `${orbital.n}${orbital.l}<sup>${orbital.electrons}</sup>`;

    const boxesMarkup = boxes.map(count => {
        const arrows = [
            count >= 1 ? '<span class="orbital-arrow up">&uarr;</span>' : '',
            count === 2 ? '<span class="orbital-arrow down">&darr;</span>' : ''
        ].join('');
        const filledClass = count > 0 ? ' filled' : '';
        return `<div class="orbital-box${filledClass}">${arrows}</div>`;
    }).join('');

    return `
        <div class="orbital-row" style="--step-index:${index}">
            <div class="orbital-label">${label}</div>
            <div class="orbital-boxes">${boxesMarkup}</div>
        </div>
    `;
}

function renderOrbitals(orbitals) {
    if (!Array.isArray(orbitals) || orbitals.length === 0) {
        return '<div class="electron-config-empty">Нет данных по орбиталям для этого элемента.</div>';
    }

    return orbitals.map((orbital, index) => renderOrbitalRow(orbital, index)).join('');
}

function renderElectronConfigModal(data) {
    if (!data) return;

    const derived = buildDerivedConfig(data);
    const symbol = data.symbol || '';
    const title = data.name ? `Строение атома ${data.name}` : 'Строение атома';
    const subtitle = data.name ? `${data.name}${symbol ? ` (${symbol})` : ''}` : symbol;

    if (electronConfigHeading) electronConfigHeading.textContent = title;
    if (electronConfigSubtitle) electronConfigSubtitle.textContent = subtitle;
    if (electronConfigSymbol) electronConfigSymbol.textContent = symbol;
    if (electronConfigNumber) electronConfigNumber.textContent = data.atomicNumber || '-';
    if (electronConfigCharge) electronConfigCharge.textContent = data.atomicNumber ? `+${data.atomicNumber}` : '';
    if (electronConfigMass) electronConfigMass.textContent = data.atomicMass ? `${data.atomicMass}` : '';

    if (electronConfigShells) {
        electronConfigShells.innerHTML = buildShells(derived.shellDistribution);
    }

    if (electronConfigOrbitals) {
        electronConfigOrbitals.innerHTML = renderOrbitals(derived.orbitals);
    }

    if (electronConfigValence) {
        electronConfigValence.textContent = data.valenceStates || '-';
    }

    const outerInfo = getOuterShellInfo(derived.shellDistribution);
    if (electronConfigOuterShell) {
        electronConfigOuterShell.textContent = outerInfo.count !== '-'
            ? `${outerInfo.count}  (${outerInfo.level}-й уровень)`
            : '-';
    }

    const valElectrons = getValenceElectrons(data, derived);
    if (electronConfigValenceElectrons) {
        electronConfigValenceElectrons.textContent = valElectrons;
    }

    if (electronConfigShort) {
        electronConfigShort.innerHTML = derived.shortConfig || '-';
    }

    if (electronConfigFull) {
        electronConfigFull.innerHTML = derived.fullConfig || '-';
    }
}

function openElectronConfigModal(data) {
    if (!electronConfigModal) return;
    renderElectronConfigModal(data);
    electronConfigModal.classList.remove('closing');
    electronConfigModal.style.display = 'flex';
    electronConfigModal.setAttribute('aria-hidden', 'false');
    document.body.classList.add('electron-config-open');
}

function closeElectronConfigModal() {
    if (!electronConfigModal) return;
    electronConfigModal.classList.add('closing');
    electronConfigModal.setAttribute('aria-hidden', 'true');
    setTimeout(() => {
        electronConfigModal.style.display = 'none';
        electronConfigModal.classList.remove('closing');
        document.body.classList.remove('electron-config-open');
    }, ELECTRON_CONFIG_ANIM_MS);
}

function initElectronConfig() {
    const elementInfo = document.getElementById('element-info');
    const content = document.querySelector('.electron-config-content');

    if (elementInfo) {
        elementInfo.addEventListener('click', (event) => {
            const trigger = event.target.closest('.electron-config-trigger');
            if (!trigger) return;
            if (!window.currentElementData) return;
            openElectronConfigModal(window.currentElementData);
        });

        elementInfo.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter' && event.key !== ' ') return;
            const trigger = event.target.closest('.electron-config-trigger');
            if (!trigger) return;
            event.preventDefault();
            if (!window.currentElementData) return;
            openElectronConfigModal(window.currentElementData);
        });
    }

    if (electronConfigClose) {
        electronConfigClose.addEventListener('click', closeElectronConfigModal);
    }

    if (electronConfigModal) {
        electronConfigModal.addEventListener('click', (event) => {
            if (event.target === electronConfigModal) {
                closeElectronConfigModal();
            }
        });
    }

    if (content) {
        const handleScroll = () => {
            content.classList.toggle('compact-header', content.scrollTop > 16);
        };
        content.addEventListener('scroll', handleScroll, { passive: true });
        handleScroll();
    }

    document.addEventListener('keydown', (event) => {
        if (event.key !== 'Escape') return;
        if (electronConfigModal && electronConfigModal.style.display === 'flex') {
            closeElectronConfigModal();
        }
    });
}

window.openElectronConfigModal = openElectronConfigModal;
window.closeElectronConfigModal = closeElectronConfigModal;
window.initElectronConfig = initElectronConfig;
window.getElectronConfigPreview = function (data) {
    if (!data) return '-';
    return buildDerivedConfig(data).shortConfig || '-';
};


============================================================
ФАЙЛ: .\js\modules\latex-export.js
============================================================

// =========================================
// МОДУЛЬ: ЭКСПОРТ ЭЛЕМЕНТА В PDF И LATEX
// =========================================

/**
 * Нормализация формулы (убираем индексы для поиска)
 */
function normalizeFormula(formula) {
    return formula.replace(/[⁺⁻⁰¹²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉]/g, (match) => {
        const map = {
            '⁺': '+', '⁻': '-', '⁰': '0', '¹': '1', '²': '2', '³': '3', '⁴': '4',
            '⁵': '5', '⁶': '6', '⁷': '7', '⁸': '8', '⁹': '9',
            '₀': '0', '₁': '1', '₂': '2', '₃': '3', '₄': '4',
            '₅': '5', '₆': '6', '₇': '7', '₈': '8', '₉': '9'
        };
        return map[match] || match;
    });
}

function getElementCompounds(symbol) {
    if (!window.solubilityData) {
        console.error('Данные таблицы растворимости не загружены');
        return [];
    }

    const compounds = [];
    const { cations, anions, defaults, exceptions } = window.solubilityData;

    const getSolubility = (cationFormula, anionFormula) => {
        const cationKey = normalizeFormula(cationFormula);
        const anionKey = normalizeFormula(anionFormula);
        const exceptionKey = `${cationKey}-${anionKey}`;
        return exceptions[exceptionKey] !== undefined ? exceptions[exceptionKey] : (defaults[anionKey] || "R");
    };

    const getCompoundColor = (cationFormula, anionFormula, solubility) => {
        const cationKey = normalizeFormula(cationFormula);
        const anionKey = normalizeFormula(anionFormula);
        const key = cationKey + '-' + anionKey;
        const colorDb = (typeof substanceColors !== 'undefined' ? substanceColors : window.substanceColors);
        if (colorDb && colorDb[key]) {
            const color = colorDb[key];
            if (color === 'colorless') return '\u0411\u0435\u0441\u0446\u0432\u0435\u0442\u043d\u044b\u0439 \u0440\u0430\u0441\u0442\u0432\u043e\u0440';
            if (color === 'white') return '\u0411\u0435\u043b\u044b\u0439';
            return color;
        }
        if (solubility === 'R') {
            if (anionKey === 'MnO4-') return '#8b008b';
            if (anionKey === 'CrO42-') return '#ffff00';
            if (anionKey === 'Cr2O72-') return '#ff8c00';
            return '\u0411\u0435\u0441\u0446\u0432\u0435\u0442\u043d\u044b\u0439 \u0440\u0430\u0441\u0442\u0432\u043e\u0440';
        }
        return '\u2014';
    };

    const getDecompositionReaction = (cationFormula, anionFormula) => {
        const cationKey = normalizeFormula(cationFormula);
        const anionKey = normalizeFormula(anionFormula);
        const key = `${cationKey}-${anionKey}`;
        if (window.decompositionReactions && window.decompositionReactions[key]) {
            return {
                equation: window.decompositionReactions[key].equation || '—',
                description: window.decompositionReactions[key].description || '—'
            };
        }
        return null;
    };

    cations.forEach(cation => {
        if (cation.f.includes(symbol) || cation.n.includes(symbol)) {
            anions.forEach(anion => {
                compounds.push({
                    type: 'cation',
                    cation: cation.f,
                    anion: anion.f,
                    solubility: getSolubility(cation.f, anion.f),
                    color: null,
                    decomposition: getDecompositionReaction(cation.f, anion.f)
                });
            });
        }
    });

    anions.forEach(anion => {
        if (anion.f.includes(symbol) || anion.n.includes(symbol)) {
            cations.forEach(cation => {
                compounds.push({
                    type: 'anion',
                    cation: cation.f,
                    anion: anion.f,
                    solubility: getSolubility(cation.f, anion.f),
                    color: null,
                    decomposition: getDecompositionReaction(cation.f, anion.f)
                });
            });
        }
    });

    compounds.forEach((compound) => {
        compound.color = getCompoundColor(compound.cation, compound.anion, compound.solubility);
    });

    return compounds;
}

/**
 * Рендерит формулу в красивый HTML с помощью KaTeX
 */
function renderFormula(formula) {
    if (!formula) return '—';
    try {
        return katex.renderToString(`\\ce{${formula}}`, {
            throwOnError: false,
            trust: true
        });
    } catch (e) {
        return formula;
    }
}

function safeValue(value, fallback = '—') {
    if (value === null || value === undefined) return fallback;
    if (typeof value === 'number' && Number.isNaN(value)) return fallback;
    if (typeof value === 'string' && value.trim().toLowerCase() === 'null') return fallback;
    const str = String(value).trim();
    return str.length === 0 ? fallback : str;
}

function toSuperscript(text) {
    const map = {
        '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴',
        '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹'
    };
    return String(text).split('').map(ch => map[ch] || ch).join('');
}

function formatElectronConfigForPDF(config) {
    if (!config) return '—';
    let str = String(config);
    str = str.replace(/<sup>(\d+)<\/sup>/gi, (_, digits) => toSuperscript(digits));
    str = str.replace(/<[^>]*>/g, '');
    return safeValue(str, '—');
}

function getCategoryLabel(data) {
    const category = (data && data.category) ? String(data.category) : '';
    if (category) return category;
    return '—';
}

/**
 * Генерирует HTML секцию для аллотропов
 */
function generateAllotropesHTML(data) {
    if (!data.allotropes && !data.extraAllotropes) return '';

    const allAllotropes = [
        ...Object.values(data.allotropes || {}),
        ...Object.values(data.extraAllotropes || {})
    ];

    if (allAllotropes.length === 0) return '';

    return `
        <div class="pdf-section">
            <h2 class="pdf-subtitle" style="color: #D36A8E;">Аллотропные модификации</h2>
            <table class="pdf-table">
                <thead>
                        <tr style="background-color: #D36A8E;">
                        <th>Название</th>
                        <th>Свойства</th>
                        <th>Структура</th>
                    </tr>
                </thead>
                <tbody>
                    ${allAllotropes.map((allo, i) => `
                        <tr class="${i % 2 === 0 ? 'even' : 'odd'}">
                            <td>
                                <strong>${allo.name}</strong><br>
                                <span style="font-size: smaller; color: #666;">${allo.alloDiscoveryYear || ''}</span>
                            </td>
                            <td>
                                ${allo.density ? `<div>ρ: ${allo.density}</div>` : ''}
                                ${allo.meltingPoint ? `<div>Tₘ: ${allo.meltingPoint}</div>` : ''}
                                ${allo.color ? `<div>${allo.color}</div>` : ''}
                            </td>
                            <td>
                                ${allo.structure || '—'}<br>
                                <span style="font-size: smaller; font-style: italic;">${allo.alloFacts || ''}</span>
                            </td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        </div>
    `;
}

/**
 * Генерирует HTML шаблон для экспорта
 */
function generatePDFTemplate(data, compounds, options = {}) {
    const solubilityText = { 'R': 'Растворим', 'M': 'Малорастворим', 'N': 'Нерастворим', 'D': 'Разлагается', 'O': 'Не существует' };
    const totalCompounds = Number(options.compoundsTotal) || compounds.length;
    const shownCompounds = Number(options.compoundsShown) || compounds.length;
    const isCompoundsTrimmed = totalCompounds > shownCompounds;
    const elementName = safeValue(data.name || data.symbol);
    const elementSymbol = safeValue(data.symbol);
    const elementNumber = safeValue(data.atomicNumber);
    const elementCategory = getCategoryLabel(data);
    const periodValue = safeValue(data.period);
    const groupValue = safeValue(data.group, data && data.category && /актиноид/i.test(data.category) ? 'актиноиды' : '—');
    const electronConfigText = formatElectronConfigForPDF(data.electronConfigFull || data.electronConfig);

    const colorNameToHex = {
    "\u0431\u0435\u043b\u044b\u0439": "#ffffff",
    "\u0431\u0435\u0441\u0446\u0432\u0435\u0442\u043d\u044b\u0439": "#f0f8ff",
    "\u0447\u0451\u0440\u043d\u044b\u0439": "#000000",
    "\u043a\u0440\u0430\u0441\u043d\u044b\u0439": "#ff0000",
    "\u0441\u0438\u043d\u0438\u0439": "#1e88e5",
    "\u0433\u043e\u043b\u0443\u0431\u043e\u0439": "#81d4fa",
    "\u0437\u0435\u043b\u0451\u043d\u044b\u0439": "#43a047",
    "\u0437\u0435\u043b\u0435\u043d\u044b\u0439": "#43a047",
    "\u0436\u0451\u043b\u0442\u044b\u0439": "#fdd835",
    "\u0436\u0435\u043b\u0442\u044b\u0439": "#fdd835",
    "\u043e\u0440\u0430\u043d\u0436\u0435\u0432\u044b\u0439": "#fb8c00",
    "\u0444\u0438\u043e\u043b\u0435\u0442\u043e\u0432\u044b\u0439": "#8e24aa",
    "\u0440\u043e\u0437\u043e\u0432\u044b\u0439": "#ec407a",
    "\u0431\u0443\u0440\u044b\u0439": "#8d6e63",
    "\u043a\u043e\u0440\u0438\u0447\u043d\u0435\u0432\u044b\u0439": "#8d6e63",
    "\u043a\u0440\u0435\u043c\u043e\u0432\u044b\u0439": "#fffdd0",
    "\u0431\u043b\u0435\u0434\u043d\u043e-\u0436\u0451\u043b\u0442\u044b\u0439": "#fff9b0",
    "\u0441\u0438\u043d\u0435-\u0437\u0435\u043b\u0451\u043d\u044b\u0439": "#48d1cc"
};

const hexToColorName = Object.keys(colorNameToHex).reduce((acc, name) => {
    acc[colorNameToHex[name].toLowerCase()] = name;
    return acc;
}, {});

const normalizeColorValue = (value) => {
    if (!value) return null;
    if (typeof value === 'object' && value.color) value = value.color;
    if (typeof value !== 'string') return null;
    const raw = value.trim();
    if (!raw) return null;
    const lower = raw.toLowerCase();
    if (lower === 'colorless' || lower === '\u0431\u0435\u0441\u0446\u0432\u0435\u0442\u043d\u044b\u0439 \u0440\u0430\u0441\u0442\u0432\u043e\u0440' || lower === '\u0431\u0435\u0441\u0446\u0432\u0435\u0442\u043d\u044b\u0439') return '#f0f8ff';
    if (lower === 'white' || lower === '\u0431\u0435\u043b\u044b\u0439') return '#ffffff';
    if (lower.startsWith('#')) return lower;
    if (lower.startsWith('rgb')) return lower;
    return colorNameToHex[lower] || null;
};

const hexToRgb = (hex) => {
    const value = hex.replace('#', '').trim();
    if (value.length === 3) {
        const r = parseInt(value[0] + value[0], 16);
        const g = parseInt(value[1] + value[1], 16);
        const b = parseInt(value[2] + value[2], 16);
        return { r, g, b };
    }
    if (value.length === 6) {
        const r = parseInt(value.slice(0, 2), 16);
        const g = parseInt(value.slice(2, 4), 16);
        const b = parseInt(value.slice(4, 6), 16);
        return { r, g, b };
    }
    return null;
};

const approximateColorNameFromHex = (hex) => {
    const rgb = hexToRgb(hex);
    if (!rgb) return '\u0426\u0432\u0435\u0442\u043d\u043e\u0439';
    const { r, g, b } = rgb;
    if (r > 235 && g > 235 && b > 235) return '\u0411\u0435\u043b\u044b\u0439';
    if (r < 40 && g < 40 && b < 40) return '\u0427\u0451\u0440\u043d\u044b\u0439';
    if (r > 200 && g > 200 && b < 120) return '\u0416\u0451\u043b\u0442\u044b\u0439';
    if (r > 200 && g > 120 && b < 80) return '\u041e\u0440\u0430\u043d\u0436\u0435\u0432\u044b\u0439';
    if (r > 160 && g < 90 && b < 90) return '\u041a\u0440\u0430\u0441\u043d\u044b\u0439';
    if (b > 150 && r < 100 && g < 120) return '\u0421\u0438\u043d\u0438\u0439';
    if (g > 150 && r < 120 && b < 120) return '\u0417\u0435\u043b\u0451\u043d\u044b\u0439';
    if (r > 150 && b > 150 && g < 120) return '\u0424\u0438\u043e\u043b\u0435\u0442\u043e\u0432\u044b\u0439';
    return '\u0426\u0432\u0435\u0442\u043d\u043e\u0439';
};

const describeColorValue = (value) => {
    if (!value) return '\u2014';
    if (typeof value === 'string') {
        const raw = value.trim();
        if (!raw) return '\u2014';
        const lower = raw.toLowerCase();
        if (lower === 'colorless') return '\u0411\u0435\u0441\u0446\u0432\u0435\u0442\u043d\u044b\u0439 \u0440\u0430\u0441\u0442\u0432\u043e\u0440';
        if (lower === 'white') return '\u0411\u0435\u043b\u044b\u0439';
        if (lower.startsWith('#')) {
            const mapped = hexToColorName[lower];
            if (mapped) {
                return mapped.charAt(0).toUpperCase() + mapped.slice(1);
            }
            return approximateColorNameFromHex(lower);
        }
        if (lower.startsWith('rgb')) return '\u0426\u0432\u0435\u0442\u043d\u043e\u0439';
    }
    return safeValue(value);
};

const renderColorSwatch = (value) => {
        const hex = normalizeColorValue(value);
        const label = describeColorValue(value);
        if (!hex) return label;
        const border = (hex === '#ffffff' || hex === '#f0f8ff') ? 'border:1px solid #ccc;' : '';
        return `<span style="display:inline-flex;align-items:center;gap:6px;">
            <span style="width:10px;height:10px;border-radius:50%;background:${hex};${border}"></span>
            <span>${label}</span>
        </span>`;
    };

    let compoundsHTML = '';
    if (compounds.length > 0) {
        compoundsHTML = `
            <div class="pdf-section">
                <h2 class="pdf-subtitle" style="color: #7E57C2;">Соединения из таблицы растворимости</h2>
                <table class="pdf-table compounds-table">
                    <colgroup>
                        <col style="width: 32%;">
                        <col style="width: 25%;">
                        <col style="width: 29%;">
                        <col style="width: 14%;">
                    </colgroup>
                    <thead>
                        <tr style="background-color: #7E57C2;">
                            <th>Формула</th>
                            <th>Растворимость</th>
                            <th>Цвет</th>
                            <th>Реакция</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${compounds.map((c, i) => `
                            <tr class="pdf-row ${i % 2 === 0 ? 'even' : 'odd'}">
                                <td>${renderFormula(c.cation)} + ${renderFormula(c.anion)}</td>
                                <td>${solubilityText[c.solubility] || c.solubility}</td>
                                <td>${renderColorSwatch(c.color)}</td>
                                <td>${c.decomposition ? renderFormula(c.decomposition.equation) : '—'}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                ${isCompoundsTrimmed ? `<p class="pdf-note">Показаны первые ${shownCompounds} соединений из ${totalCompounds} для стабильной генерации PDF.</p>` : ''}
            </div>
        `;
    }

    return `
        <div class="pdf-container">
            <div class="pdf-hero">
                <h1 class="pdf-title">${elementName} (${elementSymbol})</h1>
                <p class="pdf-hero-line">№ ${elementNumber} • ${elementCategory}</p>
            </div>
            <p class="pdf-meta">Сгенерировано: ${new Date().toLocaleDateString('ru-RU')}</p>

            <div class="pdf-section">
                <h2 class="pdf-subtitle" style="color: #4A90E2;">Базовая информация</h2>
                <table class="pdf-table">
                    <thead><tr style="background-color: #4A90E2;"><th>Свойство</th><th>Значение</th></tr></thead>
                    <tbody>
                        <tr><td>Атомный номер</td><td>${elementNumber}</td></tr>
                        <tr><td>Атомная масса</td><td>${safeValue(data.atomicMass)}</td></tr>
                        <tr><td>Период/Группа</td><td>${periodValue} / ${groupValue}</td></tr>
                        <tr><td>Электронная конфигурация</td><td>${electronConfigText}</td></tr>
                        <tr><td>Электроотрицательность</td><td>${safeValue(data.electronegativity)}</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="pdf-section">
                <h2 class="pdf-subtitle" style="color: #4C9A74;">Физические свойства</h2>
                <table class="pdf-table">
                    <thead><tr style="background-color: #4C9A74;"><th>Свойство</th><th>Значение</th></tr></thead>
                    <tbody>
                        <tr><td>Плотность</td><td>${safeValue(data.density)}</td></tr>
                        <tr><td>Температура плавления</td><td>${safeValue(data.meltingPoint)}</td></tr>
                        <tr><td>Температура кипения</td><td>${safeValue(data.boilingPoint)}</td></tr>
                        <tr><td>Состояние (20°C)</td><td>${safeValue(data.state)}</td></tr>
                        <tr><td>Цвет</td><td>${safeValue(data.color)}</td></tr>
                    </tbody>
                </table>
            </div>

            <div class="pdf-section">
                <h2 class="pdf-subtitle" style="color: #C98A3A;">История и факты</h2>
                <div class="pdf-text-block">
                    <p><strong>Открытие:</strong> ${safeValue(data.discoveryYear)} (${safeValue(data.discoverer)})</p>
                    <p><strong>Происхождение названия:</strong> ${safeValue(data.nameOrigin)}</p>
                    ${data.facts ? `<p><strong>Факты:</strong> ${Array.isArray(data.facts) ? data.facts.join(' ') : data.facts}</p>` : ''}
                </div>
            </div>

            ${generateAllotropesHTML(data)}


            ${compoundsHTML}
            
            <style>
                .pdf-container {
                    font-family: "Noto Sans", "DejaVu Sans", "Segoe UI", "Arial Unicode MS", Arial, sans-serif;
                    padding: 20px;
                    color: #333;
                    -webkit-font-smoothing: antialiased;
                    text-rendering: optimizeLegibility;
                }
                .pdf-container, .pdf-container * { box-sizing: border-box; }
                .pdf-hero { margin-bottom: 6px; }
                .pdf-title { text-align: left; color: #2B5C91; border-bottom: 2px solid #2B5C91; padding-bottom: 6px; margin: 0; }
                .pdf-hero-line { margin: 8px 0 0; color: #555; font-size: 12px; }
                .pdf-meta { text-align: center; color: #666; font-size: 10px; margin-bottom: 30px; }
                .pdf-subtitle { font-size: 16px; margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
                .pdf-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 12px; }
                .pdf-table th { color: white; padding: 8px; text-align: left; }
                .pdf-table td { padding: 8px; border-bottom: 1px solid #eee; }
                .pdf-table tr.even { background-color: #f9f9f9; }
                .compounds-table { table-layout: fixed; width: 100%; font-size: 11px; }
                .compounds-table th, .compounds-table td {
                    white-space: normal;
                    overflow-wrap: anywhere;
                    word-break: break-word;
                    vertical-align: top;
                }
                .compounds-table thead { display: table-header-group; }
                .compounds-table tbody { display: table-row-group; }
                .compounds-table tr { break-inside: avoid; page-break-inside: avoid; }
                .compounds-table th:nth-child(4), .compounds-table td:nth-child(4) { text-align: center; }
                .pdf-section { break-inside: avoid-page; page-break-inside: avoid; }
                .katex { font-size: 1.1em; }
                .pdf-note { margin-top: 8px; color: #666; font-size: 11px; }
            </style>
        </div>
    `;
}

/**
 * ГЛАВНАЯ ФУНКЦИЯ: Экспорт в PDF (Client-side)
 */
const PDF_MAX_COMPOUNDS = 180;
const PDF_LIB_CANDIDATES = [
    'https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js',
    'https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js',
    'https://unpkg.com/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js'
];

function hasHtml2PdfSupport() {
    return typeof window.html2pdf === 'function';
}

function hasCanvasPdfSupport() {
    return typeof window.html2canvas === 'function' && !!(window.jspdf && window.jspdf.jsPDF);
}

function loadScriptWithTimeout(src, timeoutMs = 15000) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.crossOrigin = 'anonymous';

        let settled = false;
        const finish = (err) => {
            if (settled) return;
            settled = true;
            clearTimeout(timerId);
            if (err) reject(err);
            else resolve();
        };

        const timerId = setTimeout(() => {
            finish(new Error(`Timeout loading ${src}`));
        }, timeoutMs);

        script.onload = () => finish(null);
        script.onerror = () => finish(new Error(`Failed to load ${src}`));
        (document.head || document.documentElement).appendChild(script);
    });
}

async function ensurePdfLibrariesLoaded() {
    if (hasHtml2PdfSupport() || hasCanvasPdfSupport()) {
        return;
    }

    for (const src of PDF_LIB_CANDIDATES) {
        try {
            await loadScriptWithTimeout(src);
        } catch (error) {
            console.warn('[PDF export] library load failed:', src, error);
        }

        if (hasHtml2PdfSupport() || hasCanvasPdfSupport()) {
            return;
        }
    }

    throw new Error('PDF libraries are not loaded (html2pdf/html2canvas/jsPDF)');
}

/**
 * Экспорт элемента в PDF (client-side)
 */
async function exportElementToPDF(elementData) {
    let button = null;
    let container = null;
    try {
        if (window.ChemLoader && window.ChemLoader.show) {
            window.ChemLoader.show();
        }

        button = document.querySelector('.pdf-export-icon-btn');
        if (button) {
            button.classList.add('loading');
        }

        if (!elementData || !elementData.symbol) {
            throw new Error('Element data is missing');
        }

        if (typeof window.loadSolubility === 'function') {
            try {
                await window.loadSolubility();
            } catch (error) {
                console.warn('[PDF export] failed to load solubility data:', error);
            }
        }

        await ensurePdfLibrariesLoaded();

        const allCompounds = getElementCompounds(elementData.symbol);
        const compounds = allCompounds.slice(0, PDF_MAX_COMPOUNDS);
        const htmlContent = generatePDFTemplate(elementData, compounds, {
            compoundsTotal: allCompounds.length,
            compoundsShown: compounds.length
        });

        container = document.createElement('div');
        container.innerHTML = htmlContent;
        container.style.position = 'fixed';
        container.style.left = '0';
        container.style.top = '0';
        container.style.width = '794px';
        container.style.minHeight = '1123px';
        container.style.backgroundColor = '#ffffff';
        container.style.pointerEvents = 'none';
        container.style.zIndex = '-2147483647';
        container.style.boxSizing = 'border-box';
        container.setAttribute('aria-hidden', 'true');
        document.body.appendChild(container);

        if (document.fonts && document.fonts.ready) {
            await document.fonts.ready;
        }

        await new Promise((resolve) => setTimeout(resolve, 60));
        await new Promise((resolve) => requestAnimationFrame(() => requestAnimationFrame(resolve)));

        const safeName = String(elementData.name || 'element')
            .replace(/[\\/:*?"<>|]+/g, '_')
            .trim();
        const fileName = `${elementData.symbol}_${safeName}.pdf`;
        const targetNode = container.firstElementChild || container;
        const renderWidth = 760;

        targetNode.style.width = `${renderWidth}px`;
        targetNode.style.boxSizing = 'border-box';

        let exported = false;

        if (hasHtml2PdfSupport()) {
            try {
                await window.html2pdf().set({
                    margin: [8, 8, 8, 8],
                    filename: fileName,
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: {
                        scale: 1.15,
                        useCORS: true,
                        backgroundColor: '#ffffff',
                        scrollX: 0,
                        scrollY: 0,
                        x: 0,
                        y: 0,
                        windowWidth: renderWidth
                    },
                    jsPDF: {
                        unit: 'mm',
                        format: 'a4',
                        orientation: 'portrait',
                        putOnlyUsedFonts: true,
                        compress: true
                    },
                    pagebreak: {
                        mode: ['css', 'legacy'],
                        avoid: ['tr', '.pdf-row', '.pdf-no-break']
                    }
                }).from(targetNode).save();
                exported = true;
            } catch (error) {
                console.warn('[PDF export] html2pdf failed, trying html2canvas/jsPDF fallback:', error);
            }
        }

        if (!exported && hasCanvasPdfSupport()) {
            const canvas = await window.html2canvas(targetNode, {
                scale: 1.15,
                useCORS: true,
                backgroundColor: '#ffffff',
                scrollX: 0,
                scrollY: 0,
                x: 0,
                y: 0,
                windowWidth: renderWidth,
                windowHeight: Math.max(targetNode.scrollHeight || 1123, 1123)
            });

            if (!canvas || !canvas.width || !canvas.height) {
                throw new Error('Canvas render failed');
            }

            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                unit: 'mm',
                format: 'a4',
                orientation: 'portrait',
                putOnlyUsedFonts: true,
                compress: true
            });

            const pageWidth = pdf.internal.pageSize.getWidth();
            const pageHeight = pdf.internal.pageSize.getHeight();
            const imageWidth = pageWidth;
            const imageHeight = (canvas.height * imageWidth) / canvas.width;
            const imageData = canvas.toDataURL('image/jpeg', 0.98);

            pdf.addImage(imageData, 'JPEG', 0, 0, imageWidth, imageHeight, undefined, 'FAST');
            let renderedHeight = pageHeight;
            while (renderedHeight < imageHeight) {
                pdf.addPage();
                pdf.addImage(imageData, 'JPEG', 0, -renderedHeight, imageWidth, imageHeight, undefined, 'FAST');
                renderedHeight += pageHeight;
            }

            pdf.save(fileName);
            exported = true;
        }

        if (!exported) {
            throw new Error('PDF libraries are not loaded (html2pdf/html2canvas/jsPDF)');
        }
    } catch (error) {
        console.error('Ошибка при генерации PDF:', error);
        alert('Не удалось создать PDF. Открой консоль и пришли текст ошибки.');
    } finally {
        if (container && container.parentNode) {
            container.parentNode.removeChild(container);
        }

        if (button) {
            button.classList.remove('loading');
        }
        const activeBtn = document.querySelector('.pdf-export-icon-btn');
        if (activeBtn) {
            activeBtn.classList.remove('loading');
        }

        if (window.ChemLoader && window.ChemLoader.hide) {
            window.ChemLoader.hide();
        }
    }
}

// ��������� ������������� ����
window.exportElementToLaTeX = exportElementToPDF;
window.generateElementPDF = exportElementToPDF;


============================================================
ФАЙЛ: .\js\modules\mobile-layout.js
============================================================

(function () {
    'use strict';

    const CONFIG = {
        TOP_MARGIN: 20,
        BOTTOM_GAP: 15,
        MIN_SCALE: 0.4,
        MAX_SCALE: 1.0,
        BODY_PADDING: 10,
        DEBUG: false
    };

    let state = {
        wrapperCreated: false,
        originalHeight: null
    };

    function isMobile() {
        return window.innerWidth <= 1024;
    }

    function getAbsoluteTop(element) {
        let top = 0;
        let el = element;
        while (el) {
            top += el.offsetTop;
            el = el.offsetParent;
        }
        return top;
    }

    function ensureWrapper() {
        if (!isMobile()) return null;

        let wrapper = document.getElementById('mobile-table-wrapper');
        if (wrapper) {
            state.wrapperCreated = true;
            return wrapper;
        }

        const container = document.querySelector('.container');
        const lanthanides = document.querySelector('.lanthanides');
        const actinides = document.querySelector('.actinides');

        if (!container) return null;

        wrapper = document.createElement('div');
        wrapper.id = 'mobile-table-wrapper';

        // ВАЖНО:
        // 1. align-self: center — даем контейнеру центрироваться родителем.
        // 2. transform-origin: top left — масштабируем от левого края.
        wrapper.style.cssText = `
            width: max-content; 
            min-width: 100%; 
            margin: 0; 
            align-self: center; 
            box-sizing: border-box; 
            transform-origin: top left; 
            will-change: transform; 
            backface-visibility: hidden;
        `;

        const parent = container.parentNode;
        parent.insertBefore(wrapper, container);

        wrapper.appendChild(container);
        if (lanthanides) wrapper.appendChild(lanthanides);
        if (actinides) wrapper.appendChild(actinides);

        state.wrapperCreated = true;
        return wrapper;
    }

    function applyTableStyles() {
        if (!isMobile()) return;


        const container = document.querySelector('.container');
        const lanthanides = document.querySelector('.lanthanides');
        const actinides = document.querySelector('.actinides');
        const allElements = document.querySelectorAll('.element');

        const availableHeight = window.innerHeight - 160;
        let CELL_H = Math.floor(availableHeight / 11);
        CELL_H = Math.min(55, Math.max(38, CELL_H));

        const CELL_W = 58;
        const LA_HEIGHT = Math.floor(CELL_H * 0.75);
        const GAP = 3;

        const FONT_SYM = Math.floor(CELL_H * 0.4) + 'px';
        const FONT_NAME = Math.max(9, Math.floor(CELL_H * 0.18)) + 'px';
        const FONT_NUM = '10px';

        const tableWidth = (18 * CELL_W) + (17 * GAP);

        if (container) {
            container.style.cssText = `
                display: grid !important;
                grid-template-columns: repeat(18, ${CELL_W}px) !important;
                grid-template-rows: repeat(7, ${CELL_H}px) !important;
                gap: ${GAP}px !important;
                width: ${tableWidth}px !important;
                min-width: ${tableWidth}px !important;
                margin: 0 !important;
                margin-left: 0 !important;
                margin-bottom: 10px !important;
            `;
        }

        const subTableWidth = (15 * CELL_W) + (14 * GAP);

        [lanthanides, actinides].forEach(el => {
            if (!el) return;
            el.style.cssText = `
                display: grid !important;
                grid-template-columns: repeat(15, ${CELL_W}px) !important;
                grid-template-rows: ${LA_HEIGHT}px !important; 
                gap: ${GAP}px !important;
                width: ${subTableWidth}px !important;
                margin-top: 5px !important;
                margin-left: ${(3 * CELL_W) + (3 * GAP)}px !important;
            `;
        });

        allElements.forEach(el => {
            const isLaOrAc = el.parentElement?.classList.contains('lanthanides') ||
                el.parentElement?.classList.contains('actinides');

            el.style.cssText = `
                position: relative !important;
                display: flex !important;
                flex-direction: column !important;
                box-sizing: border-box !important;
                border: 1px solid rgba(0,0,0,0.1) !important;
                padding: 0 !important;
                margin: 0 !important;
                width: ${CELL_W}px !important;
                height: ${isLaOrAc ? LA_HEIGHT : CELL_H}px !important;
            `;

            const symbol = el.querySelector('.symbol');
            if (symbol) {
                symbol.style.cssText = `
                    font-size: ${FONT_SYM} !important;
                    font-weight: bold !important;
                    line-height: 1 !important;
                    position: absolute !important;
                    top: 40% !important; 
                    left: 50% !important;
                    transform: translate(-50%, -50%) !important;
                    margin: 0 !important;
                `;
            }

            const name = el.querySelector('.name');
            if (name) {
                name.style.cssText = `
                    font-size: ${FONT_NAME} !important;
                    position: absolute !important;
                    bottom: 2px !important;
                    left: 50% !important;
                    transform: translateX(-50%) !important;
                    width: 96% !important;
                    text-align: center !important;
                    line-height: 0.95 !important;
                `;
            }

            const num = el.querySelector('.atomic-number');
            if (num) {
                num.style.cssText = `
                    font-size: ${FONT_NUM} !important;
                    position: absolute !important;
                    top: 2px !important;
                    left: 3px !important;
                    line-height: 1 !important;
                `;
            }
        });
    }

    function applyCalcActiveTransform() {
        if (!isMobile()) return;

        const wrapper = document.getElementById('mobile-table-wrapper');

        // ИЗМЕНЕНИЕ: Ищем ЛЮБУЮ активную панель (калькулятор или уравнитель)
        let activePanel = document.querySelector('.calc-panel.active, .balancer-panel.active');
        if (!activePanel) {
            if (document.body.classList.contains('calc-active')) {
                activePanel = document.getElementById('calc-panel');
            } else if (document.body.classList.contains('balancer-active')) {
                activePanel = document.getElementById('balancer-panel');
            }
        }

        // Если нет враппера или нет активной панели — выходим
        if (!wrapper || !activePanel) return;

        const wrapperHeight = wrapper.offsetHeight || state.originalHeight || 1;
        state.originalHeight = wrapperHeight;

        // Берем полную ширину контента для расчетов
        const wrapperWidth = wrapper.scrollWidth;

        // ИЗМЕНЕНИЕ: Считаем высоту именно той панели, которая сейчас открыта
        const panelHeight = activePanel.offsetHeight || (window.innerHeight * 0.25);

        // Масштаб
        // Оставляем небольшие отступы, чтобы таблица не прилипала
        const availableHeight = window.innerHeight - panelHeight - CONFIG.TOP_MARGIN - CONFIG.BOTTOM_GAP;
        let scale = availableHeight / wrapperHeight;
        scale = Math.max(CONFIG.MIN_SCALE, Math.min(CONFIG.MAX_SCALE, scale));

        // Вертикаль (Центрирование)
        const naturalTopDocument = getAbsoluteTop(wrapper);
        const currentScroll = window.scrollY;
        const naturalTopViewport = naturalTopDocument - currentScroll;

        // Высота таблицы после масштабирования
        const scaledHeight = wrapperHeight * scale;

        // Свободное пространство над панелью
        const freeSpaceAbove = window.innerHeight - panelHeight;

        // Целевая позиция (отступ сверху), чтобы таблица была по центру свободного места
        // Но не выше TOP_MARGIN
        let targetTop = (freeSpaceAbove - scaledHeight) / 2;
        targetTop = Math.max(CONFIG.TOP_MARGIN, targetTop);

        const translateY = targetTop - naturalTopViewport;

        // Горизонталь (умное центрирование)
        const scaledWidth = wrapperWidth * scale;
        const windowWidth = window.innerWidth;
        let translateX = 0;

        if (scaledWidth < windowWidth) {
            translateX = (windowWidth - scaledWidth) / 2;
        }

        wrapper.style.transition = 'transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';
        wrapper.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    function resetTransform() {
        const wrapper = document.getElementById('mobile-table-wrapper');
        if (wrapper) {
            wrapper.style.transition = 'transform 0.3s cubic-bezier(0.4, 0.0, 0.2, 1)';
            wrapper.style.transform = 'none';
        }
    }

    function init() {
        if (!isMobile()) return;

        ensureWrapper();
        applyTableStyles();

        requestAnimationFrame(() => {
            if (document.body.classList.contains('calc-active') || document.body.classList.contains('balancer-active')) {
                applyCalcActiveTransform();
            }
        });
    }



    const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
            if (mutation.attributeName === 'class') {
                const isCalcActive = document.body.classList.contains('calc-active');
                const isBalancerActive = document.body.classList.contains('balancer-active');
                const isActive = isCalcActive || isBalancerActive;

                if (isActive) {
                    applyCalcActiveTransform();
                    setTimeout(applyCalcActiveTransform, 300);
                } else {
                    resetTransform();
                }
            }
        }
    });

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            init();
            observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
        });
    } else {
        init();
        observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
    }

    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            state.originalHeight = null;
            init();
        }, 200);
    });

    window.mobileLayout = { init, applyTransform: applyCalcActiveTransform, resetTransform };

    // Добавить после применения стилей таблицы:
    if (isMobile()) {
        document.body.style.overflowY = 'hidden';
        document.body.classList.add('scroll-locked');
    }
})();


============================================================
ФАЙЛ: .\js\modules\modal.js
============================================================

// =========================================
// МОДУЛЬ: МОДАЛЬНОЕ ОКНО
// С поддержкой FLIP-анимаций
// =========================================

// =========================================
// Функция сворачивания/разворачивания секций
// =========================================
function toggleSection(groupName) {
    const section = document.querySelector(`.info-group.${groupName}`);
    const content = document.querySelector(`.info-group.${groupName} .group-content`);
    const title = document.querySelector(`.info-group.${groupName} .group-title`);

    if (!content || !section || !title) return;

    if (content.classList.contains('collapsed')) {
        content.classList.remove('collapsed');
        section.classList.remove('collapsed');
        title.innerHTML = title.innerHTML.replace('▼', '▶ ');
    }
    else {
        content.classList.add('collapsed');
        section.classList.add('collapsed');
        title.innerHTML = title.innerHTML.replace('▶ ', '▼ ');
    }
}

// =========================================
// Глобальные переменные
// =========================================
const modal = document.getElementById("modal");
const closeBtn = document.getElementsByClassName("close")[0];
const elementInfo = document.getElementById("element-info");
const elementTitle = document.getElementById("element-title");
const tabsPlaceholder = document.getElementById("allotrope-tabs-placeholder");

let lastClickedElement = null;
let extraAllotropesExpanded = false; // Флаг: показаны ли дополнительные аллотропы

// =========================================
// Рендеринг содержимого модального окна
// =========================================
function renderModalContent(data) {
    // Сохраняем данные текущего элемента для экспорта в PDF
    window.currentElementData = data;

    // 1. ЗАПОМИНАЕМ ТЕКУЩЕЕ СОСТОЯНИЕ (какие секции свернуты)
    const currentStates = {};
    document.querySelectorAll('.info-group').forEach(group => {
        const type = group.classList[1];
        if (type) {
            currentStates[type] = group.classList.contains('collapsed');
        }

    });

    // Формируем HTML для физических свойств
    let physicalContentHTML = `
        <p><strong>Плотность:</strong> ${data.density || '—'}</p>
        <p><strong>Температура плавления:</strong> ${data.meltingPoint || '—'}</p>
        <p><strong>Температура кипения:</strong> ${data.boilingPoint || '—'}</p>
        <p><strong>Состояние (20°C):</strong> ${data.state || '—'}</p>
        <p><strong>Цвет:</strong> ${data.color || '—'}</p>
    `;

    if (data.structure) physicalContentHTML += `<p class="allo-specific"><strong>Структура:</strong> ${data.structure}</p>`;
    if (data.hardness) physicalContentHTML += `<p class="allo-specific"><strong>Твёрдость:</strong> ${data.hardness}</p>`;
    if (data.conductivity) physicalContentHTML += `<p class="allo-specific"><strong>Проводимость:</strong> ${data.conductivity}</p>`;
    if (data.properties) physicalContentHTML += `<p class="allo-specific"><strong>Свойства:</strong> ${data.properties}</p>`;

    // Обработка applications и facts (могут быть массивами или строками)
    const applicationsText = Array.isArray(data.applications)
        ? data.applications.join(', ')
        : (data.applications || '—');

    const factsText = Array.isArray(data.facts)
        ? data.facts.join(' ')
        : (data.facts || '—');

    const previewConfig = typeof window.getElectronConfigPreview === 'function'
        ? window.getElectronConfigPreview(data)
        : (data.electronConfigShort || data.electronConfig || '-');
    const electronConfigRow = `<p class="electron-config-row electron-config-trigger" data-electron-config="true" tabindex="0" role="button" title="Открыть электронную конфигурацию">
            <strong>Электронная конфигурация:</strong>
            <span class="electron-config-value">${previewConfig}</span>
            <span class="electron-config-action">Открыть</span>
        </p>`;

    // Рендерим HTML
    elementInfo.innerHTML = `
        <div class="groups-container">
            <section class="info-group basic">
                <h3 class="group-title" onclick="toggleSection('basic')">▶ Базовая информация</h3>
                <div class="group-content">
                    <p><strong>Номер:</strong> ${data.atomicNumber || '—'}</p>
                    <p><strong>Масса:</strong> ${data.atomicMass || '—'}</p>
                    <p><strong>Период:</strong> ${data.period || '—'}</p>
                    <p><strong>Группа:</strong> ${data.group || '—'}</p>
                    <p><strong>Блок:</strong> ${data.block || '—'}</p>
                    <p><strong>Категория:</strong> ${data.category || '—'}</p>
                    ${electronConfigRow}
                    <p><strong>Электроотрицательность:</strong> ${data.electronegativity || '—'}</p>
                </div>
            </section>
            <section class="info-group physical">
                <h3 class="group-title" onclick="toggleSection('physical')">▶ Физические свойства</h3>
                <div class="group-content">
                    ${physicalContentHTML}
                </div>
            </section>
            <section class="info-group history">
                <h3 class="group-title" onclick="toggleSection('history')">▶ История и практика</h3>
                <div class="group-content">
                    <p><strong>Год открытия элемента:</strong> ${data.discoveryYear || '—'}</p>
                    <p><strong>Кто открыл элемент:</strong> ${data.discoverer || '—'}</p>
                    ${data.alloDiscoveryYear ? `<p><strong>Год открытия формы:</strong> ${data.alloDiscoveryYear}</p>` : ''}
                    ${data.alloDiscoverer ? `<p><strong>Кто открыл форму:</strong> ${data.alloDiscoverer}</p>` : ''}
                    <p><strong>Происхождение названия:</strong> ${data.nameOrigin || '—'}</p>
                    <p><strong>Области применения:</strong> ${applicationsText}</p>
                </div>
            </section>
            <section class="info-group facts">
                <h3 class="group-title" onclick="toggleSection('facts')">▶ Интересные факты</h3>
                <div class="group-content">
                    <p>${factsText}</p>
                    ${data.alloFacts ? `<p><strong>Об этой форме:</strong> ${data.alloFacts}</p>` : ''}
                </div>
            </section>
                </div>
            </section>
        </div>
    `;

    // 2. ВОССТАНАВЛИВАЕМ СОСТОЯНИЕ
    Object.keys(currentStates).forEach(type => {
        if (currentStates[type] === true) {
            const section = document.querySelector(`.info-group.${type}`);
            const content = document.querySelector(`.info-group.${type} .group-content`);
            const title = document.querySelector(`.info-group.${type} .group-title`);

            if (section && content && title) {
                section.classList.add('collapsed');
                content.classList.add('collapsed');
                title.innerHTML = title.innerHTML.replace('▶ ', '▼ ');
            }
        }
    });
}

// =========================================
// Функция создания табов аллотропов
// =========================================
function createAllotropeTabs(mainData) {
    tabsPlaceholder.innerHTML = '';
    extraAllotropesExpanded = false;

    const hasMainAllotropes = mainData.allotropes && Object.keys(mainData.allotropes).length > 0;
    const hasExtraAllotropes = mainData.extraAllotropes && Object.keys(mainData.extraAllotropes).length > 0;

    // Если нет аллотропов вообще — просто рендерим основные данные
    if (!hasMainAllotropes) {
        renderModalContent(mainData);
        return;
    }

    const allotropeKeys = Object.keys(mainData.allotropes);

    // Если только один аллотроп и нет дополнительных — не показываем табы
    if (allotropeKeys.length === 1 && !hasExtraAllotropes) {
        const mergedData = { ...mainData, ...mainData.allotropes[allotropeKeys[0]] };
        renderModalContent(mergedData);
        return;
    }

    // Создаём табы для основных аллотропов
    allotropeKeys.forEach((key, index) => {
        const btn = document.createElement('button');
        btn.className = 'allotrope-tab';
        btn.innerText = mainData.allotropes[key].name;
        btn.dataset.allotropeKey = key;
        btn.dataset.isExtra = 'false';

        btn.onclick = () => {
            document.querySelectorAll('.allotrope-tab').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const mergedData = { ...mainData, ...mainData.allotropes[key] };
            renderModalContent(mergedData);
        };

        tabsPlaceholder.appendChild(btn);

        // Активируем первый таб по умолчанию
        if (index === 0) {
            btn.click();
        }
    });

    // Если есть дополнительные аллотропы — добавляем кнопку "+ Ещё"
    if (hasExtraAllotropes) {
        const moreBtn = document.createElement('button');
        moreBtn.className = 'allotrope-tab more-btn';
        moreBtn.innerText = '+ Ещё';
        moreBtn.title = 'Показать дополнительные аллотропы';

        moreBtn.onclick = () => {
            if (extraAllotropesExpanded) {
                // Скрываем дополнительные табы
                document.querySelectorAll('.allotrope-tab[data-is-extra="true"]').forEach(tab => {
                    tab.remove();
                });
                moreBtn.innerText = '+ Ещё';
                moreBtn.classList.remove('expanded');
                extraAllotropesExpanded = false;
            } else {
                // Показываем дополнительные табы
                const extraKeys = Object.keys(mainData.extraAllotropes);
                extraKeys.forEach(key => {
                    const btn = document.createElement('button');
                    btn.className = 'allotrope-tab extra-tab';
                    btn.innerText = mainData.extraAllotropes[key].name;
                    btn.dataset.allotropeKey = key;
                    btn.dataset.isExtra = 'true';

                    btn.onclick = () => {
                        document.querySelectorAll('.allotrope-tab').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        const mergedData = { ...mainData, ...mainData.extraAllotropes[key] };
                        renderModalContent(mergedData);
                    };

                    // Вставляем перед кнопкой "Ещё"
                    tabsPlaceholder.insertBefore(btn, moreBtn);
                });

                moreBtn.innerText = '− Скрыть';
                moreBtn.classList.add('expanded');
                extraAllotropesExpanded = true;
            }
        };

        tabsPlaceholder.appendChild(moreBtn);
    }
}

// =========================================
// Анимация разлёта элементов
// =========================================
function scatterElements() {
    const modalRect = document.querySelector('.modal-content').getBoundingClientRect();
    const modalCenterX = modalRect.left + modalRect.width / 2;
    const modalCenterY = modalRect.top + modalRect.height / 2;

    document.body.classList.add('elements-scattered');
    document.body.classList.remove('elements-returning');

    const elements = document.querySelectorAll('.element');

    elements.forEach(el => {
        el.style.setProperty('transition', 'transform 0.5s cubic-bezier(0.5, 0.9, 0.5, 1.0)', 'important');
        if (!el.style.transform) {
            el.style.transform = 'translate(0, 0)';
        }
    });

    requestAnimationFrame(() => {
        elements.forEach(el => {
            const rect = el.getBoundingClientRect();
            const elCenterX = rect.left + rect.width / 2;
            const elCenterY = rect.top + rect.height / 2;

            let dirX = elCenterX - modalCenterX;
            let dirY = elCenterY - modalCenterY;

            const distance = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
            dirX = dirX / distance;
            dirY = dirY / distance;

            const randomOffset = 100 + Math.random() * 100;

            const moveX = dirX * randomOffset + (Math.random() - 0.5) * 50;
            const moveY = dirY * randomOffset + (Math.random() - 0.5) * 50;

            el.style.transform = `translate(${moveX}px, ${moveY}px)`;
        });
    });
}

function returnElements() {
    document.body.classList.remove('elements-scattered');
    document.body.classList.add('elements-returning');

    const elements = document.querySelectorAll('.element');
    elements.forEach(el => {
        el.style.setProperty('transition', 'transform 0.3s cubic-bezier(0.4, 0.05, 0.8, 1.0)', 'important');
        el.style.transform = 'translate(0, 0)';
    });

    setTimeout(() => {
        document.body.classList.remove('elements-returning');
        elements.forEach(el => {
            el.style.removeProperty('transform');
            el.style.removeProperty('transition');
        });
    }, 320);
}

// =========================================
// Обработчики кликов по элементам
// =========================================
document.querySelectorAll('.element').forEach(el => {
    el.addEventListener('click', () => {
        // Проверяем, открыт ли другой полноэкранный UI/панель.
        if (
            document.body.classList.contains('calc-active') ||
            document.body.classList.contains('balancer-active') ||
            document.body.classList.contains('modal-open') ||
            document.body.classList.contains('reactions-open') ||
            document.body.classList.contains('solubility-open')
        ) {
            return;
        }
        lastClickedElement = el;

        // Данные элемента
        const symbol = el.dataset.symbol;
        const mainData = elementsData[symbol] || {};
        if (!mainData.symbol) {
            mainData.symbol = symbol;
        }
        elementTitle.innerText = `${mainData.name || symbol} (${symbol})`;
        if (window.spawnAtom) {
            window.spawnAtom(mainData.atomicNumber, mainData.period);
        }
        createAllotropeTabs(mainData);

        const fab = document.getElementById('fab-container');
        if (fab && fab.classList.contains('active')) {
            fab.classList.remove('active');
        }

        // Открываем модалку
        modal.style.display = "flex";
        document.body.classList.add('modal-open');

        // Закрываем панель фильтров при открытии модалки элемента
        const filtersPanel = document.getElementById('filters-panel');
        if (filtersPanel && filtersPanel.classList.contains('active')) {
            if (!filtersPanel.classList.contains('closing')) {
                filtersPanel.classList.add('closing');
                setTimeout(() => {
                    filtersPanel.classList.remove('active', 'closing');
                }, 360);
            }
        }

        // Блокируем скролл основной страницы
        document.body.style.overflow = "hidden";

        // Запускаем разлёт элементов ТОЛЬКО если экран широкий (компьютер)
        if (window.innerWidth > 1024) {
            // Вычисляем координаты для CSS-анимации
            const rect = el.getBoundingClientRect();
            const elementCenterX = rect.left + rect.width / 2;
            const elementCenterY = rect.top + rect.height / 2;
            const screenCenterX = window.innerWidth / 2;
            const screenCenterY = window.innerHeight / 2;

            modal.style.setProperty('--start-x', (elementCenterX - screenCenterX) + 'px');
            modal.style.setProperty('--start-y', (elementCenterY - screenCenterY) + 'px');

            setTimeout(scatterElements, 50);
        }

        modal.classList.remove('closing');
    });
});

// =========================================
// Закрытие модального окна
// =========================================
function closeModal() {
    // Возвращаем элементы только на ПК
    if (window.clearAtom) {
        window.clearAtom();
    }
    if (window.innerWidth > 1024) {
        returnElements();
    }

    modal.classList.add('closing');
    document.body.classList.remove('modal-open');

    // Возвращаем скролл
    document.body.style.overflow = "";

    setTimeout(() => {
        modal.style.display = "none";
        modal.classList.remove('closing');
    }, 360);
}

// Экспортируем для использования в других модулях
window.closeModal = closeModal;

closeBtn.onclick = closeModal;

window.addEventListener('click', function (event) {
    if (event.target === modal) {
        closeModal();
    }
});


============================================================
ФАЙЛ: .\js\modules\pdf-export.js
============================================================

// =========================================
// МОДУЛЬ: ЭКСПОРТ ЭЛЕМЕНТА В PDF
// =========================================

/**
 * Получает все соединения элемента из таблицы растворимости
 * @param {string} symbol - Символ химического элемента
 * @returns {Array} Массив объектов с данными о соединениях
 */
function getElementCompounds(symbol) {
    if (!window.solubilityData) {
        console.error('Данные таблицы растворимости не загружены');
        return [];
    }

    const compounds = [];
    const { cations, anions, defaults, exceptions } = window.solubilityData;

    // Нормализация формулы (убираем индексы для поиска)
    const normalizeFormula = (formula) => {
        return formula.replace(/[⁺⁻⁰¹²³⁴⁵⁶⁷⁸⁹₀₁₂₃₄₅₆₇₈₉]/g, (match) => {
            const map = {
                '⁺': '+', '⁻': '-', '⁰': '0', '¹': '1', '²': '2', '³': '3', '⁴': '4',
                '⁵': '5', '⁶': '6', '⁷': '7', '⁸': '8', '⁹': '9',
                '₀': '0', '₁': '1', '₂': '2', '₃': '3', '₄': '4',
                '₅': '5', '₆': '6', '₇': '7', '₈': '8', '₉': '9'
            };
            return map[match] || match;
        });
    };

    // Функция получения растворимости
    const getSolubility = (cationFormula, anionFormula) => {
        const cationKey = normalizeFormula(cationFormula);
        const anionKey = normalizeFormula(anionFormula);
        const exceptionKey = `${cationKey}-${anionKey}`;

        if (exceptions[exceptionKey] !== undefined) {
            return exceptions[exceptionKey];
        }
        return defaults[anionKey] || "R";
    };

    // Функция получения цвета соединения
    const getCompoundColor = (cationFormula, anionFormula) => {
        const cationKey = normalizeFormula(cationFormula);
        const anionKey = normalizeFormula(anionFormula);
        const key = `${cationKey}-${anionKey}`;

        if (window.substanceColors && window.substanceColors[key]) {
            const color = window.substanceColors[key];
            if (color === 'colorless') return 'Бесцветный раствор';
            if (color === 'white') return 'Белый';
            return color; // Возвращаем hex цвет
        }
        return '—';
    };

    // Функция получения реакции разложения
    const getDecompositionReaction = (cationFormula, anionFormula) => {
        const cationKey = normalizeFormula(cationFormula);
        const anionKey = normalizeFormula(anionFormula);
        const key = `${cationKey}-${anionKey}`;

        if (window.decompositionReactions && window.decompositionReactions[key]) {
            const reaction = window.decompositionReactions[key];
            return {
                equation: reaction.equation || '—',
                description: reaction.description || '—'
            };
        }
        return null;
    };

    // Проверяем, образует ли элемент катион
    cations.forEach(cation => {
        if (cation.f.includes(symbol) || cation.n.includes(symbol)) {
            anions.forEach(anion => {
                const solubility = getSolubility(cation.f, anion.f);
                const color = getCompoundColor(cation.f, anion.f);
                const decomposition = getDecompositionReaction(cation.f, anion.f);

                compounds.push({
                    type: 'cation',
                    cation: cation.f,
                    cationName: cation.n,
                    anion: anion.f,
                    anionName: anion.n,
                    solubility: solubility,
                    color: color,
                    decomposition: decomposition
                });
            });
        }
    });

    // Проверяем, образует ли элемент анион
    anions.forEach(anion => {
        if (anion.f.includes(symbol) || anion.n.includes(symbol)) {
            cations.forEach(cation => {
                const solubility = getSolubility(cation.f, anion.f);
                const color = getCompoundColor(cation.f, anion.f);
                const decomposition = getDecompositionReaction(cation.f, anion.f);

                compounds.push({
                    type: 'anion',
                    cation: cation.f,
                    cationName: cation.n,
                    anion: anion.f,
                    anionName: anion.n,
                    solubility: solubility,
                    color: color,
                    decomposition: decomposition
                });
            });
        }
    });

    return compounds;
}

/**
 * Расшифровка обозначений растворимости
 */
function getSolubilityText(code) {
    const map = {
        'R': 'Растворим',
        'M': 'Малорастворим',
        'N': 'Нерастворим',
        'D': 'Разлагается',
        'O': 'Не существует'
    };
    return map[code] || code;
}

/**
 * Генерирует PDF файл с информацией об элементе
 * @param {Object} elementData - Данные элемента
 */
async function generateElementPDF(elementData) {
    try {
        // Проверяем наличие jsPDF
        if (typeof window.jspdf === 'undefined') {
            alert('Библиотека jsPDF не загружена. Пожалуйста, обновите страницу.');
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        // Настройка шрифта для поддержки кириллицы
        doc.setFont('helvetica');

        let yPosition = 20;
        const pageWidth = doc.internal.pageSize.getWidth();
        const margin = 15;

        // Заголовок
        doc.setFontSize(20);
        doc.setTextColor(33, 150, 243);
        const title = `${elementData.name || elementData.symbol} (${elementData.symbol})`;
        doc.text(title, pageWidth / 2, yPosition, { align: 'center' });
        yPosition += 10;

        // Дата генерации
        doc.setFontSize(10);
        doc.setTextColor(128, 128, 128);
        const date = new Date().toLocaleDateString('ru-RU');
        doc.text(`Сгенерировано: ${date}`, pageWidth / 2, yPosition, { align: 'center' });
        yPosition += 15;

        // Базовая информация
        doc.setFontSize(14);
        doc.setTextColor(0, 0, 0);
        doc.text('Базовая информация', margin, yPosition);
        yPosition += 7;

        doc.autoTable({
            startY: yPosition,
            head: [['Свойство', 'Значение']],
            body: [
                ['Атомный номер', elementData.atomicNumber || '—'],
                ['Атомная масса', elementData.atomicMass || '—'],
                ['Период', elementData.period || '—'],
                ['Группа', elementData.group || '—'],
                ['Блок', elementData.block || '—'],
                ['Категория', elementData.category || '—'],
                ['Электронная конфигурация', elementData.electronConfig || '—'],
                ['Электроотрицательность', elementData.electronegativity || '—']
            ],
            margin: { left: margin, right: margin },
            styles: { font: 'helvetica', fontSize: 10 },
            headStyles: { fillColor: [33, 150, 243] }
        });

        yPosition = doc.lastAutoTable.finalY + 10;

        // Физические свойства
        doc.setFontSize(14);
        doc.text('Физические свойства', margin, yPosition);
        yPosition += 7;

        doc.autoTable({
            startY: yPosition,
            head: [['Свойство', 'Значение']],
            body: [
                ['Плотность', elementData.density || '—'],
                ['Температура плавления', elementData.meltingPoint || '—'],
                ['Температура кипения', elementData.boilingPoint || '—'],
                ['Состояние (20°C)', elementData.state || '—'],
                ['Цвет', elementData.color || '—']
            ],
            margin: { left: margin, right: margin },
            styles: { font: 'helvetica', fontSize: 10 },
            headStyles: { fillColor: [76, 175, 80] }
        });

        yPosition = doc.lastAutoTable.finalY + 10;

        // История
        doc.setFontSize(14);
        doc.text('История и применение', margin, yPosition);
        yPosition += 7;

        doc.autoTable({
            startY: yPosition,
            head: [['Свойство', 'Значение']],
            body: [
                ['Год открытия', elementData.discoveryYear || '—'],
                ['Первооткрыватель', elementData.discoverer || '—'],
                ['Происхождение названия', elementData.nameOrigin || '—'],
                ['Применение', Array.isArray(elementData.applications)
                    ? elementData.applications.join(', ')
                    : (elementData.applications || '—')]
            ],
            margin: { left: margin, right: margin },
            styles: { font: 'helvetica', fontSize: 10 },
            headStyles: { fillColor: [255, 152, 0] }
        });

        yPosition = doc.lastAutoTable.finalY + 10;

        // Интересные факты
        if (elementData.facts) {
            doc.setFontSize(14);
            doc.text('Интересные факты', margin, yPosition);
            yPosition += 7;

            const factsText = Array.isArray(elementData.facts)
                ? elementData.facts.join(' ')
                : elementData.facts;

            const splitFacts = doc.splitTextToSize(factsText, pageWidth - 2 * margin);
            doc.setFontSize(10);
            doc.text(splitFacts, margin, yPosition);
            yPosition += splitFacts.length * 5 + 10;
        }

        // Соединения из таблицы растворимости
        const compounds = getElementCompounds(elementData.symbol);

        if (compounds.length > 0) {
            // Новая страница для соединений
            doc.addPage();
            yPosition = 20;

            doc.setFontSize(16);
            doc.setTextColor(33, 150, 243);
            doc.text(`Соединения ${elementData.symbol} из таблицы растворимости`, margin, yPosition);
            yPosition += 10;

            // Подготовка данных для таблицы
            const compoundRows = compounds.map(comp => {
                // Формула соединения (упрощенная)
                let formula = '—';
                if (comp.type === 'cation') {
                    formula = `${comp.cation} + ${comp.anion}`;
                } else {
                    formula = `${comp.cation} + ${comp.anion}`;
                }

                // Цвет
                let colorText = comp.color;
                if (colorText && colorText.startsWith('#')) {
                    colorText = 'Цветной';
                }

                // Реакция разложения
                let reaction = '—';
                if (comp.decomposition) {
                    reaction = comp.decomposition.equation;
                }

                return [
                    formula,
                    getSolubilityText(comp.solubility),
                    colorText,
                    reaction
                ];
            });

            doc.autoTable({
                startY: yPosition,
                head: [['Компоненты', 'Растворимость', 'Цвет', 'Реакция']],
                body: compoundRows,
                margin: { left: margin, right: margin },
                styles: {
                    font: 'helvetica',
                    fontSize: 8,
                    cellPadding: 2
                },
                headStyles: {
                    fillColor: [156, 39, 176],
                    fontSize: 9
                },
                columnStyles: {
                    0: { cellWidth: 40 },
                    1: { cellWidth: 35 },
                    2: { cellWidth: 35 },
                    3: { cellWidth: 'auto' }
                }
            });
        }

        // Сохранение PDF
        const fileName = `${elementData.symbol}_${elementData.name || 'element'}.pdf`;
        doc.save(fileName);

    } catch (error) {
        console.error('Ошибка при генерации PDF:', error);
        alert('Произошла ошибка при создании PDF. Проверьте консоль для деталей.');
    }
}

// Делаем функцию глобально доступной
window.generateElementPDF = generateElementPDF;


============================================================
ФАЙЛ: .\js\modules\radioactive.js
============================================================

// Radioactive Easter Egg Module - Pro Shard-Based Disintegration

document.addEventListener('DOMContentLoaded', () => {
    const uraniumAtomicNumber = 92; // U

    const timeoutMap = new Map();
    const activationTime = 2000; // 2 seconds
    let decayInterval;

    const elements = document.querySelectorAll('.element');

    elements.forEach(element => {
        const atomicNumberSpan = element.querySelector('.atomic-number');
        if (!atomicNumberSpan) return;
        const atomicNumber = parseInt(atomicNumberSpan.textContent);

        if (atomicNumber === uraniumAtomicNumber) {
            element.addEventListener('mouseenter', () => startRadioactiveTimer(element));
            element.addEventListener('mouseleave', () => stopRadioactiveTimer(element));
            element.addEventListener('touchstart', () => startRadioactiveTimer(element), { passive: true });
            element.addEventListener('touchend', () => stopRadioactiveTimer(element));
            element.addEventListener('touchcancel', () => stopRadioactiveTimer(element));
        }
    });

    function startRadioactiveTimer(element) {
        if (timeoutMap.has(element)) clearTimeout(timeoutMap.get(element));
        const timeoutId = setTimeout(() => triggerRadioactiveEffect(), activationTime);
        timeoutMap.set(element, timeoutId);
    }

    function stopRadioactiveTimer(element) {
        if (timeoutMap.has(element)) {
            clearTimeout(timeoutMap.get(element));
            timeoutMap.delete(element);
        }
        removeRadioactiveEffect();
    }

    function triggerRadioactiveEffect() {
        if (document.body.classList.contains('radioactive-mode')) return;
        document.body.classList.add('radioactive-mode');
        if (!decayInterval) startDecaySpread();
        if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
    }

    function removeRadioactiveEffect() {
        document.body.classList.remove('radioactive-mode');
        stopDecaySpread();
    }

    function startDecaySpread() {
        if (decayInterval) clearInterval(decayInterval);
        const allElements = Array.from(document.querySelectorAll('.element'));

        decayInterval = setInterval(() => {
            const healthyElements = allElements.filter(el =>
                !el.classList.contains('radioactive-decay') &&
                el.style.visibility !== 'hidden'
            );

            if (healthyElements.length === 0) {
                clearInterval(decayInterval);
                return;
            }

            const victim = healthyElements[Math.floor(Math.random() * healthyElements.length)];
            victim.classList.add('radioactive-decay');
            crumbleToShards(victim);
        }, 120);
    }

    function stopDecaySpread() {
        if (decayInterval) {
            clearInterval(decayInterval);
            decayInterval = null;
        }

        // Heal all elements smoothly
        document.querySelectorAll('.element.radioactive-decay').forEach(el => {
            el.classList.remove('radioactive-decay');

            // Restore visual state
            el.style.color = '';
            el.style.backgroundColor = '';
            el.style.borderColor = '';
            el.style.boxShadow = '';

            // Restore children
            el.querySelectorAll('*').forEach(child => {
                child.style.opacity = '';
            });

            el.style.transition = 'all 1.5s ease-out';

            setTimeout(() => {
                el.style.transition = '';
            }, 1500);
        });
    }

    // ==========================================
    // PRO DISINTEGRATION: Fragment Cloning
    // ==========================================

    function crumbleToShards(element) {
        const rect = element.getBoundingClientRect();

        // Capture appearance BEFORE hiding
        const computed = window.getComputedStyle(element);
        const appearance = {
            backgroundColor: computed.backgroundColor,
            borderColor: computed.borderColor,
            color: computed.color,
            fontSize: computed.fontSize,
            fontFamily: computed.fontFamily,
            padding: computed.padding,
            borderRadius: computed.borderRadius
        };

        // Hide the original element content but KEEP it alive for hover
        element.style.backgroundColor = 'transparent';
        element.style.borderColor = 'transparent';
        element.style.boxShadow = 'none';
        element.style.color = 'transparent';
        element.querySelectorAll('*').forEach(child => child.style.opacity = '0');

        // Create shards (3x3 grid)
        const rows = 3;
        const cols = 3;
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                createShard(element, rect, r, c, rows, cols, appearance);
            }
        }
    }

    function createShard(original, rect, r, c, rows, cols, appearance) {
        const shard = document.createElement('div');
        shard.className = original.className;
        shard.classList.remove('radioactive-decay');
        shard.classList.add('radioactive-shard');
        shard.innerHTML = original.innerHTML;

        // Use the CAPTURED appearance
        shard.style.backgroundColor = appearance.backgroundColor;
        shard.style.borderColor = appearance.borderColor;
        shard.style.color = appearance.color;
        shard.style.fontSize = appearance.fontSize;
        shard.style.fontFamily = appearance.fontFamily;
        shard.style.padding = appearance.padding;
        shard.style.borderRadius = appearance.borderRadius;

        shard.style.display = 'flex';
        shard.style.flexDirection = 'column';
        shard.style.alignItems = 'center';
        shard.style.justifyContent = 'center';

        // Position exactly on top of the original
        shard.style.width = rect.width + 'px';
        shard.style.height = rect.height + 'px';
        shard.style.left = rect.left + 'px';
        shard.style.top = rect.top + 'px';

        // SLICE: clip-path to only show one part of the element
        // We add some randomness to the slice to make it "jagged"
        const xStart = (c / cols) * 100;
        const xEnd = ((c + 1) / cols) * 100;
        const yStart = (r / rows) * 100;
        const yEnd = ((r + 1) / rows) * 100;

        // Create jagged corners
        const p1 = `${xStart + rand(-5, 5)}% ${yStart + rand(-5, 5)}%`;
        const p2 = `${xEnd + rand(-5, 5)}% ${yStart + rand(-5, 5)}%`;
        const p3 = `${xEnd + rand(-5, 5)}% ${yEnd + rand(-5, 5)}%`;
        const p4 = `${xStart + rand(-5, 5)}% ${yEnd + rand(-5, 5)}%`;

        shard.style.clipPath = `polygon(${p1}, ${p2}, ${p3}, ${p4})`;
        shard.style.webkitClipPath = shard.style.clipPath;

        document.body.appendChild(shard);

        // Physics variables
        const duration = 800 + Math.random() * 1200;
        const delay = Math.random() * 400; // Pieces don't all fall at once
        const tx = (Math.random() - 0.5) * 150; // horizontal drift
        const ty = window.innerHeight * 0.5 + Math.random() * 200; // fall distance
        const rot = (Math.random() - 0.5) * 500; // spin

        // Animating using Web Animations API (high performance)
        const anim = shard.animate([
            { transform: 'translate(0, 0) rotate(0deg)', opacity: 1 },
            { transform: `translate(${tx}px, ${ty}px) rotate(${rot}deg)`, opacity: 0 }
        ], {
            duration: duration,
            delay: delay,
            easing: 'cubic-bezier(0.5, 0, 1, 1)', // Gravity-like acceleration
            fill: 'forwards'
        });

        anim.onfinish = () => {
            shard.remove();
        };
    }

    function rand(min, max) {
        return Math.random() * (max - min) + min;
    }
});


============================================================
ФАЙЛ: .\js\modules\reactions.js
============================================================

﻿// =========================================
// MODULE: REACTIONS MODE (DATABASE LOOKUP)
// =========================================
(function () {
    const DB_URL = 'data/reactions-db.json';
    const MAX_SUGGESTIONS = 5;
    const REACTION_CATEGORIES = {
        'R00': ['special'],
        'R01': ['displacement', 'redox', 'metal_acid'],
        'R02': ['redox', 'oxidizing_acid'],
        'R03': ['redox', 'oxidizing_acid'],
        'R04': ['redox', 'oxidizing_acid'],
        'R05': ['exchange'],
        'R06': ['exchange', 'precipitation'],
        'R07': ['exchange', 'precipitation'],
        'R08': ['displacement', 'redox'],
        'R09': ['combination'],
        'R10': ['exchange'],
        'R11': ['combination', 'alkali_formation'],
        'R12': ['exchange'],
        'R13': ['combination', 'acid_formation'],
        'R14': ['neutralization', 'exchange'],
        'R15': ['amphoterism', 'exchange'],
        'R16': ['amphoterism', 'complexation'],
        'R17': ['amphoterism', 'fusion'],
        'R18': ['redox', 'displacement'],
        'R19': ['combination', 'oxidation'],
        'R20': ['decomposition', 'thermal', 'redox'],
        'R21': ['decomposition', 'thermal'],
        'R22': ['decomposition', 'thermal'],
        'R23': ['hydrolysis', 'exchange'],
        'R24': ['displacement', 'redox', 'halogen'],
        'R25': ['combination', 'oxidation'],
        'R26': ['neutralization'],
        'R27': ['combination'],
        'R30': ['electrolysis', 'redox'],
        'R31': ['electrolysis', 'redox'],
        'R32': ['dehydration'],
        'R33': ['complexation', 'redox'],
        'R34': ['precipitation'],
        'R35': ['decomposition'],
        'R36': ['redox'],
        'R37': ['redox'],
        'R38': ['redox'],
        'R39': ['complexation'],
        'R40': ['redox'],
        'R41': ['disproportionation', 'redox'],
        'R42': ['redox'],
        'R43': ['redox', 'exothermic'],
        'R44': ['redox'],
        'R45': ['complexation'],
        'R47': ['redox'],
        'R48': ['redox'],
        'R49': ['displacement', 'redox'],
        'R50': ['combination'],
        'R51': ['redox', 'qualitative'],
        'R52': ['disproportionation'],
        'R53': ['hydrolysis'],
        'R55': ['disproportionation'],
        'R56': ['disproportionation'],
        'R57': ['decomposition', 'redox'],
        'R58': ['redox'],
        'R59': ['redox'],
        'R61': ['exchange'],
        'R62': ['qualitative', 'precipitation'],
        'R63': ['oxidation'],
        'R64': ['combination'],
        'R65': ['combination'],
        'R66': ['redox'],
        'R67': ['decomposition'],
        'R68': ['specific'],
        'R71': ['complexation'],
        'R72': ['qualitative', 'complexation'],
        'R73': ['redox'],
        'R74': ['redox'],
        'R75': ['specific'],
        'R76': ['specific'],
        'R77': ['specific', 'redox'],
        'R78': ['qualitative'],
        'R80': ['decomposition', 'redox'],
        'R81': ['specific', 'redox'],
        'R82': ['complexation'],
        'R83': ['no_reaction'],
        'R84': ['redox', 'oxidizing_acid'],
        'R99': ['combustion', 'redox']
    };

    const TAG_LABELS = {
        'special': 'Спец. правило',
        'displacement': 'Замещение',
        'redox': 'ОВР',
        'metal_acid': 'Металл + К-та',
        'oxidizing_acid': 'К-та окислитель',
        'exchange': 'Обмен',
        'precipitation': 'Осаждение',
        'combination': 'Соединение',
        'alkali_formation': 'Образование щёлочи',
        'acid_formation': 'Образование кислоты',
        'neutralization': 'Нейтрализация',
        'amphoterism': 'Амфотерность',
        'complexation': 'Комплексообразование',
        'fusion': 'Сплавление',
        'oxidation': 'Окисление',
        'decomposition': 'Разложение',
        'thermal': 'Нагревание',
        'hydrolysis': 'Гидролиз',
        'halogen': 'Галогены',
        'electrolysis': 'Электролиз',
        'dehydration': 'Дегидратация',
        'disproportionation': 'Диспропорционирование',
        'exothermic': 'Экзотерм.',
        'qualitative': 'Качественная',
        'combustion': 'Горение',
        'specific': 'Специфическая',
        'suggestion': 'Похожие',
        'no_reaction': 'Нет реакции'
    };

    const subDigitsMap = {
        '\u2080': '0', '\u2081': '1', '\u2082': '2', '\u2083': '3', '\u2084': '4',
        '\u2085': '5', '\u2086': '6', '\u2087': '7', '\u2088': '8', '\u2089': '9'
    };

    let dbLoaded = false;
    let dbError = null;
    let reactionsIndex = null;
    let ionMaps = null;
    let dataMaps = null;
    let ruleMap = null;
    const fallbackIonCharges = {
        'H': 1, 'Li': 1, 'Na': 1, 'K': 1, 'Rb': 1, 'Cs': 1, 'NH4': 1, 'Ag': 1,
        'Mg': 2, 'Ca': 2, 'Sr': 2, 'Ba': 2, 'Zn': 2, 'Cu': 2, 'Pb': 2, 'Fe': 2, 'Sn': 2, 'Be': 2,
        'Al': 3, 'Cr': 3,
        'F': -1, 'Cl': -1, 'Br': -1, 'I': -1, 'OH': -1, 'NO3': -1, 'NO2': -1, 'HCO3': -1, 'HSO4': -1, 'HSO3': -1, 'H2PO4': -1, 'ClO4': -1,
        'SO4': -2, 'SO3': -2, 'CO3': -2, 'S': -2, 'SiO3': -2, 'CrO4': -2,
        'PO4': -3
    };

    function buildIonMaps(data) {
        if (!data || !Array.isArray(data.ions)) return null;
        const cations = new Map();
        const anions = new Map();

        const stripCharge = (ionStr, charge) => {
            if (!ionStr) return null;
            let compact = ionStr.replace(/\s+/g, '');
            const magnitude = Math.abs(Number(charge)) || 0;
            if (magnitude === 0) return compact;
            if (magnitude === 1) {
                return compact.replace(/[+-]$/, '');
            }
            const tail = String(magnitude);
            if (compact.endsWith(`${tail}+`) || compact.endsWith(`${tail}-`)) {
                return compact.slice(0, -(tail.length + 1));
            }
            if (compact.endsWith(`+${tail}`) || compact.endsWith(`-${tail}`)) {
                return compact.slice(0, -(tail.length + 1));
            }
            return compact;
        };

        const parseIon = (ionStr, charge) => {
            if (!ionStr) return null;
            const numericCharge = Number(charge);
            if (Number.isFinite(numericCharge) && numericCharge !== 0) {
                const formula = stripCharge(ionStr, numericCharge);
                if (!formula) return null;
                return { formula, charge: numericCharge };
            }
            const compact = ionStr.replace(/\s+/g, '');
            const match = compact.match(/^(.+?)(\d*)([+-])$/);
            if (!match) return null;
            const formula = match[1];
            const magnitude = match[2] ? parseInt(match[2], 10) : 1;
            const sign = match[3] === '-' ? -1 : 1;
            return { formula, charge: sign * magnitude };
        };

        data.ions.forEach((ion) => {
            const parsed = parseIon(ion.ion, ion.charge);
            if (!parsed) return;
            if (ion.type === 'cation') {
                if (!cations.has(parsed.formula)) cations.set(parsed.formula, []);
                cations.get(parsed.formula).push(parsed.charge);
            } else if (ion.type === 'anion') {
                if (!anions.has(parsed.formula)) anions.set(parsed.formula, []);
                anions.get(parsed.formula).push(parsed.charge);
            }
        });

        return { cations, anions };
    }

    function normalizeDigits(str) {
        return str.replace(/[\u2080-\u2089]/g, (m) => subDigitsMap[m] || m);
    }

    function stripLeadingCoeff(token) {
        return token.replace(/^\s*\d+([.,]\d+)?\s*/, '');
    }

    function stripTrailingCondition(token) {
        // Remove trailing condition like (разб), (конц), (t°), (aq), (s), etc.
        let out = token;
        while (/\([^)]+\)$/.test(out)) {
            out = out.replace(/\([^)]+\)$/, '');
        }
        return out;
    }

    function normalizeToken(token, opts) {
        if (!token) return '';
        let out = normalizeDigits(token);
        out = out.replace(/\s+/g, '');
        out = stripLeadingCoeff(out);
        if (opts && opts.stripConditions) {
            out = stripTrailingCondition(out);
        }
        return out;
    }

    function splitReactants(input) {
        if (!input) return [];
        let text = normalizeDigits(input);
        const parts = text.split(/=|->|\u2192|\u21cc/);
        const left = parts[0] || '';
        return left
            .split(/[+;]/)
            .map((t) => t.trim())
            .filter(Boolean);
    }

    function buildKey(tokens, opts) {
        const normalized = tokens
            .map((t) => normalizeToken(t, opts))
            .filter(Boolean)
            .sort();
        return normalized.join('|');
    }

    function buildIndex(examples) {
        const strict = new Map();
        const relaxed = new Map();
        const entries = [];

        examples.forEach((example) => {
            const reactants = splitReactants(example.reactants || '');
            const strictKey = buildKey(reactants, { stripConditions: false });
            const relaxedKey = buildKey(reactants, { stripConditions: true });
            const strictTokens = reactants
                .map((t) => normalizeToken(t, { stripConditions: false }))
                .filter(Boolean);
            const relaxedTokens = reactants
                .map((t) => normalizeToken(t, { stripConditions: true }))
                .filter(Boolean);

            const entry = {
                example,
                strictKey,
                relaxedKey,
                strictTokens,
                relaxedTokens
            };

            if (strictKey) {
                if (!strict.has(strictKey)) strict.set(strictKey, []);
                strict.get(strictKey).push(example);
            }
            if (relaxedKey) {
                if (!relaxed.has(relaxedKey)) relaxed.set(relaxedKey, []);
                relaxed.get(relaxedKey).push(example);
            }

            entries.push(entry);
        });

        return { strict, relaxed, entries };
    }

    function getIonCharge(formula, type, prefer) {
        if (ionMaps) {
            const map = type === 'anion' ? ionMaps.anions : ionMaps.cations;
            const list = map.get(formula);
            if (list && list.length > 0) {
                if (prefer === 'max') return Math.max(...list);
                return Math.min(...list);
            }
        }
        const fallback = fallbackIonCharges[formula];
        if (!fallback) return null;
        if (type === 'anion' && fallback < 0) return fallback;
        if (type === 'cation' && fallback > 0) return fallback;
        return null;
    }

    function parseRomanNumeral(raw) {
        const map = { I: 1, V: 5, X: 10 };
        const text = String(raw || '').trim().toUpperCase();
        if (!/^[IVX]+$/.test(text)) return null;
        let total = 0;
        for (let i = 0; i < text.length; i++) {
            const cur = map[text[i]] || 0;
            const next = map[text[i + 1]] || 0;
            total += cur < next ? -cur : cur;
        }
        return total > 0 ? total : null;
    }

    function parseOxidationStateFromLabel(label) {
        const match = String(label || '').match(/\(([^)]+)\)\s*$/);
        if (!match) return null;
        const token = match[1].trim();
        if (/^\d+$/.test(token)) {
            const n = parseInt(token, 10);
            return n > 0 ? n : null;
        }
        return parseRomanNumeral(token);
    }

    function mergeSubclassTags(prev, next) {
        const list = [];
        String(prev || '')
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
            .forEach((s) => list.push(s));
        String(next || '')
            .split(',')
            .map((s) => s.trim())
            .filter(Boolean)
            .forEach((s) => {
                if (!list.includes(s)) list.push(s);
            });
        return list.join(', ');
    }

    function inferCationChargeFromOxide(oxideFormula, metalSymbol) {
        const counts = parseFormulaCounts(oxideFormula);
        const mCount = counts[metalSymbol] || 0;
        const oCount = counts.O || 0;
        if (!mCount || !oCount) return null;
        const charge = (2 * oCount) / mCount;
        return Number.isInteger(charge) && charge > 0 ? charge : null;
    }

    function buildDataMaps(data) {
        if (!data) return null;
        const classMap = new Map();
        const oxideSubclassMap = new Map();
        const acidOxideMap = new Map();
        const oxideToAcidMap = new Map();
        const metalOxideMap = new Map();
        const metalToOxideMap = new Map();
        const metalToHydroxideMap = new Map();
        const metalToOxideByChargeMap = new Map();
        const elementMap = new Map();
        const activityMap = new Map();
        const solubilityMap = new Map();
        const solubilityCations = [];
        const solubilityAnions = [];

        (data.substances || []).forEach((item) => {
            if (!item.formula) return;
            classMap.set(item.formula, { class: item.type, info: item });
        });

        (data.substance_classes || []).forEach((item) => {
            if (!item.formula) return;
            const prev = classMap.get(item.formula);
            const subclass = prev && prev.class === item.class
                ? mergeSubclassTags(prev.subclass, item.subclass)
                : item.subclass;
            classMap.set(item.formula, { class: item.class, subclass, info: item });
            if (item.class === 'oxide' && subclass) {
                oxideSubclassMap.set(item.formula, subclass);
            }
        });

        (data.acid_oxide_pairs || []).forEach((pair) => {
            if (pair.oxide && pair.acid) {
                const acids = splitAlternatives(pair.acid);
                if (!acids.length) return;
                acids.forEach((acid) => acidOxideMap.set(acid, pair.oxide));
                oxideToAcidMap.set(pair.oxide, acids[0]);
            }
        });

        (data.metal_oxide_pairs || []).forEach((pair) => {
            if (!pair.oxide) return;
            const metalInfo = { metal: pair.metal, hydroxide: pair.hydroxide, oxide: pair.oxide };
            metalOxideMap.set(pair.oxide, metalInfo);
            if (pair.metal) {
                const metalSymbol = pair.metal.replace(/\(.*\)$/, '');
                if (!metalToOxideMap.has(metalSymbol)) {
                    metalToOxideMap.set(metalSymbol, pair.oxide);
                }
                if (pair.hydroxide && !metalToHydroxideMap.has(metalSymbol)) {
                    metalToHydroxideMap.set(metalSymbol, pair.hydroxide);
                }

                const explicitCharge = parseOxidationStateFromLabel(pair.metal);
                const inferredCharge = explicitCharge || inferCationChargeFromOxide(pair.oxide, metalSymbol) || getIonCharge(metalSymbol, 'cation', 'min');
                if (inferredCharge) {
                    metalToOxideByChargeMap.set(`${metalSymbol}|${inferredCharge}`, pair.oxide);
                }
            }
        });

        (data.elements || []).forEach((el) => {
            if (!el.symbol) return;
            elementMap.set(el.symbol, el);
        });

        (data.activity_series || []).forEach((entry) => {
            if (entry.element) activityMap.set(entry.element, entry.rank);
        });

        if (data.solubility_table) {
            solubilityCations.push(...(data.solubility_table.cations || []));
            solubilityAnions.push(...Object.keys(data.solubility_table.anions || {}));
            const cationIndex = new Map();
            solubilityCations.forEach((c, i) => cationIndex.set(c.replace(/\s+/g, ''), i));
            Object.entries(data.solubility_table.anions || {}).forEach(([anion, row]) => {
                const anionKey = anion.replace(/\s+/g, '');
                row.forEach((cell, idx) => {
                    const cation = solubilityCations[idx]?.replace(/\s+/g, '');
                    if (!cation) return;
                    solubilityMap.set(`${cation}|${anionKey}`, cell);
                });
            });
        }

        return {
            classMap,
            oxideSubclassMap,
            acidOxideMap,
            oxideToAcidMap,
            metalOxideMap,
            metalToOxideMap,
            metalToHydroxideMap,
            metalToOxideByChargeMap,
            elementMap,
            activityMap,
            solubilityMap,
            solubilityCations,
            solubilityAnions
        };
    }

    function gcd(a, b) {
        let x = Math.abs(a);
        let y = Math.abs(b);
        while (y) {
            const t = y;
            y = x % y;
            x = t;
        }
        return x || 1;
    }

    function lcm(a, b) {
        return Math.abs(a * b) / gcd(a, b);
    }

    function parseAcid(formula) {
        if (!formula || formula === 'H2O') return null;
        const normalized = splitAlternatives(String(formula))[0] || String(formula);
        if (!/^H/.test(normalized)) return null;
        const match = normalized.match(/^H(\d*)(.+)$/);
        if (!match) return null;
        const hCount = match[1] ? parseInt(match[1], 10) : 1;
        const anionFormula = match[2];
        if (/^\d+$/.test(anionFormula)) return null;
        return { hCount, anionFormula };
    }

    function parseBase(formula) {
        if (!formula) return null;
        const matchBracket = formula.match(/^(.+?)\((OH)\)(\d*)$/);
        if (matchBracket) {
            return {
                cationFormula: matchBracket[1],
                ohCount: matchBracket[3] ? parseInt(matchBracket[3], 10) : 1
            };
        }
        const matchPlain = formula.match(/^(.+?)OH$/);
        if (matchPlain) {
            return { cationFormula: matchPlain[1], ohCount: 1 };
        }
        return null;
    }

    function isPolyatomic(formula) {
        return !/^[A-Z][a-z]?\d*$/.test(formula);
    }

    function buildSaltFormula(cationFormula, cationCharge, anionFormula, anionCharge) {
        const a = Math.abs(cationCharge);
        const b = Math.abs(anionCharge);
        const g = gcd(a, b);
        const cationSub = b / g;
        const anionSub = a / g;

        const cationPart = cationSub > 1 ? `${cationFormula}${cationSub}` : cationFormula;
        const anionCore = isPolyatomic(anionFormula) && anionSub > 1
            ? `(${anionFormula})${anionSub}`
            : (anionSub > 1 ? `${anionFormula}${anionSub}` : anionFormula);

        return `${cationPart}${anionCore}`;
    }

    function normalizeIonKey(ion) {
        return ion.replace(/\s+/g, '');
    }

    function escapeRegExp(text) {
        return String(text || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function getSolubility(cationFormula, cationCharge, anionFormula, anionCharge) {
        if (!dataMaps || !dataMaps.solubilityMap) return null;
        const cationKey = normalizeIonKey(`${cationFormula}${Math.abs(cationCharge)}+`.replace('1+', '+'));
        const altCationKey = normalizeIonKey(`${cationFormula}+`);
        const anionKey = normalizeIonKey(`${anionFormula}${Math.abs(anionCharge)}-`.replace('1-', '-'));
        const altAnionKey = normalizeIonKey(`${anionFormula}-`);
        return dataMaps.solubilityMap.get(`${cationKey}|${anionKey}`)
            || dataMaps.solubilityMap.get(`${cationKey}|${altAnionKey}`)
            || dataMaps.solubilityMap.get(`${altCationKey}|${anionKey}`)
            || dataMaps.solubilityMap.get(`${altCationKey}|${altAnionKey}`)
            || null;
    }

    function isInsoluble(sol) {
        return sol === 'IS' || sol === 'SS' || sol === 'D';
    }

    function resolveCationCandidates(cationPart) {
        const compact = String(cationPart || '').trim();
        if (!compact) return [];
        const candidates = [];
        const noTailIndex = compact.replace(/\d+$/, '');
        if (noTailIndex && noTailIndex !== compact) candidates.push(noTailIndex);
        candidates.push(compact);
        return [...new Set(candidates)];
    }

    function detectSalt(formula) {
        const normalized = normalizeToken(formula, { stripConditions: true });
        const anionKeys = Array.from(new Set([
            ...(ionMaps ? Array.from(ionMaps.anions.keys()) : []),
            'H2PO4', 'HSO4', 'HSO3', 'HCO3', 'PO4', 'SO4', 'SO3', 'CO3', 'NO3', 'NO2', 'ClO4', 'SiO3', 'Cl', 'Br', 'I', 'F', 'S'
        ])).sort((a, b) => b.length - a.length);
        for (const anion of anionKeys) {
            const safeAnion = escapeRegExp(anion);
            const anionPattern = new RegExp(`^(.*)(${safeAnion})(\\d*)$`);
            const match = normalized.match(anionPattern);
            if (match) {
                const catPart = match[1];
                const anionSub = match[3] ? parseInt(match[3], 10) : 1;
                if (!catPart) continue;
                const anionCharge = getIonCharge(anion, 'anion', 'min');
                if (!anionCharge) continue;
                const cationCandidates = resolveCationCandidates(catPart);
                for (const cationFormula of cationCandidates) {
                    let cationCharge = getIonCharge(cationFormula, 'cation', 'min');
                    const safeCation = escapeRegExp(cationFormula);
                    const catSubMatch = String(catPart).match(new RegExp(`^${safeCation}(\\d*)$`));
                    const cationSub = catSubMatch && catSubMatch[1] ? parseInt(catSubMatch[1], 10) : 1;
                    const inferredCharge = (Math.abs(anionCharge) * anionSub) / cationSub;
                    if ((!cationCharge || ['Fe', 'Cr', 'Cu', 'Sn', 'Pb', 'Mn', 'Co', 'Ni'].includes(cationFormula)) && Number.isInteger(inferredCharge) && inferredCharge > 0) {
                        cationCharge = inferredCharge;
                    }
                    if (!cationCharge) continue;
                    return { cationFormula, anionFormula: anion, cationCharge, anionCharge };
                }
            }
            const complexMatch = normalized.match(new RegExp(`^(.*)\\(${safeAnion}\\)(\\d*)$`));
            if (complexMatch) {
                const catPart = complexMatch[1];
                const anionSub = complexMatch[2] ? parseInt(complexMatch[2], 10) : 1;
                if (!catPart) continue;
                const anionCharge = getIonCharge(anion, 'anion', 'min');
                if (!anionCharge) continue;
                const cationCandidates = resolveCationCandidates(catPart);
                for (const cationFormula of cationCandidates) {
                    let cationCharge = getIonCharge(cationFormula, 'cation', 'min');
                    const safeCation = escapeRegExp(cationFormula);
                    const catSubMatch = String(catPart).match(new RegExp(`^${safeCation}(\\d*)$`));
                    const cationSub = catSubMatch && catSubMatch[1] ? parseInt(catSubMatch[1], 10) : 1;
                    const inferredCharge = (Math.abs(anionCharge) * anionSub) / cationSub;
                    if ((!cationCharge || ['Fe', 'Cr', 'Cu', 'Sn', 'Pb', 'Mn', 'Co', 'Ni'].includes(cationFormula)) && Number.isInteger(inferredCharge) && inferredCharge > 0) {
                        cationCharge = inferredCharge;
                    }
                    if (!cationCharge) continue;
                    return { cationFormula, anionFormula: anion, cationCharge, anionCharge };
                }
            }
        }
        return null;
    }

    function normalizeRawInput(raw) {
        if (!raw) return '';
        return normalizeDigits(raw).replace(/\s+/g, '').toLowerCase();
    }

    function hasKeyword(rawInput, keywords) {
        if (!rawInput) return false;
        const normalized = normalizeRawInput(rawInput);
        return keywords.some(k => normalized.includes(k.toLowerCase()));
    }

    function hasHeatingCondition(rawInput) {
        return hasKeyword(rawInput, ['t', 'нагр', 'heat', 'кипяч', 'boil', 'сплав']);
    }

    function hasAllReactants(tokens, reactants) {
        const normalizedTokens = tokens.map(t => normalizeToken(t, { stripConditions: true }));
        return reactants.every(r => normalizedTokens.includes(r));
    }

    function formatCoeff(n) {
        if (n === 1) return '';
        return String(n);
    }

    function isSaltLikeFormula(formula) {
        if (!formula) return false;
        if (parseAcid(formula) || parseBase(formula) || formula === 'H2O') return false;
        if (classifyFormula(formula).kind === 'metal') return false;
        return !!detectSalt(formula);
    }

    function isWeakAcid(acidFormula) {
        const acidClass = dataMaps?.classMap.get(acidFormula);
        return /weak/i.test(String(acidClass?.subclass || ''));
    }

    function isWeakBase(baseFormula) {
        const baseClass = dataMaps?.classMap.get(baseFormula);
        return /weak/i.test(String(baseClass?.subclass || ''));
    }

    function isGasProduct(acidFormula) {
        return ['H2CO3', 'H2SO3', 'H2S', 'NH4OH'].includes(acidFormula);
    }

    function buildAcidFormula(anionFormula, anionCharge) {
        const hCount = Math.abs(Number(anionCharge) || 1);
        return `H${hCount > 1 ? hCount : ''}${anionFormula}`;
    }

    function formatCoeff(n) {
        return n > 1 ? `${n} ` : '';
    }

    function parseFormulaCounts(formula) {
        const clean = formula.replace(/\s+/g, '');
        const elements = {};
        let i = 0;
        const len = clean.length;
        const stack = [{}];

        while (i < len) {
            const char = clean[i];
            if (char === '(' || char === '[') {
                stack.push({});
                i++;
            } else if (char === ')' || char === ']') {
                const top = stack.pop();
                i++;
                let numStr = '';
                while (i < len && /\d/.test(clean[i])) {
                    numStr += clean[i];
                    i++;
                }
                const mult = numStr ? parseInt(numStr, 10) : 1;
                const parent = stack[stack.length - 1];
                Object.keys(top).forEach((el) => {
                    parent[el] = (parent[el] || 0) + top[el] * mult;
                });
            } else if (/[A-Z]/.test(char)) {
                let name = char;
                i++;
                if (i < len && /[a-z]/.test(clean[i])) {
                    name += clean[i];
                    i++;
                }
                let numStr = '';
                while (i < len && /\d/.test(clean[i])) {
                    numStr += clean[i];
                    i++;
                }
                const count = numStr ? parseInt(numStr, 10) : 1;
                const current = stack[stack.length - 1];
                current[name] = (current[name] || 0) + count;
            } else {
                i++;
            }
        }
        while (stack.length > 1) {
            const top = stack.pop();
            const parent = stack[stack.length - 1];
            Object.keys(top).forEach((el) => {
                parent[el] = (parent[el] || 0) + top[el];
            });
        }
        return stack[0];
    }

    function classifyFormula(formula) {
        if (!formula || !dataMaps) return { kind: 'unknown' };
        if (formula === 'H2O') return { kind: 'water' };

        const classInfo = dataMaps.classMap.get(formula);
        if (classInfo) {
            if (classInfo.class === 'oxide') {
                return { kind: 'oxide', subclass: classInfo.subclass || dataMaps.oxideSubclassMap.get(formula) };
            }
            return { kind: classInfo.class, subclass: classInfo.subclass };
        }

        if (parseAcid(formula)) return { kind: 'acid' };
        if (parseBase(formula)) return { kind: 'base' };

        if (dataMaps.elementMap.has(formula)) {
            const el = dataMaps.elementMap.get(formula);
            if (el.is_metal) return { kind: 'metal' };
            if (el.is_nonmetal) return { kind: 'nonmetal' };
            return { kind: 'element' };
        }
        const diatomic = formula.match(/^([A-Z][a-z]?)2$/);
        if (diatomic && dataMaps.elementMap.has(diatomic[1])) {
            const el = dataMaps.elementMap.get(diatomic[1]);
            if (el.is_nonmetal) return { kind: 'nonmetal' };
        }

        if (/^(F|Cl|Br|I)2$/.test(formula)) return { kind: 'halogen' };

        return { kind: 'unknown' };
    }

    function findHalideSalt(formula) {
        if (!ionMaps) return null;
        const halides = ['F', 'Cl', 'Br', 'I'];
        for (const hal of halides) {
            const anion = `${hal}-`;
            if (!ionMaps.anions.has(hal)) {
                // anion formulas in map are like Cl, Br, I
            }
            const suffixMatch = formula.match(new RegExp(`^(.+?)${hal}(\\d*)$`));
            if (suffixMatch) {
                const cationFormula = suffixMatch[1];
                const cationCharge = getIonCharge(cationFormula, 'cation', 'min');
                if (!cationCharge) continue;
                return { cationFormula, cationCharge, anionFormula: hal, anionCharge: -1 };
            }
        }
        return null;
    }

    function extractCondition(token) {
        const raw = token.toLowerCase();
        if (raw.includes('конц')) return 'conc';
        if (raw.includes('разб')) return 'dilute';
        if (raw.includes('оч.разб') || raw.includes('оченьразб') || raw.includes('оч.')) return 'very-dilute';
        return null;
    }

    function hasKeyword(raw, words) {
        const text = String(raw || '').toLowerCase();
        return words.some((w) => text.includes(w));
    }

    function hasAllReactants(tokens, required) {
        const set = new Set((tokens || []).map((t) => normalizeToken(t, { stripConditions: true })));
        return required.every((r) => set.has(r));
    }

    function hasAnyReactant(tokens, candidates) {
        const set = new Set((tokens || []).map((t) => normalizeToken(t, { stripConditions: true })));
        return (candidates || []).some((c) => set.has(c));
    }

    function getPresentReactant(tokens, candidates) {
        const set = new Set((tokens || []).map((t) => normalizeToken(t, { stripConditions: true })));
        return (candidates || []).find((c) => set.has(c)) || null;
    }

    function detectRedoxMedium(tokens, rawInput) {
        const acidicByReagents = hasAnyReactant(tokens, ['H2SO4', 'HCl', 'HNO3']);
        const alkalineByReagents = hasAnyReactant(tokens, ['KOH', 'NaOH']);
        const neutralByReagents = hasAnyReactant(tokens, ['H2O']);
        const acidicByText = hasKeyword(rawInput, ['кисл', 'acidic', 'acid']);
        const alkalineByText = hasKeyword(rawInput, ['щелоч', 'alkaline', 'alkali']);
        const neutralByText = hasKeyword(rawInput, ['нейтр', 'neutral']);
        return {
            acidic: acidicByReagents || acidicByText,
            alkaline: alkalineByReagents || alkalineByText,
            neutral: neutralByReagents || neutralByText
        };
    }

    function hasHeatingCondition(raw) {
        const text = String(raw || '').toLowerCase();
        return /(нагрев|t°|темп|°c|\bt\b|heat|hot)/.test(text);
    }

    function hasConditionHint(raw) {
        const text = String(raw || '').toLowerCase();
        return /(конц|разб|оч\.|изб|недост|дефиц|сплав|нагрев|холод|пар|кат|раствор|расплав|горяч|электрол|электр|conc|dilut|excess|deficit|limited|heat|steam|catalyst|electrolysis|electro|solution|molten|melt|fusion|splav|spalv)/.test(text);
    }

    function hasExcessOn(raw, species) {
        const rawText = String(raw || '').toLowerCase();
        const text = normalizeRawInput(raw).toLowerCase();
        const key = species ? normalizeRawInput(species).toLowerCase() : '';
        if (!/(изб|excess)/.test(rawText) && !text.includes('изб') && !text.includes('excess')) return false;
        if (!key) return true;

        const escapedSpecies = String(species || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&').toLowerCase();
        if (escapedSpecies) {
            const taggedPattern = new RegExp(`${escapedSpecies}\\([^)]*(изб|excess)`);
            if (taggedPattern.test(rawText)) return true;
        }

        return text.includes(`изб${key}`)
            || text.includes(`excess${key}`)
            || text.includes(`${key}изб`)
            || text.includes(`${key}excess`);
    }

    function hasDeficitCondition(raw) {
        return hasKeyword(raw, ['недост', 'дефиц', 'limited', 'deficit']);
    }

    function isLikelyOrganicAcid(formula) {
        const f = String(formula || '');
        const counts = parseFormulaCounts(f);
        if (!counts.C) return false;
        const inorganicCarbonAcids = new Set(['H2CO3', 'H2SiO3', 'HCN']);
        return !inorganicCarbonAcids.has(f);
    }

    function getMetalChargePreferMax(metal) {
        return getIonCharge(metal, 'cation', 'max') || getIonCharge(metal, 'cation', 'min');
    }

    function ruleNeutralization(tokens) {
        if (!ionMaps) return null;
        if (tokens.length !== 2) return null;

        const first = normalizeToken(tokens[0], { stripConditions: true });
        const second = normalizeToken(tokens[1], { stripConditions: true });

        const tryPair = (acidStr, baseStr) => {
            if (isLikelyOrganicAcid(acidStr)) return null;
            const acid = parseAcid(acidStr);
            const base = parseBase(baseStr);
            if (!acid || !base) return null;

            const anionCharge = getIonCharge(acid.anionFormula, 'anion', 'min');
            const cationCharge = getIonCharge(base.cationFormula, 'cation', 'min') || base.ohCount;
            if (!anionCharge || !cationCharge) return null;

            const salt = buildSaltFormula(base.cationFormula, cationCharge, acid.anionFormula, anionCharge);
            const l = lcm(acid.hCount, base.ohCount);
            const acidCoeff = l / acid.hCount;
            const baseCoeff = l / base.ohCount;
            const waterCoeff = l;

            const left = `${formatCoeff(acidCoeff)}${acidStr} + ${formatCoeff(baseCoeff)}${baseStr}`;
            const right = `${salt} + ${formatCoeff(waterCoeff)}H2O`;
            return `${left} \u2192 ${right}`;
        };

        return tryPair(first, second) || tryPair(second, first);
    }

    function ruleBasicOxideWater(tokens) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const first = classifyFormula(a);
        const second = classifyFormula(b);
        const tryPair = (oxideStr, otherStr) => {
            if (classifyFormula(oxideStr).kind !== 'oxide') return null;
            if (classifyFormula(otherStr).kind !== 'water') return null;
            const oxideInfo = dataMaps.metalOxideMap.get(oxideStr);
            if (!oxideInfo || !oxideInfo.hydroxide) return null;
            const hydroxideClass = dataMaps.classMap.get(oxideInfo.hydroxide);
            const subclass = hydroxideClass?.subclass || '';
            if (!/strong/i.test(String(subclass))) return null;
            return `${oxideStr} + H2O \u2192 ${oxideInfo.hydroxide}`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleAcidicOxideWater(tokens) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (oxideStr, otherStr) => {
            const info = classifyFormula(oxideStr);
            if (info.kind !== 'oxide') return null;
            if (classifyFormula(otherStr).kind !== 'water') return null;
            if (oxideStr === 'SiO2') return null;
            const acid = dataMaps.oxideToAcidMap.get(oxideStr);
            if (!acid) return null;
            return `${oxideStr} + H2O \u2192 ${acid}`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleBasicOxideAcid(tokens) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const inferChargeFromOxide = (oxideStr, metal) => {
            const counts = parseFormulaCounts(oxideStr);
            const mCount = counts[metal] || 0;
            const oCount = counts.O || 0;
            if (!mCount || !oCount) return null;
            const charge = (2 * oCount) / mCount;
            return Number.isInteger(charge) && charge > 0 ? charge : null;
        };
        const tryPair = (oxideStr, acidStr) => {
            const info = classifyFormula(oxideStr);
            if (info.kind !== 'oxide') return null;
            if (isLikelyOrganicAcid(acidStr)) return null;
            const acid = parseAcid(acidStr);
            if (!acid) return null;
            const oxideInfo = dataMaps.metalOxideMap.get(oxideStr);
            if (!oxideInfo) return null;
            const metalSymbol = oxideInfo.metal ? oxideInfo.metal.replace(/\(.*\)$/, '') : null;
            if (!metalSymbol) return null;
            const cationCharge = inferChargeFromOxide(oxideStr, metalSymbol) || getMetalChargePreferMax(metalSymbol);
            const anionCharge = getIonCharge(acid.anionFormula, 'anion', 'min');
            if (!cationCharge || !anionCharge) return null;
            const salt = buildSaltFormula(metalSymbol, cationCharge, acid.anionFormula, anionCharge);
            return `${oxideStr} + ${acidStr} \u2192 ${salt} + H2O`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleAcidicOxideBase(tokens, rawInput) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (oxideStr, baseStr) => {
            const info = classifyFormula(oxideStr);
            if (info.kind !== 'oxide') return null;
            const base = parseBase(baseStr);
            if (!base) return null;
            if (oxideStr === 'SiO2' && !hasKeyword(rawInput, ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv']) && !hasHeatingCondition(rawInput)) {
                return null;
            }
            if (oxideStr === 'CO2' && ['NaOH', 'KOH'].includes(baseStr) && hasKeyword(rawInput, ['изб', 'excess'])) {
                const c = baseStr.startsWith('K') ? 'K' : 'Na';
                return `CO2 + ${baseStr} → ${c}HCO3`;
            }
            const baseClass = dataMaps.classMap.get(baseStr);
            const baseSubclass = baseClass?.subclass || '';
            if (!/strong/i.test(String(baseSubclass))) return null;
            const acid = dataMaps.oxideToAcidMap.get(oxideStr);
            if (!acid) return null;
            const acidParsed = parseAcid(acid);
            if (!acidParsed) return null;
            const cationCharge = getIonCharge(base.cationFormula, 'cation', 'min');
            const anionCharge = getIonCharge(acidParsed.anionFormula, 'anion', 'min');
            if (!cationCharge || !anionCharge) return null;
            const salt = buildSaltFormula(base.cationFormula, cationCharge, acidParsed.anionFormula, anionCharge);
            return `${oxideStr} + ${baseStr} \u2192 ${salt} + H2O`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleBasicOxideAcidicOxide(tokens) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (basicOxide, acidicOxide) => {
            const info = classifyFormula(basicOxide);
            if (info.kind !== 'oxide') return null;
            const acid = dataMaps.oxideToAcidMap.get(acidicOxide);
            if (!acid) return null;
            const oxideInfo = dataMaps.metalOxideMap.get(basicOxide);
            if (!oxideInfo) return null;
            const metalSymbol = oxideInfo.metal ? oxideInfo.metal.replace(/\(.*\)$/, '') : null;
            if (!metalSymbol) return null;
            const acidParsed = parseAcid(acid);
            if (!acidParsed) return null;
            const cationCharge = getIonCharge(metalSymbol, 'cation', 'min');
            const anionCharge = getIonCharge(acidParsed.anionFormula, 'anion', 'min');
            if (!cationCharge || !anionCharge) return null;
            const salt = buildSaltFormula(metalSymbol, cationCharge, acidParsed.anionFormula, anionCharge);
            return `${basicOxide} + ${acidicOxide} \u2192 ${salt}`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleAmphotericAcid(tokens) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (amphStr, acidStr) => {
            const info = classifyFormula(amphStr);
            if (info.kind !== 'oxide' && info.kind !== 'base') return null;
            if (!info.subclass || !String(info.subclass).includes('amphoteric')) return null;
            if (!parseAcid(acidStr)) return null;
            return ruleBasicOxideAcid([amphStr, acidStr]) || ruleNeutralization([amphStr, acidStr]);
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleAmphotericBase(tokens, rawInput) {
        if (hasKeyword(rawInput, ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv'])) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const alkalis = ['NaOH', 'KOH'];
        const amphMap = {
            'Al(OH)3': { coeff: 1, complex: '[Al(OH)4]' },
            'Zn(OH)2': { coeff: 2, complex: '[Zn(OH)4]' },
            'Be(OH)2': { coeff: 2, complex: '[Be(OH)4]' },
            'Cr(OH)3': { coeff: 1, complex: '[Cr(OH)4]' },
            'Sn(OH)2': { coeff: 2, complex: '[Sn(OH)4]' },
            'Pb(OH)2': { coeff: 2, complex: '[Pb(OH)4]' },
            'Al2O3': { coeff: 2, complex: '[Al(OH)4]', needsWater: 3 },
            'ZnO': { coeff: 2, complex: '[Zn(OH)4]', needsWater: 1 },
            'BeO': { coeff: 2, complex: '[Be(OH)4]', needsWater: 1 },
            'Cr2O3': { coeff: 2, complex: '[Cr(OH)4]', needsWater: 3 },
            'SnO': { coeff: 2, complex: '[Sn(OH)4]', needsWater: 1 },
            'PbO': { coeff: 2, complex: '[Pb(OH)4]', needsWater: 1 }
        };

        const tryPair = (amphStr, baseStr) => {
            if (!alkalis.includes(baseStr)) return null;
            const cfg = amphMap[amphStr];
            if (!cfg) return null;
            const cation = baseStr.replace('OH', '');
            const cationPart = cfg.coeff > 1 ? `${cation}${cfg.coeff}` : cation;
            const complexSalt = `${cationPart}${cfg.complex}`;
            const baseCoeff = cfg.coeff;
            const waterPart = cfg.needsWater ? ` + ${cfg.needsWater}H2O` : '';
            return `${amphStr} + ${baseCoeff} ${baseStr}${waterPart} \u2192 ${complexSalt}`;
        };

        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleMetalWater(tokens) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (metalStr, waterStr) => {
            if (classifyFormula(metalStr).kind !== 'metal') return null;
            if (classifyFormula(waterStr).kind !== 'water') return null;
            const hydroxide = dataMaps.metalToHydroxideMap.get(metalStr);
            if (!hydroxide) return null;
            const charge = getIonCharge(metalStr, 'cation', 'min');
            if (!charge) return null;
            if (charge === 1) {
                return `2${metalStr} + 2H2O \u2192 2${hydroxide} + H2\u2191`;
            }
            if (charge === 2) {
                return `${metalStr} + 2H2O \u2192 ${hydroxide} + H2\u2191`;
            }
            return `${metalStr} + H2O \u2192 ${hydroxide} + H2\u2191`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleMetalOxygen(tokens, rawInput) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (metalStr, oxygenStr) => {
            if (classifyFormula(metalStr).kind !== 'metal') return null;
            if (oxygenStr !== 'O2') return null;
            if (metalStr === 'Fe') return '3Fe + 2O2 \u2192 Fe3O4';
            const oxygenDeficit = hasKeyword(rawInput, ['недост', 'дефиц', 'огранич', 'малоo2', 'deficit', 'limited']);
            if (metalStr === 'Li') return '4Li + O2 \u2192 2Li2O';
            if (metalStr === 'Na') {
                return oxygenDeficit ? '4Na + O2 \u2192 2Na2O' : '2Na + O2 \u2192 Na2O2';
            }
            if (metalStr === 'K') {
                return oxygenDeficit ? '4K + O2 \u2192 2K2O' : '2K + O2 \u2192 2KO2';
            }
            if (metalStr === 'Rb' || metalStr === 'Cs') {
                return oxygenDeficit ? `4${metalStr} + O2 \u2192 2${metalStr}2O` : `${metalStr} + O2 \u2192 ${metalStr}O2`;
            }
            const oxide = dataMaps.metalToOxideMap.get(metalStr);
            if (!oxide) return null;
            const counts = parseFormulaCounts(oxide);
            const metalCount = counts[metalStr] || 1;
            const oxygenCount = counts.O || 1;
            const l = lcm(oxygenCount, 2);
            const oxideCoeff = l / oxygenCount;
            const o2Coeff = l / 2;
            const metalCoeff = metalCount * oxideCoeff;
            const left = `${formatCoeff(metalCoeff)}${metalStr} + ${formatCoeff(o2Coeff)}O2`;
            const right = `${formatCoeff(oxideCoeff)}${oxide}`;
            return `${left} \u2192 ${right}`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleNonmetalOxygen(tokens, rawInput) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (nonmetalStr, oxygenStr) => {
            if (oxygenStr !== 'O2') return null;
            if (nonmetalStr === 'H2') return '2H2 + O2 → 2H2O';
            if (nonmetalStr === 'N2') return 'N2 + O2 → 2NO';
            if (classifyFormula(nonmetalStr).kind !== 'nonmetal') return null;
            if (nonmetalStr === 'C' && hasKeyword(rawInput, ['недост', 'дефиц'])) {
                return '2C + O2 → 2CO';
            }
            // Pick first matching oxide from acid_oxide_pairs
            let oxide = null;
            for (const pair of dataMaps.oxideToAcidMap.entries()) {
                const [ox] = pair;
                const counts = parseFormulaCounts(ox);
                if (counts[nonmetalStr]) {
                    oxide = ox;
                    break;
                }
            }
            if (!oxide) return null;
            const counts = parseFormulaCounts(oxide);
            const elemCount = counts[nonmetalStr] || 1;
            const oxygenCount = counts.O || 1;
            const l = lcm(oxygenCount, 2);
            const oxideCoeff = l / oxygenCount;
            const o2Coeff = l / 2;
            const elemCoeff = elemCount * oxideCoeff;
            const left = `${formatCoeff(elemCoeff)}${nonmetalStr} + ${formatCoeff(o2Coeff)}O2`;
            const right = `${formatCoeff(oxideCoeff)}${oxide}`;
            return `${left} \u2192 ${right}`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleHalogenDisplacement(tokens) {
        if (!ionMaps) return null;
        if (tokens.length !== 2) return null;
        const order = ['F2', 'Cl2', 'Br2', 'I2'];
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (halogen, salt) => {
            if (!order.includes(halogen)) return null;
            const saltInfo = findHalideSalt(salt);
            if (!saltInfo) return null;
            const saltHal = `${saltInfo.anionFormula}2`;
            const canDisplace = order.indexOf(halogen) < order.indexOf(saltHal);
            if (!canDisplace) return null;
            const newSalt = buildSaltFormula(saltInfo.cationFormula, saltInfo.cationCharge, halogen.replace('2', ''), -1);
            const saltCoeff = Math.abs(saltInfo.cationCharge) === 1 ? 2 : 1;
            const leftSalt = `${formatCoeff(saltCoeff)}${salt}`;
            const rightSalt = `${formatCoeff(saltCoeff)}${newSalt}`;
            return `${halogen} + ${leftSalt} \u2192 ${rightSalt} + ${saltHal}`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleSpecialCombination(tokens) {
        if (hasAllReactants(tokens, ['Na', 'Cl2'])) return '2Na + Cl2 → 2NaCl';
        if (hasAllReactants(tokens, ['Fe', 'Cl2'])) return '2Fe + 3Cl2 → 2FeCl3';
        if (hasAllReactants(tokens, ['CH4', 'O2'])) return 'CH4 + 2O2 → CO2 + 2H2O';
        return null;
    }

    function ruleMetalAcid(tokens, rawInput) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (metalStr, acidStr) => {
            if (classifyFormula(metalStr).kind !== 'metal') return null;
            if (isLikelyOrganicAcid(acidStr)) return null;
            const acid = parseAcid(acidStr);
            if (!acid) return null;
            const acidInfo = dataMaps.classMap.get(acidStr);
            if (/HNO3/i.test(acidStr)) return null;
            if (/H2SO4/i.test(acidStr) && hasKeyword(rawInput, ['конц'])) return null;
            if (acidInfo && acidInfo.info && acidInfo.info.is_oxidizer) return null;
            const metalRank = dataMaps.activityMap.get(metalStr);
            const hRank = dataMaps.activityMap.get('H');
            if (metalRank && hRank && metalRank > hRank) return null;
            const cationCharge = getIonCharge(metalStr, 'cation', 'min');
            const anionCharge = getIonCharge(acid.anionFormula, 'anion', 'min');
            if (!cationCharge || !anionCharge) return null;
            const salt = buildSaltFormula(metalStr, cationCharge, acid.anionFormula, anionCharge);

            const g = gcd(Math.abs(cationCharge), Math.abs(anionCharge));
            const saltCationSub = Math.abs(anionCharge) / g;
            const saltAnionSub = Math.abs(cationCharge) / g;
            const saltCoeff = (saltAnionSub * acid.hCount) % 2 === 0 ? 1 : 2;
            const metalCoeff = saltCoeff * saltCationSub;
            const acidCoeff = saltCoeff * saltAnionSub;
            const h2Coeff = (acidCoeff * acid.hCount) / 2;

            return `${formatCoeff(metalCoeff)}${metalStr} + ${formatCoeff(acidCoeff)}${acidStr} \u2192 ${formatCoeff(saltCoeff)}${salt} + ${formatCoeff(h2Coeff)}H2\u2191`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleMetalHNO3(tokens, rawInput) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (metalStr, acidStr) => {
            if (classifyFormula(metalStr).kind !== 'metal') return null;
            if (!/HNO3/i.test(acidStr)) return null;

            const isConc = hasKeyword(rawInput, ['конц']);
            const isVeryDilute = hasKeyword(rawInput, ['оч.разб', 'оченьразб', 'оч.']);
            const isDilute = hasKeyword(rawInput, ['разб']) || !isConc;

            if (isConc) {
                // R03
                if (['Au', 'Pt'].includes(metalStr)) return null;
                const isHeated = hasHeatingCondition(rawInput);
                if (['Fe', 'Al', 'Cr'].includes(metalStr) && !isHeated) return null;

                const cationCharge = getMetalChargePreferMax(metalStr);
                const nitrate = buildSaltFormula(metalStr, cationCharge, 'NO3', -1);
                const tempLabel = isHeated ? '(t\u00b0)' : '';

                if (hasKeyword(rawInput, ['оченьконц', 'дым']) && ['Zn', 'Mg', 'Al'].includes(metalStr)) {
                    return `${metalStr} + HNO3(конц)${tempLabel} \u2192 ${nitrate} + N2O\u2191 + H2O`;
                }
                return `${metalStr} + HNO3(конц)${tempLabel} \u2192 ${nitrate} + NO2\u2191 + H2O`;
            }

            // R02 (dilute)
            if (['Au', 'Pt'].includes(metalStr)) return null;
            const metalRank = dataMaps.activityMap.get(metalStr) || 999;
            const isActive = metalRank <= (dataMaps.activityMap.get('Al') || 7);
            const cationCharge = getMetalChargePreferMax(metalStr);
            const nitrate = buildSaltFormula(metalStr, cationCharge, 'NO3', -1);
            if (isVeryDilute && isActive) {
                const n = cationCharge;
                const aCoeff = 8 / gcd(8, n);
                const bCoeff = (5 * aCoeff * n) / 4;
                const dCoeff = (aCoeff * n) / 8;
                const eCoeff = (3 * aCoeff * n) / 8;
                return `${formatCoeff(aCoeff)}${metalStr} + ${formatCoeff(bCoeff)}HNO3(оч.разб) \u2192 ${formatCoeff(aCoeff)}${nitrate} + ${formatCoeff(dCoeff)}NH4NO3 + ${formatCoeff(eCoeff)}H2O`;
            }
            if (hasKeyword(rawInput, ['слаб', 'умерен']) && isActive) {
                return `${metalStr} + HNO3(разб) \u2192 ${nitrate} + N2O\u2191 + H2O`;
            }
            return `${metalStr} + HNO3(разб) \u2192 ${nitrate} + NO\u2191 + H2O`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleMetalH2SO4Conc(tokens, rawInput) {
        if (!dataMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (metalStr, acidStr) => {
            if (classifyFormula(metalStr).kind !== 'metal') return null;
            if (!/H2SO4/i.test(acidStr) || !hasKeyword(rawInput, ['конц'])) return null;
            if (['Au', 'Pt'].includes(metalStr)) return null;

            const isHeated = hasHeatingCondition(rawInput);
            if (['Fe', 'Al', 'Cr'].includes(metalStr) && !isHeated) return null;

            const metalRank = dataMaps.activityMap.get(metalStr) || 999;
            const isVeryActive = metalRank <= (dataMaps.activityMap.get('Mg') || 7);
            const cationCharge = getMetalChargePreferMax(metalStr);
            const sulfate = buildSaltFormula(metalStr, cationCharge, 'SO4', -2);
            const tempLabel = isHeated ? '(t\u00b0)' : '';

            if (hasKeyword(rawInput, ['s\u2193', 'сера', 'редк']) && ['Zn', 'Mg'].includes(metalStr)) {
                return `${metalStr} + H2SO4(конц)${tempLabel} \u2192 ${sulfate} + S\u2193 + H2O`;
            }
            if (isVeryActive) {
                return `${metalStr} + H2SO4(конц)${tempLabel} \u2192 ${sulfate} + H2S\u2191 + H2O`;
            }
            return `${metalStr} + H2SO4(конц)${tempLabel} \u2192 ${sulfate} + SO2\u2191 + H2O`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleAmphotericFusion(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        if (!hasKeyword(rawInput, ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv'])) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (amphStr, baseStr) => {
            if (!['NaOH', 'KOH'].includes(baseStr)) return null;
            const map = {
                'Al2O3': 'NaAlO2',
                'ZnO': 'Na2ZnO2',
                'Zn(OH)2': 'Na2ZnO2',
                'BeO': 'Na2BeO2',
                'Be(OH)2': 'Na2BeO2',
                'Al(OH)3': 'NaAlO2',
                'Cr2O3': 'NaCrO2',
                'PbO': 'Na2PbO2',
                'Pb(OH)2': 'Na2PbO2',
                'SnO': 'Na2SnO2',
                'Sn(OH)2': 'Na2SnO2'
            };
            if (!map[amphStr]) return null;
            const salt = baseStr.startsWith('K') ? map[amphStr].replace(/^Na/, 'K') : map[amphStr];
            return `${amphStr} + ${baseStr} \u2192 ${salt} + H2O`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleAmphotericInAlkali(tokens, rawInput) {
        if (hasKeyword(rawInput, ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv'])) return null;
        const joined = normalizeRawInput(tokens.join('+'));
        const hasNaOH = joined.includes('NaOH');
        const hasKOH = joined.includes('KOH');
        if (!hasNaOH && !hasKOH) return null;
        const alkali = hasKOH ? 'KOH' : 'NaOH';
        const aluminate = hasKOH ? 'K[Al(OH)4]' : 'Na[Al(OH)4]';
        const zincate = hasKOH ? 'K2[Zn(OH)4]' : 'Na2[Zn(OH)4]';

        if (joined.includes('Al2O3') && joined.includes('H2O')) {
            return `Al2O3 + 2${alkali} + 3H2O \u2192 2${aluminate}`;
        }
        if (joined.includes('ZnO') && joined.includes('H2O')) {
            return `ZnO + 2${alkali} + H2O \u2192 ${zincate}`;
        }
        if (joined.includes('Al(OH)3')) {
            return `Al(OH)3 + ${alkali} \u2192 ${aluminate}`;
        }
        if (joined.includes('Zn(OH)2')) {
            return `Zn(OH)2 + 2${alkali} \u2192 ${zincate}`;
        }
        if (joined.includes('Al') && joined.includes('H2O')) {
            return `2Al + 2${alkali} + 6H2O \u2192 2${aluminate} + 3H2\u2191`;
        }
        if (joined.includes('Zn') && joined.includes('H2O')) {
            return `Zn + 2${alkali} + 2H2O \u2192 ${zincate} + H2\u2191`;
        }
        return null;
    }

    function ruleMetalSteam(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (metal, water) => {
            if (classifyFormula(metal).kind !== 'metal') return null;
            if (water !== 'H2O') return null;
            if (metal === 'Fe') return '3Fe + 4H2O \u2192 Fe3O4 + 4H2\u2191';
            if (metal === 'Zn') return 'Zn + H2O \u2192 ZnO + H2\u2191';
            if (metal === 'Mg') return 'Mg + H2O \u2192 MgO + H2\u2191';
            if (metal === 'Al') return '2Al + 3H2O \u2192 Al2O3 + 3H2\u2191';
            return null;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleHalogenAlkaliDisproportionation(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (halogen, alkali) => {
            if (!['Cl2', 'Br2', 'I2'].includes(halogen)) return null;
            if (!['NaOH', 'KOH'].includes(alkali)) return null;
            const m = alkali.startsWith('K') ? 'K' : 'Na';
            const normalizedRaw = normalizeRawInput(rawInput);
            const isHot = hasHeatingCondition(rawInput)
                || hasKeyword(rawInput, ['горяч', 'гор.'])
                || ((normalizedRaw.includes('3Cl2') || normalizedRaw.includes(`3${halogen}`))
                    && (normalizedRaw.includes('6NaOH') || normalizedRaw.includes('6KOH')));
            if (isHot) {
                return `3${halogen} + 6${alkali} \u2192 5${m}${halogen.replace('2', '')} + ${m}${halogen.replace('2', '')}O3 + 3H2O`;
            }
            return `${halogen} + 2${alkali} \u2192 ${m}${halogen.replace('2', '')} + ${m}${halogen.replace('2', '')}O + H2O`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleDecompositionNitrates(tokens, rawInput) {
        if (tokens.length !== 1) return null;
        const saltStr = normalizeToken(tokens[0], { stripConditions: true });
        if (!saltStr.includes('NO3')) return null;
        if (saltStr === 'NH4NO3') {
            if (hasKeyword(rawInput, ['сильн', 'оченьсильн', 'взрыв', 'strongheat'])) {
                return '2NH4NO3 \u2192 2N2\u2191 + O2\u2191 + 4H2O';
            }
            return 'NH4NO3 \u2192 N2O\u2191 + 2H2O';
        }
        const salt = detectSalt(saltStr);
        if (!salt) return null;
        const cation = salt.cationFormula;
        if (['Na', 'K', 'Rb', 'Cs'].includes(cation)) {
            const nitrite = buildSaltFormula(cation, getIonCharge(cation, 'cation', 'min'), 'NO2', -1);
            return `${saltStr} \u2192 ${nitrite} + O2\u2191`;
        }
        if (['Ag', 'Hg'].includes(cation)) {
            return `${saltStr} \u2192 ${cation} + NO2\u2191 + O2\u2191`;
        }
        const oxide = dataMaps.metalToOxideByChargeMap.get(`${cation}|${salt.cationCharge}`)
            || dataMaps.metalToOxideMap.get(cation);
        if (oxide) {
            return `${saltStr} \u2192 ${oxide} + NO2\u2191 + O2\u2191`;
        }
        return null;
    }

    function ruleDecompositionCarbonates(tokens, rawInput) {
        if (tokens.length !== 1) return null;
        const saltStr = normalizeToken(tokens[0], { stripConditions: true });
        if (!saltStr.includes('CO3')) return null;
        if (saltStr.includes('HCO3')) {
            const salt = detectSalt(saltStr);
            if (!salt) return null;
            const carbonate = buildSaltFormula(salt.cationFormula, salt.cationCharge, 'CO3', -2);
            return `${saltStr} \u2192 ${carbonate} + CO2\u2191 + H2O`;
        }
        const salt = detectSalt(saltStr);
        if (!salt) return null;
        if (['Na', 'K', 'Rb', 'Cs'].includes(salt.cationFormula)) return null;
        if (saltStr === 'FeCO3') return 'FeCO3 → FeO + CO2↑';
        const oxide = dataMaps.metalToOxideByChargeMap.get(`${salt.cationFormula}|${salt.cationCharge}`)
            || dataMaps.metalToOxideMap.get(salt.cationFormula);
        if (oxide) {
            return `${saltStr} \u2192 ${oxide} + CO2\u2191`;
        }
        return null;
    }

    function ruleDecompositionHydroxides(tokens, rawInput) {
        if (tokens.length !== 1) return null;
        const baseStr = normalizeToken(tokens[0], { stripConditions: true });
        if (!baseStr.includes('OH')) return null;
        const baseClass = dataMaps.classMap.get(baseStr);
        const subclass = String(baseClass?.subclass || '');
        if (/strong/i.test(subclass)) return null;
        const base = parseBase(baseStr);
        if (!base) return null;
        if (baseStr === 'Fe(OH)2') return 'Fe(OH)2 → FeO + H2O';
        const oxide = dataMaps.metalToOxideByChargeMap.get(`${base.cationFormula}|${base.ohCount}`)
            || dataMaps.metalToOxideMap.get(base.cationFormula);
        if (oxide) return `${baseStr} \u2192 ${oxide} + H2O`;
        return null;
    }

    function ruleHydrolysis(tokens) {
        if (!dataMaps) return null;
        if (tokens.length === 3 && hasAllReactants(tokens, ['Al2(SO4)3', 'Na2CO3', 'H2O'])) {
            return 'Al2(SO4)3 + 3Na2CO3 + 3H2O → 2Al(OH)3↓ + 3CO2↑ + 3Na2SO4';
        }
        if (tokens.length < 1 || tokens.length > 2) return null;
        const first = normalizeToken(tokens[0], { stripConditions: true });
        const second = tokens[1] ? normalizeToken(tokens[1], { stripConditions: true }) : '';
        const saltStr = first === 'H2O' ? second : first;
        const hasWater = first === 'H2O' || second === 'H2O' || tokens.length === 1;
        if (parseAcid(saltStr) || parseBase(saltStr) || saltStr === 'H2O') return null;
        const salt = detectSalt(saltStr);
        if (!salt || !hasWater) return null;
        if (saltStr === 'FeCl3') return 'FeCl3 + H2O ⇌ FeOHCl2 + HCl';
        if (saltStr === 'NH4Cl') return 'NH4Cl + H2O ⇌ NH3·H2O + HCl';
        if (saltStr === 'K2S') return 'K2S + H2O ⇌ KHS + KOH';
        if (saltStr === 'Al2S3') return 'Al2S3 + 6H2O → 2Al(OH)3↓ + 3H2S↑';

        const strongAcidAnions = new Set(['Cl', 'Br', 'I', 'NO3', 'ClO4']);
        const strongBaseCations = new Set(['Li', 'Na', 'K', 'Rb', 'Cs', 'Ca', 'Sr', 'Ba']);
        const acid = buildAcidFormula(salt.anionFormula, salt.anionCharge);
        const base = buildSaltFormula(salt.cationFormula, salt.cationCharge, 'OH', -1);

        const weakAcid = !strongAcidAnions.has(salt.anionFormula) && (isWeakAcid(acid) || ['CO3', 'S', 'SO3', 'SiO3', 'PO4'].includes(salt.anionFormula));
        const weakBase = !strongBaseCations.has(salt.cationFormula) && (isWeakBase(base) || ['NH4', 'Al', 'Fe', 'Zn', 'Cu', 'Cr'].includes(salt.cationFormula));

        if (weakAcid && weakBase) {
            return `${saltStr} + 2H2O \u21cc ${acid} + ${base}`;
        }
        if (weakAcid) {
            if (Math.abs(salt.anionCharge) <= 1) return null;
            const acidSalt = buildSaltFormula(salt.cationFormula, salt.cationCharge, `H${salt.anionFormula}`, salt.anionCharge + 1);
            const hydroxide = buildSaltFormula(salt.cationFormula, salt.cationCharge, 'OH', -1);
            return `${saltStr} + H2O \u21cc ${acidSalt} + ${hydroxide}`;
        }
        if (weakBase) {
            const basicSalt = buildSaltFormula(`H`, 1, salt.anionFormula, salt.anionCharge);
            return `${saltStr} + H2O \u21cc ${base} + ${basicSalt}`;
        }
        return null;
    }

    function ruleAcidSaltBase(tokens) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (acidSalt, baseStr) => {
            if (!parseBase(baseStr)) return null;
            if (!/HCO3|HSO4|HSO3|H2PO4/.test(acidSalt)) return null;
            const salt = detectSalt(acidSalt);
            if (!salt) return null;
            const targetAnion = acidSalt.includes('HCO3') ? 'CO3' :
                acidSalt.includes('HSO4') ? 'SO4' :
                    acidSalt.includes('HSO3') ? 'SO3' : 'PO4';
            const anionCharge = getIonCharge(targetAnion, 'anion', 'min');
            if (!anionCharge) return null;
            const newSalt = buildSaltFormula(salt.cationFormula, salt.cationCharge, targetAnion, anionCharge);
            return `${acidSalt} + ${baseStr} \u2192 ${newSalt} + H2O`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleSaltAcidSalt(tokens) {
        if (tokens.length < 2 || tokens.length > 3) return null;
        const joined = normalizeRawInput(tokens.join('+'));
        if (joined.includes('Na2SO3') && joined.includes('SO2') && joined.includes('H2O')) {
            return 'Na2SO3 + SO2 + H2O → 2NaHSO3';
        }
        if (joined.includes('Na2CO3') && joined.includes('CO2') && joined.includes('H2O')) {
            return 'Na2CO3 + CO2 + H2O \u2192 2NaHCO3';
        }
        if (joined.includes('Na2SO4') && joined.includes('H2SO4')) {
            return 'Na2SO4 + H2SO4 \u2192 2NaHSO4';
        }
        if (joined.includes('Na3PO4') && joined.includes('H3PO4')) {
            return 'Na3PO4 + H3PO4 \u2192 3NaH2PO4';
        }
        return null;
    }

    function ruleKMnO4(tokens, rawInput) {
        if (!hasAllReactants(tokens, ['KMnO4'])) return null;

        const medium = detectRedoxMedium(tokens, rawInput);
        const acidic = medium.acidic;
        const alkaline = medium.alkaline;
        const neutralOrDefault = medium.neutral || (!acidic && !alkaline);

        const fe2Salt = getPresentReactant(tokens, ['FeSO4', 'FeCl2']);
        const sulfite = getPresentReactant(tokens, ['Na2SO3', 'K2SO3']);
        const nitrite = getPresentReactant(tokens, ['KNO2', 'NaNO2']);
        const halide = getPresentReactant(tokens, ['KI', 'KBr']);

        if (
            acidic
            && hasAnyReactant(tokens, ['HCl'])
            && !hasAnyReactant(tokens, ['FeSO4', 'FeCl2', 'SnCl2', 'KI', 'KBr', 'H2O2', 'H2C2O4', 'KNO2', 'NaNO2', 'Na2SO3', 'K2SO3'])
        ) {
            return '2KMnO4 + 16HCl \u2192 2MnCl2 + 5Cl2\u2191 + 2KCl + 8H2O';
        }
        if (acidic && fe2Salt) {
            if (fe2Salt === 'FeCl2') {
                return '2KMnO4 + 10FeCl2 + 18H2SO4 \u2192 K2SO4 + 2MnSO4 + 5Fe2(SO4)3 + 20HCl + 8H2O';
            }
            return '2KMnO4 + 10FeSO4 + 8H2SO4 \u2192 K2SO4 + 2MnSO4 + 5Fe2(SO4)3 + 8H2O';
        }
        if (acidic && halide) {
            if (halide === 'KBr') {
                return '2KMnO4 + 10KBr + 8H2SO4 \u2192 2MnSO4 + 5Br2 + 6K2SO4 + 8H2O';
            }
            return '2KMnO4 + 10KI + 8H2SO4 \u2192 2MnSO4 + 5I2 + 6K2SO4 + 8H2O';
        }
        if (acidic && hasAnyReactant(tokens, ['H2O2'])) {
            return '2KMnO4 + 5H2O2 + 3H2SO4 \u2192 2MnSO4 + 5O2\u2191 + K2SO4 + 8H2O';
        }
        if (acidic && hasAnyReactant(tokens, ['H2C2O4'])) {
            return '2KMnO4 + 5H2C2O4 + 3H2SO4 \u2192 K2SO4 + 2MnSO4 + 10CO2\u2191 + 8H2O';
        }
        if (acidic && nitrite) {
            if (nitrite === 'NaNO2') {
                return '2KMnO4 + 5NaNO2 + 3H2SO4 \u2192 K2SO4 + 2MnSO4 + 5NaNO3 + 3H2O';
            }
            return '2KMnO4 + 5KNO2 + 3H2SO4 \u2192 2MnSO4 + 5KNO3 + K2SO4 + 3H2O';
        }
        if (acidic && sulfite) {
            if (sulfite === 'K2SO3') {
                return '2KMnO4 + 5K2SO3 + 3H2SO4 \u2192 2MnSO4 + 6K2SO4 + 3H2O';
            }
            return '2KMnO4 + 5Na2SO3 + 3H2SO4 \u2192 2MnSO4 + 5Na2SO4 + K2SO4 + 3H2O';
        }
        if (alkaline && sulfite) {
            if (sulfite === 'K2SO3') {
                return '2KMnO4 + K2SO3 + 2KOH \u2192 2K2MnO4 + K2SO4 + H2O';
            }
            return '2KMnO4 + Na2SO3 + 2KOH \u2192 2K2MnO4 + Na2SO4 + H2O';
        }
        if (neutralOrDefault && sulfite) {
            if (sulfite === 'K2SO3') {
                return '2KMnO4 + 3K2SO3 + H2O \u2192 2MnO2\u2193 + 3K2SO4 + 2KOH';
            }
            return '2KMnO4 + 3Na2SO3 + H2O \u2192 2MnO2\u2193 + 3Na2SO4 + 2KOH';
        }
        return null;
    }

    function ruleChromateDichromatePH(tokens, rawInput) {
        const rawJoined = normalizeRawInput(tokens.join('+'));
        const medium = detectRedoxMedium(tokens, rawInput);
        const hasK2Cr2O7 = hasAllReactants(tokens, ['K2Cr2O7']);
        const hasK2CrO4 = hasAllReactants(tokens, ['K2CrO4']);
        const hasNa2CrO4 = hasAllReactants(tokens, ['Na2CrO4']);

        if ((hasK2CrO4 || hasNa2CrO4) && medium.acidic) {
            if (hasAllReactants(tokens, ['H2SO4'])) {
                if (hasK2CrO4) {
                    return '2K2CrO4 + H2SO4 \u2192 K2Cr2O7 + K2SO4 + H2O';
                }
                return '2Na2CrO4 + H2SO4 \u2192 Na2Cr2O7 + Na2SO4 + H2O';
            }
            return '2CrO4²⁻ + 2H⁺ ⇌ Cr2O7²⁻ + H2O';
        }
        if (hasK2Cr2O7 && medium.alkaline) {
            if (hasAnyReactant(tokens, ['KOH'])) {
                return 'K2Cr2O7 + 2KOH \u2192 2K2CrO4 + H2O';
            }
            if (hasAnyReactant(tokens, ['NaOH'])) {
                return 'K2Cr2O7 + 2NaOH \u2192 K2CrO4 + Na2CrO4 + H2O';
            }
            return 'Cr2O7²⁻ + 2OH⁻ ⇌ 2CrO4²⁻ + H2O';
        }
        if (rawJoined.includes('CrO4') && rawJoined.includes('H')) {
            return '2CrO4²⁻ + 2H⁺ ⇌ Cr2O7²⁻ + H2O';
        }
        return null;
    }

    function ruleChromatePrecipitation(tokens) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const sa = detectSalt(a);
        const sb = detectSalt(b);
        if (!sa || !sb) return null;

        let chromate = null;
        let reagent = null;
        if (sa.anionFormula === 'CrO4') {
            chromate = { formula: a, salt: sa };
            reagent = { formula: b, salt: sb };
        } else if (sb.anionFormula === 'CrO4') {
            chromate = { formula: b, salt: sb };
            reagent = { formula: a, salt: sa };
        }
        if (!chromate || !reagent) return null;
        if (!['Ba', 'Pb', 'Ag'].includes(reagent.salt.cationFormula)) return null;

        const precipitate = buildSaltFormula(
            reagent.salt.cationFormula,
            reagent.salt.cationCharge,
            'CrO4',
            -2
        );
        const spectatorSalt = buildSaltFormula(
            chromate.salt.cationFormula,
            chromate.salt.cationCharge,
            reagent.salt.anionFormula,
            reagent.salt.anionCharge
        );

        return `${chromate.formula} + ${reagent.formula} \u2192 ${precipitate}\u2193 + ${spectatorSalt}`;
    }

    function ruleDichromateRedox(tokens, rawInput) {
        if (!hasAllReactants(tokens, ['K2Cr2O7'])) return null;
        const medium = detectRedoxMedium(tokens, rawInput);
        if (!medium.acidic && !hasAnyReactant(tokens, ['H2SO4', 'HCl'])) return null;

        const sulfite = getPresentReactant(tokens, ['Na2SO3', 'K2SO3']);
        const halide = getPresentReactant(tokens, ['KI', 'KBr']);

        if (hasAllReactants(tokens, ['FeSO4', 'H2SO4'])) {
            return 'K2Cr2O7 + 6FeSO4 + 7H2SO4 \u2192 Cr2(SO4)3 + 3Fe2(SO4)3 + K2SO4 + 7H2O';
        }
        if (hasAllReactants(tokens, ['FeCl2', 'HCl'])) {
            return 'K2Cr2O7 + 6FeCl2 + 14HCl \u2192 2CrCl3 + 6FeCl3 + 2KCl + 7H2O';
        }
        if (hasAllReactants(tokens, ['H2S', 'H2SO4'])) {
            return 'K2Cr2O7 + 3H2S + 4H2SO4 \u2192 Cr2(SO4)3 + 3S\u2193 + K2SO4 + 7H2O';
        }
        if (sulfite && hasAllReactants(tokens, ['H2SO4'])) {
            if (sulfite === 'K2SO3') {
                return 'K2Cr2O7 + 3K2SO3 + 4H2SO4 \u2192 Cr2(SO4)3 + 4K2SO4 + 4H2O';
            }
            return 'K2Cr2O7 + 3Na2SO3 + 4H2SO4 \u2192 Cr2(SO4)3 + 3Na2SO4 + K2SO4 + 4H2O';
        }
        if (halide && hasAllReactants(tokens, ['H2SO4'])) {
            if (halide === 'KBr') {
                return 'K2Cr2O7 + 6KBr + 7H2SO4 \u2192 Cr2(SO4)3 + 3Br2 + 4K2SO4 + 7H2O';
            }
            return 'K2Cr2O7 + 6KI + 7H2SO4 \u2192 Cr2(SO4)3 + 3I2 + 4K2SO4 + 7H2O';
        }
        if (hasAllReactants(tokens, ['H2O2', 'H2SO4'])) {
            return 'K2Cr2O7 + 3H2O2 + 4H2SO4 \u2192 Cr2(SO4)3 + K2SO4 + 7H2O + 3O2\u2191';
        }
        if (hasAllReactants(tokens, ['SnCl2', 'HCl'])) {
            return 'K2Cr2O7 + 3SnCl2 + 14HCl \u2192 2CrCl3 + 3SnCl4 + 2KCl + 7H2O';
        }
        if (hasAllReactants(tokens, ['HCl']) && !hasAnyReactant(tokens, ['SnCl2', 'FeCl2'])) {
            return 'K2Cr2O7 + 14HCl \u2192 2CrCl3 + 3Cl2\u2191 + 2KCl + 7H2O';
        }
        return null;
    }

    function ruleK2Cr2O7(tokens, rawInput) {
        return ruleChromateDichromatePH(tokens, rawInput)
            || ruleChromatePrecipitation(tokens)
            || ruleDichromateRedox(tokens, rawInput);
    }

    function ruleChromiumAmphoteric(tokens, rawInput) {
        const medium = detectRedoxMedium(tokens, rawInput);
        if (!medium.alkaline && !hasAnyReactant(tokens, ['KOH', 'NaOH'])) return null;

        if (hasAllReactants(tokens, ['Cr(OH)3', 'H2O2', 'KOH'])) {
            return '2Cr(OH)3 + 3H2O2 + 4KOH \u2192 2K2CrO4 + 8H2O';
        }
        if (hasAllReactants(tokens, ['Cr(OH)3', 'H2O2', 'NaOH'])) {
            return '2Cr(OH)3 + 3H2O2 + 4NaOH \u2192 2Na2CrO4 + 8H2O';
        }
        if (hasAllReactants(tokens, ['Cr(OH)3', 'KOH'])) {
            return 'Cr(OH)3 + 3KOH \u2192 K3[Cr(OH)6]';
        }
        if (hasAllReactants(tokens, ['Cr(OH)3', 'NaOH'])) {
            return 'Cr(OH)3 + 3NaOH \u2192 Na3[Cr(OH)6]';
        }
        return null;
    }

    function ruleK2Cr2O7FeSO4(tokens) {
        if (hasAllReactants(tokens, ['K2Cr2O7', 'FeSO4', 'H2SO4'])) {
            return 'K2Cr2O7 + 6FeSO4 + 7H2SO4 \u2192 Cr2(SO4)3 + 3Fe2(SO4)3 + K2SO4 + 7H2O';
        }
        return null;
    }

    function inferElectrolysisMode(tokens, rawInput) {
        const isMelt = hasKeyword(rawInput, ['расплав', 'molten', 'melt']);
        const isAq = hasKeyword(rawInput, ['раствор', 'р-р', 'рра', 'aq', 'водн', 'solution']) || hasAllReactants(tokens, ['H2O']);
        if (isMelt) return 'melt';
        if (isAq) return 'aq';
        return 'aq';
    }

    function buildMoltenHydroxideElectrolysis(baseFormula) {
        const base = parseBase(baseFormula);
        if (!base) return null;
        const n = base.ohCount || 1;
        const a = 4;
        const metalCoeff = a;
        const oxygenCoeff = (a * n) / 4;
        const waterCoeff = (a * n) / 2;
        const g = gcd(gcd(metalCoeff, oxygenCoeff), waterCoeff);
        const leftCoeff = a / g;
        const mCoeff = metalCoeff / g;
        const oCoeff = oxygenCoeff / g;
        const wCoeff = waterCoeff / g;
        return `${formatCoeff(leftCoeff)}${baseFormula} \u2192 ${formatCoeff(mCoeff)}${base.cationFormula} + ${formatCoeff(oCoeff)}O2\u2191 + ${formatCoeff(wCoeff)}H2O`;
    }

    function classifyElectroAnion(anionFormula) {
        if (['Cl', 'Br', 'I'].includes(anionFormula)) return 'halide';
        if (anionFormula === 'F') return 'fluoride';
        if (anionFormula === 'S') return 'sulfide';
        if (anionFormula === 'OH') return 'hydroxide';
        return 'oxygen';
    }

    function inferAqCathodeProduct(cationFormula) {
        if (cationFormula === 'H' || cationFormula === 'NH4') return 'H2';
        const rankAl = dataMaps?.activityMap?.get('Al');
        const rank = dataMaps?.activityMap?.get(cationFormula);
        if (rankAl && rank && rank > rankAl) return cationFormula;
        return 'H2';
    }

    function ruleElectrolysis(tokens, rawInput) {
        if (!hasKeyword(rawInput, ['элект', 'электролиз', 'electrolysis', 'electro'])) return null;
        const normalizedTokens = (tokens || []).map((t) => normalizeToken(t, { stripConditions: true }));
        const joined = normalizeRawInput(normalizedTokens.join('+'));
        const mode = inferElectrolysisMode(normalizedTokens, rawInput);
        const electrolyte = normalizedTokens.find((t) => t && t !== 'H2O') || 'H2O';

        if (electrolyte === 'H2O') {
            return '2H2O \u2192 2H2\u2191 + O2\u2191';
        }

        if (mode === 'aq') {
            if (electrolyte === 'NaCl') return '2NaCl + 2H2O \u2192 2NaOH + H2\u2191 + Cl2\u2191';
            if (electrolyte === 'AgNO3') return '4AgNO3 + 2H2O \u2192 4Ag + O2\u2191 + 4HNO3';
            if (electrolyte === 'KBr') return '2KBr + 2H2O \u2192 2KOH + H2\u2191 + Br2\u2191';
            if (electrolyte === 'CuSO4') return '2CuSO4 + 2H2O \u2192 2Cu + O2\u2191 + 2H2SO4';
            if (electrolyte === 'Cu(NO3)2') return '2Cu(NO3)2 + 2H2O \u2192 2Cu + O2\u2191 + 4HNO3';
            if (electrolyte === 'FeCl2') return 'FeCl2 \u2192 Fe + Cl2\u2191';
            if (electrolyte === 'NiBr2') return 'NiBr2 \u2192 Ni + Br2\u2191';

            const salt = detectSalt(electrolyte);
            if (!salt) {
                const base = parseBase(electrolyte);
                if (base || parseAcid(electrolyte)) {
                    return '2H2O \u2192 2H2\u2191 + O2\u2191';
                }
                return null;
            }

            const cation = salt.cationFormula;
            const anion = salt.anionFormula;
            const anionClass = classifyElectroAnion(anion);
            const cathodeProduct = inferAqCathodeProduct(cation);
            const cathodeIsMetal = cathodeProduct !== 'H2';
            const anodeIsOxidizableAnion = anionClass === 'halide' || anionClass === 'sulfide';
            const anodeProduct = anionClass === 'halide' ? `${anion}2`
                : anionClass === 'sulfide' ? 'S'
                    : 'O2';

            if (anodeIsOxidizableAnion && cathodeIsMetal) {
                return `${electrolyte} \u2192 ${cathodeProduct} + ${anodeProduct}\u2191`.replace('S↑', 'S↓');
            }

            if (anodeIsOxidizableAnion && !cathodeIsMetal) {
                const hydroxide = buildSaltFormula(cation, salt.cationCharge, 'OH', -1);
                const anodeTail = anionClass === 'sulfide' ? 'S↓' : `${anion}2\u2191`;
                return `${electrolyte} + H2O \u2192 ${hydroxide} + H2\u2191 + ${anodeTail}`;
            }

            if (!anodeIsOxidizableAnion && cathodeIsMetal) {
                const acid = buildAcidFormula(anion, salt.anionCharge);
                return `${electrolyte} + H2O \u2192 ${cathodeProduct} + O2\u2191 + ${acid}`;
            }

            // Active cation + oxygen-containing anion / fluoride: water is discharged on both electrodes.
            return '2H2O \u2192 2H2\u2191 + O2\u2191';
        }

        // Molten electrolysis
        if (electrolyte === 'Al2O3') return '2Al2O3 \u2192 4Al + 3O2\u2191';
        if (electrolyte === 'NaOH' || electrolyte === 'KOH' || parseBase(electrolyte)) {
            return buildMoltenHydroxideElectrolysis(electrolyte);
        }

        const meltSalt = detectSalt(electrolyte);
        if (meltSalt) {
            const anionClass = classifyElectroAnion(meltSalt.anionFormula);
            if (anionClass === 'halide' || anionClass === 'fluoride') {
                return `${electrolyte} \u2192 ${meltSalt.cationFormula} + ${meltSalt.anionFormula}2\u2191`;
            }
            if (anionClass === 'sulfide') {
                return `${electrolyte} \u2192 ${meltSalt.cationFormula} + S\u2193`;
            }
            if (meltSalt.anionFormula === 'NO3') {
                return `${electrolyte} \u2192 ${meltSalt.cationFormula} + NO2\u2191 + O2\u2191`;
            }
            if (meltSalt.anionFormula === 'SO4') {
                return `${electrolyte} \u2192 ${meltSalt.cationFormula} + SO3\u2191 + O2\u2191`;
            }
            if (meltSalt.anionFormula === 'CO3') {
                return `${electrolyte} \u2192 ${meltSalt.cationFormula} + CO2\u2191 + O2\u2191`;
            }
            if (anionClass === 'oxygen' || anionClass === 'hydroxide') {
                return `${electrolyte} \u2192 ${meltSalt.cationFormula} + O2\u2191`;
            }
        }

        if (joined.includes('H2O')) return '2H2O \u2192 2H2\u2191 + O2\u2191';
        return null;
    }

    function ruleConcH2SO4WithHalogenHydrides(tokens, rawInput) {
        const joined = normalizeRawInput(tokens.join('+'));
        if (!joined.includes('H2SO4')) return null;
        if (joined.includes('HBr')) {
            return 'H2SO4(конц) + 2HBr \u2192 SO2\u2191 + Br2 + 2H2O';
        }
        if (joined.includes('HI')) {
            return 'H2SO4(конц) + 8HI \u2192 H2S\u2191 + 4I2 + 4H2O';
        }
        return null;
    }

    function ruleThermite(tokens, rawInput) {
        const joined = normalizeRawInput(tokens.join('+'));
        if (joined.includes('Fe2O3') && joined.includes('Al')) {
            return 'Fe2O3 + 2Al \u2192 Al2O3 + 2Fe';
        }
        if (joined.includes('Cr2O3') && joined.includes('Al')) {
            return 'Cr2O3 + 2Al \u2192 Al2O3 + 2Cr';
        }
        return null;
    }

    function rulePeroxideSuperoxide(tokens) {
        const joined = normalizeRawInput(tokens.join('+'));
        if (joined.includes('Na2O2') && joined.includes('H2O')) {
            return '2Na2O2 + 2H2O \u2192 4NaOH + O2\u2191';
        }
        if (joined.includes('Na2O2') && joined.includes('CO2')) {
            return '2Na2O2 + 2CO2 \u2192 2Na2CO3 + O2\u2191';
        }
        if (joined.includes('KO2') && joined.includes('H2O')) {
            return '4KO2 + 2H2O \u2192 4KOH + 3O2\u2191';
        }
        if (joined.includes('KO2') && joined.includes('CO2')) {
            return '4KO2 + 2CO2 \u2192 2K2CO3 + 3O2\u2191';
        }
        return null;
    }

    function ruleComplexFormation(tokens, rawInput) {
        const joined = normalizeRawInput(tokens.join('+'));
        if (joined.includes('Cu(OH)2') && joined.includes('NH3')) {
            return 'Cu(OH)2 + 4NH3 \u2192 [Cu(NH3)4](OH)2';
        }
        if (joined.includes('AgCl') && joined.includes('NH3')) {
            return 'AgCl + 2NH3 \u2192 [Ag(NH3)2]Cl';
        }
        return null;
    }

    function ruleAmmoniaAndNOx(tokens, rawInput) {
        if (tokens.length === 1) {
            const single = normalizeToken(tokens[0], { stripConditions: true });
            if (single === 'N2O4') return 'N2O4 \u21cc 2NO2';
        }
        if (hasAllReactants(tokens, ['NH3', 'O2'])) {
            if (hasKeyword(rawInput, ['безкат', 'без кат'])) {
                return '4NH3 + 3O2 \u2192 2N2 + 6H2O';
            }
            return '4NH3 + 5O2 \u2192 4NO + 6H2O';
        }
        if (hasAllReactants(tokens, ['NO', 'O2'])) {
            return '2NO + O2 \u2192 2NO2';
        }
        if (hasAllReactants(tokens, ['NO2', 'H2O'])) {
            return '2NO2 + H2O \u2192 HNO2 + HNO3';
        }
        return null;
    }

    function ruleSOxOxidation(tokens, rawInput) {
        if (hasAllReactants(tokens, ['SO2', 'O2'])) {
            if (hasKeyword(rawInput, ['кат', 'v2o5', 't', 'нагрев'])) {
                return '2SO2 + O2 \u21cc 2SO3';
            }
            return '2SO2 + O2 \u2192 2SO3';
        }
        if (hasAllReactants(tokens, ['SO2', 'NaOH'])) {
            if (hasExcessOn(rawInput, 'SO2')) return 'SO2 + NaOH \u2192 NaHSO3';
            if (hasExcessOn(rawInput, 'NaOH')) return 'SO2 + 2NaOH \u2192 Na2SO3 + H2O';
            return 'SO2 + 2NaOH \u2192 Na2SO3 + H2O';
        }
        if (hasAllReactants(tokens, ['SO2', 'KOH'])) {
            if (hasExcessOn(rawInput, 'SO2')) return 'SO2 + KOH \u2192 KHSO3';
            if (hasExcessOn(rawInput, 'KOH')) return 'SO2 + 2KOH \u2192 K2SO3 + H2O';
            return 'SO2 + 2KOH \u2192 K2SO3 + H2O';
        }
        if (hasAllReactants(tokens, ['SO2', 'H2S'])) {
            return 'SO2 + 2H2S \u2192 3S\u2193 + 2H2O';
        }
        if (hasAllReactants(tokens, ['SO2', 'Br2', 'H2O'])) {
            return 'SO2 + Br2 + 2H2O \u2192 H2SO4 + 2HBr';
        }
        return null;
    }

    function ruleHalogenHalideAq(tokens) {
        if (hasAllReactants(tokens, ['Cl2', 'KBr'])) return 'Cl2 + 2KBr \u2192 2KCl + Br2';
        if (hasAllReactants(tokens, ['Cl2', 'KI'])) return 'Cl2 + 2KI \u2192 2KCl + I2';
        if (hasAllReactants(tokens, ['Br2', 'KI'])) return 'Br2 + 2KI \u2192 2KBr + I2';
        return null;
    }

    function ruleAmmoniaWithAcids(tokens) {
        if (hasAllReactants(tokens, ['NH3', 'HCl'])) return 'NH3 + HCl \u2192 NH4Cl';
        if (hasAllReactants(tokens, ['NH3', 'HNO3'])) return 'NH3 + HNO3 \u2192 NH4NO3';
        if (hasAllReactants(tokens, ['NH3', 'H2SO4'])) return '2NH3 + H2SO4 \u2192 (NH4)2SO4';
        if (hasAllReactants(tokens, ['NH3', 'CO2', 'H2O'])) return 'NH3 + CO2 + H2O \u2192 NH4HCO3';
        return null;
    }

    function ruleQualitativeRedox(tokens) {
        if (hasAllReactants(tokens, ['FeCl2', 'KMnO4', 'H2SO4'])) {
            return '2KMnO4 + 10FeCl2 + 18H2SO4 \u2192 K2SO4 + 2MnSO4 + 5Fe2(SO4)3 + 20HCl + 8H2O';
        }
        if (hasAllReactants(tokens, ['KI', 'KIO3', 'H2SO4'])) {
            return '5KI + KIO3 + 3H2SO4 \u2192 3I2 + 3K2SO4 + 3H2O';
        }
        return null;
    }

    function ruleHydrogenPeroxide(tokens, rawInput) {
        if (tokens.length === 1 && normalizeToken(tokens[0], { stripConditions: true }) === 'H2O2') {
            return '2H2O2 \u2192 2H2O + O2\u2191';
        }
        if (hasAllReactants(tokens, ['H2O2', 'KI']) || hasAllReactants(tokens, ['H2O2', 'MnO2'])) {
            return '2H2O2 \u2192 2H2O + O2\u2191';
        }
        return null;
    }

    function ruleCarbidesNitridesPhosphidesHydrolysis(tokens) {
        if (!hasAllReactants(tokens, ['H2O'])) return null;
        if (hasAllReactants(tokens, ['CaC2', 'H2O'])) return 'CaC2 + 2H2O \u2192 C2H2\u2191 + Ca(OH)2';
        if (hasAllReactants(tokens, ['AlN', 'H2O'])) return 'AlN + 3H2O \u2192 Al(OH)3 + NH3\u2191';
        if (hasAllReactants(tokens, ['Mg3N2', 'H2O'])) return 'Mg3N2 + 6H2O \u2192 3Mg(OH)2 + 2NH3\u2191';
        if (hasAllReactants(tokens, ['Ca3P2', 'H2O'])) return 'Ca3P2 + 6H2O \u2192 3Ca(OH)2 + 2PH3\u2191';
        if (hasAllReactants(tokens, ['Al4C3', 'H2O'])) return 'Al4C3 + 12H2O \u2192 4Al(OH)3 + 3CH4\u2191';
        return null;
    }

    function ruleNO2Alkali(tokens) {
        if (hasAllReactants(tokens, ['NO2', 'NaOH'])) return '2NO2 + 2NaOH \u2192 NaNO2 + NaNO3 + H2O';
        if (hasAllReactants(tokens, ['NO2', 'KOH'])) return '2NO2 + 2KOH \u2192 KNO2 + KNO3 + H2O';
        return null;
    }

    function ruleHalogenWater(tokens) {
        if (tokens.length !== 2) return null;
        if (hasAllReactants(tokens, ['Cl2', 'H2O'])) return 'Cl2 + H2O \u21cc HCl + HClO';
        if (hasAllReactants(tokens, ['Br2', 'H2O'])) return 'Br2 + H2O \u21cc HBr + HBrO';
        if (hasAllReactants(tokens, ['F2', 'H2O'])) return '2F2 + 2H2O \u2192 4HF + O2\u2191';
        return null;
    }

    function ruleThermalOxidizerDecomposition(tokens, rawInput) {
        if (tokens.length === 1) {
            const single = normalizeToken(tokens[0], { stripConditions: true });
            if (single === 'KClO3') return '2KClO3 \u2192 2KCl + 3O2\u2191';
            if (single === 'KMnO4') return '2KMnO4 \u2192 K2MnO4 + MnO2 + O2\u2191';
            if (single === 'NH4NO2') return 'NH4NO2 \u2192 N2\u2191 + 2H2O';
            if (single === 'FeSO4') return '2FeSO4 \u2192 Fe2O3 + SO2\u2191 + SO3\u2191';
            if (single === 'KNO2') return '2KNO2 \u2192 K2O + NO\u2191 + NO2\u2191';
            return null;
        }
        if (tokens.length === 2 && hasAllReactants(tokens, ['KClO3', 'MnO2'])) {
            if (hasKeyword(rawInput, ['кат', 'catalyst', 'mnо2']) || hasHeatingCondition(rawInput)) {
                return '2KClO3 \u2192 2KCl + 3O2\u2191';
            }
        }
        return null;
    }

    function ruleReductionByCO(tokens, rawInput) {
        if (hasAllReactants(tokens, ['Fe2O3', 'CO'])) return 'Fe2O3 + 3CO \u2192 2Fe + 3CO2';
        if (hasAllReactants(tokens, ['CuO', 'CO'])) return 'CuO + CO \u2192 Cu + CO2';
        if (hasAllReactants(tokens, ['PbO', 'CO'])) return 'PbO + CO \u2192 Pb + CO2';
        return null;
    }

    function ruleReductionByCarbon(tokens, rawInput) {
        if (hasAllReactants(tokens, ['Fe2O3', 'C'])) return '2Fe2O3 + 3C \u2192 4Fe + 3CO2';
        if (hasAllReactants(tokens, ['ZnO', 'C'])) return 'ZnO + C \u2192 Zn + CO';
        if (hasAllReactants(tokens, ['CuO', 'C'])) return '2CuO + C \u2192 2Cu + CO2';
        return null;
    }

    function ruleDehydration(tokens) {
        const joined = normalizeRawInput(tokens.join('+'));
        if (joined.includes('C12H22O11') && joined.includes('H2SO4')) {
            return 'C12H22O11 + H2SO4(конц) \u2192 12C + 11H2O + H2SO4(конц)';
        }
        if (joined.includes('CuSO4') && joined.includes('5H2O') && joined.includes('H2SO4')) {
            return 'CuSO4\u00b75H2O + H2SO4(конц) \u2192 CuSO4 + H2SO4\u00b75H2O';
        }
        return null;
    }

    function ruleAquaRegia(tokens) {
        const joined = normalizeRawInput(tokens.join('+'));
        if (joined.includes('Au') && joined.includes('HNO3') && joined.includes('HCl')) {
            return 'Au + HNO3 + 4HCl \u2192 H[AuCl4] + NO\u2191 + 2H2O';
        }
        if (joined.includes('Pt') && joined.includes('HNO3') && joined.includes('HCl')) {
            return '3Pt + 4HNO3 + 18HCl \u2192 3H2[PtCl6] + 4NO\u2191 + 8H2O';
        }
        return null;
    }

    function ruleSilicicAcid(tokens) {
        const joined = normalizeRawInput(tokens.join('+'));
        if (joined.includes('Na2SiO3') && joined.includes('HCl')) {
            return 'Na2SiO3 + 2HCl \u2192 2NaCl + H2SiO3\u2193';
        }
        return null;
    }

    function ruleUnstableAcids(tokens) {
        if (tokens.length !== 1) return null;
        const acid = normalizeToken(tokens[0], { stripConditions: true });
        if (acid === 'H2CO3') return 'H2CO3 \u2192 CO2\u2191 + H2O';
        if (acid === 'H2SO3') return 'H2SO3 \u2192 SO2\u2191 + H2O';
        if (acid === 'HNO2') return '2HNO2 \u2192 NO\u2191 + NO2\u2191 + H2O';
        if (acid === 'H2SiO3') return 'H2SiO3 \u2192 SiO2 + H2O';
        return null;
    }

    function ruleSiliconSpecific(tokens, rawInput) {
        const hotFusion = hasKeyword(rawInput, ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv']) || hasHeatingCondition(rawInput);
        if (hasAllReactants(tokens, ['SiO2', 'NaOH'])) {
            if (!hotFusion) return null;
            return 'SiO2 + 2NaOH \u2192 Na2SiO3 + H2O';
        }
        if (hasAllReactants(tokens, ['SiO2', 'KOH'])) {
            if (!hotFusion) return null;
            return 'SiO2 + 2KOH \u2192 K2SiO3 + H2O';
        }
        if (hasAllReactants(tokens, ['SiO2', 'Na2CO3'])) {
            if (!hotFusion) return null;
            return 'SiO2 + Na2CO3 \u2192 Na2SiO3 + CO2\u2191';
        }
        if (hasAllReactants(tokens, ['SiO2', 'CaO'])) {
            if (!hotFusion) return null;
            return 'SiO2 + CaO \u2192 CaSiO3';
        }
        if (hasAllReactants(tokens, ['SiO2', 'HF'])) {
            return 'SiO2 + 4HF \u2192 SiF4\u2191 + 2H2O';
        }
        if (hasAllReactants(tokens, ['Si', 'NaOH', 'H2O'])) {
            return 'Si + 2NaOH + H2O \u2192 Na2SiO3 + 2H2\u2191';
        }
        if (hasAllReactants(tokens, ['Si', 'KOH', 'H2O'])) {
            return 'Si + 2KOH + H2O \u2192 K2SiO3 + 2H2\u2191';
        }
        if (hasAllReactants(tokens, ['Na2SiO3', 'CO2', 'H2O'])) {
            return 'Na2SiO3 + CO2 + H2O \u2192 Na2CO3 + H2SiO3\u2193';
        }
        return null;
    }

    function rulePhosphorusSpecific(tokens, rawInput) {
        if (hasAllReactants(tokens, ['P', 'O2'])) {
            if (hasDeficitCondition(rawInput)) return '4P + 3O2 \u2192 2P2O3';
            return '4P + 5O2 \u2192 2P2O5';
        }
        if (hasAllReactants(tokens, ['P', 'Cl2'])) {
            if (hasExcessOn(rawInput, 'Cl2')) return '2P + 5Cl2 \u2192 2PCl5';
            if (hasDeficitCondition(rawInput)) return '2P + 3Cl2 \u2192 2PCl3';
            return '2P + 3Cl2 \u2192 2PCl3';
        }
        if (hasAllReactants(tokens, ['P', 'Ca'])) return '3Ca + 2P \u2192 Ca3P2';
        if (hasAllReactants(tokens, ['P', 'Na'])) return '3Na + P \u2192 Na3P';
        if (hasAllReactants(tokens, ['PCl3', 'H2O'])) return 'PCl3 + 3H2O \u2192 H3PO3 + 3HCl';
        if (hasAllReactants(tokens, ['PCl5', 'H2O'])) return 'PCl5 + 4H2O \u2192 H3PO4 + 5HCl';
        return null;
    }

    function ruleCarbonSpecific(tokens, rawInput) {
        if (hasAllReactants(tokens, ['C', 'H2O'])) {
            if (hasKeyword(rawInput, ['пар', 'steam']) || hasHeatingCondition(rawInput)) {
                return 'C + H2O \u2192 CO + H2\u2191';
            }
            return null;
        }
        if (hasAllReactants(tokens, ['CO2', 'C'])) {
            if (hasHeatingCondition(rawInput) || hasKeyword(rawInput, ['t', 'нагрев', 'кокс'])) {
                return 'CO2 + C \u2192 2CO';
            }
            return null;
        }
        if (hasAllReactants(tokens, ['CO2', 'Mg'])) {
            return '2Mg + CO2 \u2192 2MgO + C';
        }
        if (hasAllReactants(tokens, ['CO', 'NaOH'])) {
            if (hasKeyword(rawInput, ['конц', 'давл', 'pressure', 'highp'])) {
                return 'CO + NaOH \u2192 HCOONa';
            }
            return null;
        }
        if (hasAllReactants(tokens, ['CO', 'KOH'])) {
            if (hasKeyword(rawInput, ['конц', 'давл', 'pressure', 'highp'])) {
                return 'CO + KOH \u2192 HCOOK';
            }
            return null;
        }
        return null;
    }

    function ruleSulfidesSpecific(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        if (hasAllReactants(tokens, ['FeS2', 'O2'])) {
            return '4FeS2 + 11O2 \u2192 2Fe2O3 + 8SO2\u2191';
        }
        if (hasAllReactants(tokens, ['CuS', 'HNO3'])) {
            return '3CuS + 8HNO3 \u2192 3Cu(NO3)2 + 3S\u2193 + 2NO\u2191 + 4H2O';
        }
        if (hasAllReactants(tokens, ['PbS', 'HNO3'])) {
            return '3PbS + 8HNO3 \u2192 3Pb(NO3)2 + 3S\u2193 + 2NO\u2191 + 4H2O';
        }
        return null;
    }

    function ruleIodineStarch(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        const normalized = tokens.map((t) => normalizeToken(t, { stripConditions: true }).toLowerCase());
        const hasIodine = normalized.includes('i2');
        const hasStarch = normalized.some((t) =>
            t === 'starch'
            || t.includes('крахмал')
            || t.includes('krakhmal')
            || t.includes('krahmal')
        );
        if (!hasIodine || !hasStarch) return null;
        return 'I2 + starch \u2192 I2·starch (синий комплекс)';
    }

    function ruleAmmoniaReducing(tokens, rawInput) {
        if (hasAllReactants(tokens, ['NH3', 'CuO'])) {
            return '2NH3 + 3CuO \u2192 3Cu + N2\u2191 + 3H2O';
        }
        return null;
    }

    function ruleHalogenLabPreparation(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        if (hasAllReactants(tokens, ['HCl', 'MnO2'])) {
            if (!hasHeatingCondition(rawInput) && !hasKeyword(rawInput, ['конц', 'conc'])) return null;
            return 'MnO2 + 4HCl \u2192 MnCl2 + Cl2\u2191 + 2H2O';
        }
        return null;
    }

    function ruleComplexQualitative(tokens, rawInput) {
        if (hasAllReactants(tokens, ['FeCl3', 'KSCN'])) return 'FeCl3 + 3KSCN \u2192 Fe(SCN)3 + 3KCl';
        if (hasAllReactants(tokens, ['FeCl3', 'K4[Fe(CN)6]'])) return 'FeCl3 + K4[Fe(CN)6] \u2192 KFe[Fe(CN)6]\u2193 + 3KCl';
        if (hasAllReactants(tokens, ['FeCl2', 'K3[Fe(CN)6]'])) return 'FeCl2 + K3[Fe(CN)6] \u2192 KFe[Fe(CN)6]\u2193 + 2KCl';
        if (hasAllReactants(tokens, ['AgNO3', 'NH3'])) return 'AgNO3 + 2NH3 \u2192 [Ag(NH3)2]NO3';
        if (hasAllReactants(tokens, ['Zn(OH)2', 'NH3'])) return 'Zn(OH)2 + 4NH3 \u2192 [Zn(NH3)4](OH)2';
        return null;
    }

    function ruleAmphotericSaltExcessAlkali(tokens, rawInput) {
        if (!(hasKeyword(rawInput, ['изб', 'excess']) || hasExcessOn(rawInput))) return null;
        if (hasAllReactants(tokens, ['AlCl3', 'NaOH'])) return 'AlCl3 + 4NaOH \u2192 Na[Al(OH)4] + 3NaCl';
        if (hasAllReactants(tokens, ['AlCl3', 'KOH'])) return 'AlCl3 + 4KOH \u2192 K[Al(OH)4] + 3KCl';
        return null;
    }

    function ruleAmmoniumDecomposition(tokens, rawInput) {
        if (tokens.length !== 1) return null;
        const single = normalizeToken(tokens[0], { stripConditions: true });
        if (single === 'NH4Cl') return 'NH4Cl \u2192 NH3\u2191 + HCl\u2191';
        if (single === 'NH4HCO3') return 'NH4HCO3 \u2192 NH3\u2191 + CO2\u2191 + H2O';
        if (single === '(NH4)2Cr2O7') return '(NH4)2Cr2O7 \u2192 Cr2O3 + N2\u2191 + 4H2O';
        return null;
    }

    function ruleReductionByHydrogen(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        if (hasAllReactants(tokens, ['Fe2O3', 'H2'])) return 'Fe2O3 + 3H2 \u2192 2Fe + 3H2O';
        if (hasAllReactants(tokens, ['CuO', 'H2'])) return 'CuO + H2 \u2192 Cu + H2O';
        if (hasAllReactants(tokens, ['WO3', 'H2'])) return 'WO3 + 3H2 \u2192 W + 3H2O';
        return null;
    }

    function ruleMetalNonmetalSynthesis(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        if (hasAllReactants(tokens, ['Fe', 'S'])) return 'Fe + S \u2192 FeS';
        if (hasAllReactants(tokens, ['Cu', 'S'])) return 'Cu + S \u2192 CuS';
        if (hasAllReactants(tokens, ['Na', 'S'])) return '2Na + S \u2192 Na2S';
        if (hasAllReactants(tokens, ['Ca', 'N2'])) return '3Ca + N2 \u2192 Ca3N2';
        if (hasAllReactants(tokens, ['Mg', 'N2'])) return '3Mg + N2 \u2192 Mg3N2';
        if (hasAllReactants(tokens, ['Li', 'N2'])) return '6Li + N2 \u2192 2Li3N';
        return null;
    }

    function ruleNonmetalNonmetalSynthesis(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        if (hasAllReactants(tokens, ['H2', 'Cl2'])) return 'H2 + Cl2 \u2192 2HCl';
        if (hasAllReactants(tokens, ['H2', 'S'])) return 'H2 + S \u2192 H2S';
        if (hasAllReactants(tokens, ['N2', 'H2'])) return 'N2 + 3H2 \u21cc 2NH3';
        return null;
    }

    function ruleFe2ToFe3Oxidation(tokens, rawInput) {
        if (hasAllReactants(tokens, ['Fe(OH)2', 'O2', 'H2O'])) {
            return '4Fe(OH)2 + O2 + 2H2O \u2192 4Fe(OH)3';
        }
        if (hasAllReactants(tokens, ['FeCl2', 'Cl2'])) {
            return '2FeCl2 + Cl2 \u2192 2FeCl3';
        }
        return null;
    }

    function ruleLimewaterCO2(tokens, rawInput) {
        if (!hasAllReactants(tokens, ['Ca(OH)2', 'CO2'])) return null;
        if (hasKeyword(rawInput, ['изб', 'excess'])) {
            return 'Ca(OH)2 + 2CO2 \u2192 Ca(HCO3)2';
        }
        return 'Ca(OH)2 + CO2 \u2192 CaCO3\u2193 + H2O';
    }

    function ruleLabAcidGeneration(tokens, rawInput) {
        if (!hasKeyword(rawInput, ['конц', 'conc'])) return null;
        if (hasAllReactants(tokens, ['H2SO4', 'NaCl'])) {
            return 'NaCl + H2SO4(конц) \u2192 NaHSO4 + HCl\u2191';
        }
        if (hasAllReactants(tokens, ['H2SO4', 'NaNO3'])) {
            return 'NaNO3 + H2SO4(конц) \u2192 NaHSO4 + HNO3\u2191';
        }
        return null;
    }

    // =========================================
    // NEW ALGORITHMIC RULES
    // =========================================

    /**
     * R80: Improved nitrate decomposition — algorithmic.
     * Groups: alkali (→ nitrite + O2), Li (→ oxide), 
     * middle activity (→ oxide + NO2 + O2), noble metals (→ metal + NO2 + O2).
     */
    function ruleDecompositionNitratesExtended(tokens, rawInput) {
        if (tokens.length !== 1) return null;
        const saltStr = normalizeToken(tokens[0], { stripConditions: true });
        if (!saltStr.includes('NO3')) return null;
        if (saltStr === 'NH4NO3') {
            if (hasKeyword(rawInput, ['сильн', 'оченьсильн', 'взрыв', 'strongheat'])) {
                return '2NH4NO3 → 2N2↑ + O2↑ + 4H2O';
            }
            return 'NH4NO3 → N2O↑ + 2H2O';
        }
        const salt = detectSalt(saltStr);
        if (!salt || salt.anionFormula !== 'NO3') return null;
        const cation = salt.cationFormula;
        const cationCharge = salt.cationCharge;
        if (!dataMaps) return null;

        const metalRank = dataMaps.activityMap ? dataMaps.activityMap.get(cation) : null;
        const rankMg = dataMaps.activityMap ? dataMaps.activityMap.get('Mg') : 5;
        const rankCu = dataMaps.activityMap ? dataMaps.activityMap.get('Cu') : 14;

        // Group 1: Alkali metals EXCEPT Li → nitrite + O2
        if (['Na', 'K', 'Rb', 'Cs', 'Ba', 'Sr', 'Ca'].includes(cation)) {
            const nitrite = buildSaltFormula(cation, cationCharge, 'NO2', -1);
            // 2MeNO3 → 2MeNO2 + O2
            return `2${saltStr} → 2${nitrite} + O2↑`;
        }

        // Group 2: Li is special — decomposes to oxide like middle metals
        if (cation === 'Li') {
            return `4LiNO3 → 2Li2O + 4NO2↑ + O2↑`;
        }

        // Group 3: Noble metals (Ag, Hg, Au, Pt) → free metal + NO2 + O2
        if (['Ag', 'Hg', 'Au', 'Pt'].includes(cation)) {
            // 2Me(NO3)n → 2Me + 2n·NO2 + n·O2
            const n = cationCharge;
            const saltCoeff = 2;
            const no2Coeff = 2 * n;
            const o2Coeff = n;
            const g = gcd(gcd(saltCoeff, no2Coeff), o2Coeff);
            return `${formatCoeff(saltCoeff / g)}${saltStr} → ${formatCoeff(saltCoeff / g)}${cation} + ${formatCoeff(no2Coeff / g)}NO2↑ + ${formatCoeff(o2Coeff / g)}O2↑`;
        }

        // Group 4: Middle metals (Mg to Cu inclusive) → oxide + NO2 + O2
        const oxide = dataMaps.metalToOxideByChargeMap
            ? (dataMaps.metalToOxideByChargeMap.get(`${cation}|${cationCharge}`) || dataMaps.metalToOxideMap.get(cation))
            : null;
        if (oxide) {
            // 2Me(NO3)n → Me_xO_y + 2n·NO2 + n·O2  (auto-balanced)
            const n = cationCharge;
            const no2Coeff = 2 * n;
            const o2Coeff = n;
            return `${saltStr} → ${oxide} + ${formatCoeff(no2Coeff)}NO2↑ + ${formatCoeff(o2Coeff / 2)}O2↑`;
        }
        return null;
    }

    /**
     * R81: Extended silicon chemistry — algorithmic.
     * Si + halogens, SiH4 combustion, silicide hydrolysis, glass production.
     */
    function ruleSiliconExtended(tokens, rawInput) {
        const joined = normalizeRawInput(tokens.join('+'));
        const hotFusion = hasKeyword(rawInput, ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv']) || hasHeatingCondition(rawInput);

        // Si + Halogen → SiX4
        if (tokens.length === 2 && hasAllReactants(tokens, ['Si'])) {
            const halogens = { 'F2': 'SiF4', 'Cl2': 'SiCl4', 'Br2': 'SiBr4' };
            for (const [hal, product] of Object.entries(halogens)) {
                if (hasAllReactants(tokens, [hal])) {
                    return `Si + 2${hal} → ${product}`;
                }
            }
        }

        // SiH4 + O2 → SiO2 + H2O (silane combustion)
        if (hasAllReactants(tokens, ['SiH4', 'O2'])) {
            return 'SiH4 + 2O2 → SiO2 + 2H2O';
        }

        // Mg2Si + HCl → MgCl2 + SiH4 (silane preparation)
        if (hasAllReactants(tokens, ['Mg2Si', 'HCl'])) {
            return 'Mg2Si + 4HCl → 2MgCl2 + SiH4↑';
        }
        if (hasAllReactants(tokens, ['Mg2Si', 'H2SO4'])) {
            return 'Mg2Si + 2H2SO4 → 2MgSO4 + SiH4↑';
        }

        // SiO2 + K2CO3 (fusion) → K2SiO3 + CO2
        if (hasAllReactants(tokens, ['SiO2', 'K2CO3']) && hotFusion) {
            return 'SiO2 + K2CO3 → K2SiO3 + CO2↑';
        }

        // SiO2 + CaCO3 (fusion) → CaSiO3 + CO2
        if (hasAllReactants(tokens, ['SiO2', 'CaCO3']) && hotFusion) {
            return 'SiO2 + CaCO3 → CaSiO3 + CO2↑';
        }

        // SiO2 + MgO (fusion) → MgSiO3
        if (hasAllReactants(tokens, ['SiO2', 'MgO']) && hotFusion) {
            return 'SiO2 + MgO → MgSiO3';
        }

        // SiCl4 + H2O → H2SiO3 + HCl (hydrolysis of SiCl4)
        if (hasAllReactants(tokens, ['SiCl4', 'H2O'])) {
            return 'SiCl4 + 3H2O → H2SiO3↓ + 4HCl';
        }

        // Si + HF + HNO3 → H2SiF6 + NO + H2O (etching)
        if (hasAllReactants(tokens, ['Si', 'HF', 'HNO3'])) {
            return '3Si + 4HNO3 + 18HF → 3H2SiF6 + 4NO↑ + 8H2O';
        }

        return null;
    }

    /**
     * R82: Extended complex formation — algorithmic.
     * Any soluble salt of Cu, Ni, Co, Zn, Ag, Cd + NH3 → ammoniate.
     * Complex destruction by acid or CO2.
     */
    function ruleExtendedComplexes(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });

        // Ammoniate formation: salt + NH3 → [Me(NH3)n]salt
        const ammoniateCoords = {
            'Cu': { n: 4, charge: 2 },
            'Ni': { n: 6, charge: 2 },
            'Co': { n: 6, charge: 2 },
            'Zn': { n: 4, charge: 2 },
            'Ag': { n: 2, charge: 1 },
            'Cd': { n: 4, charge: 2 }
        };

        const tryAmmoniate = (saltStr, nh3Str) => {
            if (nh3Str !== 'NH3') return null;
            const salt = detectSalt(saltStr);
            if (!salt) return null;
            const cfg = ammoniateCoords[salt.cationFormula];
            if (!cfg || salt.cationCharge !== cfg.charge) return null;

            const anionCharge = salt.anionCharge;
            const absAnionCharge = Math.abs(anionCharge);
            const anionCount = cfg.charge / absAnionCharge;
            if (!Number.isInteger(anionCount)) return null;

            const anionPart = anionCount > 1
                ? (isPolyatomic(salt.anionFormula) ? `(${salt.anionFormula})${anionCount}` : `${salt.anionFormula}${anionCount}`)
                : salt.anionFormula;
            const complex = `[${salt.cationFormula}(NH3)${cfg.n}]${anionPart}`;

            return `${saltStr} + ${cfg.n}NH3 → ${complex}`;
        };

        const amm = tryAmmoniate(a, b) || tryAmmoniate(b, a);
        if (amm) return amm;

        // Complex destruction by acid: Na[Al(OH)4] + HCl → AlCl3 + NaCl + H2O
        const tryComplexDestruction = (complexStr, acidStr) => {
            const acid = parseAcid(acidStr);
            if (!acid) return null;

            // Na[Al(OH)4] + 4HCl → AlCl3 + NaCl + 4H2O
            if (complexStr === 'Na[Al(OH)4]' && acidStr === 'HCl') {
                return 'Na[Al(OH)4] + 4HCl → AlCl3 + NaCl + 4H2O';
            }
            if (complexStr === 'K[Al(OH)4]' && acidStr === 'HCl') {
                return 'K[Al(OH)4] + 4HCl → AlCl3 + KCl + 4H2O';
            }
            if (complexStr === 'Na2[Zn(OH)4]' && acidStr === 'HCl') {
                return 'Na2[Zn(OH)4] + 4HCl → ZnCl2 + 2NaCl + 4H2O';
            }
            if (complexStr === 'K2[Zn(OH)4]' && acidStr === 'HCl') {
                return 'K2[Zn(OH)4] + 4HCl → ZnCl2 + 2KCl + 4H2O';
            }
            return null;
        };

        const destr = tryComplexDestruction(a, b) || tryComplexDestruction(b, a);
        if (destr) return destr;

        // Complex destruction by CO2: Na[Al(OH)4] + CO2 → Al(OH)3↓ + NaHCO3
        const tryComplexCO2 = (complexStr, gasStr) => {
            if (gasStr !== 'CO2') return null;
            if (complexStr === 'Na[Al(OH)4]') return 'Na[Al(OH)4] + CO2 → Al(OH)3↓ + NaHCO3';
            if (complexStr === 'K[Al(OH)4]') return 'K[Al(OH)4] + CO2 → Al(OH)3↓ + KHCO3';
            if (complexStr === 'Na2[Zn(OH)4]') return 'Na2[Zn(OH)4] + 2CO2 → Zn(OH)2↓ + 2NaHCO3';
            if (complexStr === 'K2[Zn(OH)4]') return 'K2[Zn(OH)4] + 2CO2 → Zn(OH)2↓ + 2KHCO3';
            return null;
        };

        const co2 = tryComplexCO2(a, b) || tryComplexCO2(b, a);
        if (co2) return co2;

        // Be(OH)2 + NaOH/KOH → Na2[Be(OH)4]
        const tryBeryllate = (amphStr, baseStr) => {
            if (amphStr !== 'Be(OH)2') return null;
            if (baseStr === 'NaOH') return 'Be(OH)2 + 2NaOH → Na2[Be(OH)4]';
            if (baseStr === 'KOH') return 'Be(OH)2 + 2KOH → K2[Be(OH)4]';
            return null;
        };

        const berr = tryBeryllate(a, b) || tryBeryllate(b, a);
        if (berr) return berr;

        return null;
    }

    /**
     * R83: HNO3 / H2SO4(conc) passivation detection.
     * Fe, Al, Cr + conc HNO3 (cold) → no reaction (passivation).
     */
    function rulePassivation(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });

        const tryPassivation = (metalStr, acidStr) => {
            if (!['Fe', 'Al', 'Cr'].includes(metalStr)) return null;
            const isConc = hasKeyword(rawInput, ['конц']);
            const isHeated = hasHeatingCondition(rawInput);

            // Trigger passivation if concentrated acid is used WITHOUT heating
            if (isHeated) return null;

            if (isConc && (/HNO3/i.test(acidStr) || /H2SO4/i.test(acidStr))) {
                return `${metalStr} + ${acidStr} ↛ (пассивация: на поверхности образуется защитная оксидная плёнка)`;
            }
            return null;
        };

        return tryPassivation(a, b) || tryPassivation(b, a);
    }

    /**
     * R84: Tin / Lead specific with HNO3 — algorithmic.
     * Sn + HNO3(разб) → Sn(NO3)2 + NH4NO3 + H2O
     * Sn + HNO3(конц) → H2SnO3↓ + NO2 + H2O (β-оловянная кислота)
     * Pb + HNO3(разб) → Pb(NO3)2 + NO + H2O
     */
    function ruleSnPbHNO3(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });

        const tryPair = (metalStr, acidStr) => {
            if (!/HNO3/i.test(acidStr)) return null;
            const isConc = hasKeyword(rawInput, ['конц']);

            if (metalStr === 'Sn') {
                if (isConc) {
                    return 'Sn + 4HNO3(конц) → H2SnO3↓ + 4NO2↑ + H2O';
                }
                return '4Sn + 10HNO3(разб) → 4Sn(NO3)2 + NH4NO3 + 3H2O';
            }
            return null;
        };

        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleSaltAcid(tokens) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (saltStr, acidStr) => {
            const salt = detectSalt(saltStr);
            const acid = parseAcid(acidStr);
            if (!salt || !acid) return null;
            const newSalt = buildSaltFormula(salt.cationFormula, salt.cationCharge, acid.anionFormula, getIonCharge(acid.anionFormula, 'anion', 'min'));
            const newAcid = buildAcidFormula(salt.anionFormula, salt.anionCharge);
            const newSaltSol = getSolubility(salt.cationFormula, salt.cationCharge, acid.anionFormula, getIonCharge(acid.anionFormula, 'anion', 'min'));
            const newAcidWeak = isWeakAcid(newAcid) || isGasProduct(newAcid);
            if (isInsoluble(newSaltSol) || newAcidWeak) {
                const gasPart = isGasProduct(newAcid)
                    ? ` + ${newAcid === 'H2CO3' ? 'CO2↑ + H2O' : newAcid === 'H2SO3' ? 'SO2↑ + H2O' : newAcid === 'H2S' ? 'H2S↑' : 'NH3↑ + H2O'}`
                    : ` + ${newAcid}`;
                return `${saltStr} + ${acidStr} \u2192 ${newSalt}${gasPart}`;
            }
            return null;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleSaltBase(tokens) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (saltStr, baseStr) => {
            const salt = detectSalt(saltStr);
            const base = parseBase(baseStr);
            if (!salt || !base) return null;
            const anionCharge = salt.anionCharge;
            const cationCharge = salt.cationCharge;
            const baseCationCharge = getIonCharge(base.cationFormula, 'cation', 'min');
            const newSalt = buildSaltFormula(base.cationFormula, baseCationCharge, salt.anionFormula, anionCharge);
            const newBase = buildSaltFormula(salt.cationFormula, cationCharge, 'OH', -1);
            const newSaltSol = getSolubility(base.cationFormula, baseCationCharge, salt.anionFormula, anionCharge);
            const newBaseWeak = isWeakBase(newBase) || isInsoluble(getSolubility(salt.cationFormula, cationCharge, 'OH', -1));
            if (isInsoluble(newSaltSol) || newBaseWeak || newBase === 'NH4OH') {
                const basePart = newBase === 'NH4OH' ? 'NH3↑ + H2O' : newBase;
                return `${saltStr} + ${baseStr} \u2192 ${newSalt} + ${basePart}`;
            }
            return null;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleSaltSalt(tokens) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (saltStr1, saltStr2) => {
            const s1 = detectSalt(saltStr1);
            const s2 = detectSalt(saltStr2);
            if (!s1 || !s2) return null;
            const newSalt1 = buildSaltFormula(s1.cationFormula, s1.cationCharge, s2.anionFormula, s2.anionCharge);
            const newSalt2 = buildSaltFormula(s2.cationFormula, s2.cationCharge, s1.anionFormula, s1.anionCharge);
            const sol1 = getSolubility(s1.cationFormula, s1.cationCharge, s2.anionFormula, s2.anionCharge);
            const sol2 = getSolubility(s2.cationFormula, s2.cationCharge, s1.anionFormula, s1.anionCharge);
            if (isInsoluble(sol1) || isInsoluble(sol2)) {
                const product1 = isInsoluble(sol1) ? `${newSalt1}\u2193` : newSalt1;
                const product2 = isInsoluble(sol2) ? `${newSalt2}\u2193` : newSalt2;
                return `${saltStr1} + ${saltStr2} \u2192 ${product1} + ${product2}`;
            }
            return null;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function ruleMetalSalt(tokens) {
        if (!dataMaps || !ionMaps) return null;
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const tryPair = (metalStr, saltStr) => {
            if (classifyFormula(metalStr).kind !== 'metal') return null;
            if (!isSaltLikeFormula(saltStr)) return null;
            const salt = detectSalt(saltStr);
            if (!salt) return null;
            const metalRank = dataMaps.activityMap.get(metalStr);
            const saltMetalRank = dataMaps.activityMap.get(salt.cationFormula);
            if (!metalRank || !saltMetalRank) return null;
            if (metalRank >= saltMetalRank) return null;
            const newSalt = buildSaltFormula(metalStr, getIonCharge(metalStr, 'cation', 'min'), salt.anionFormula, salt.anionCharge);
            return `${metalStr} + ${saltStr} \u2192 ${newSalt} + ${salt.cationFormula}`;
        };
        return tryPair(a, b) || tryPair(b, a);
    }

    function parseEquationCompound(token) {
        const trimmed = String(token || '').trim();
        const match = trimmed.match(/^(\d+)\s*(.+)$/);
        if (match) {
            return { formula: match[2].trim() };
        }
        return { formula: trimmed };
    }

    function stripPhaseMarkers(formula) {
        return String(formula || '').replace(/[↑↓]/g, '');
    }

    function buildBalanceMatrix(reactants, products) {
        const all = [...reactants, ...products];
        const signs = all.map((_, idx) => (idx < reactants.length ? 1 : -1));
        const elementSet = new Set();
        const countsList = all.map((cmp) => {
            const counts = parseFormulaCounts(stripPhaseMarkers(cmp.formula));
            Object.keys(counts).forEach((el) => elementSet.add(el));
            return counts;
        });
        const elements = Array.from(elementSet);
        if (!elements.length) return null;
        return elements.map((el) => all.map((_, idx) => (countsList[idx][el] || 0) * signs[idx]));
    }

    function solveCoefficientsBruteforce(matrix, termsCount, maxCoeff = 12) {
        const coeffs = new Array(termsCount).fill(1);
        while (true) {
            let valid = true;
            for (let r = 0; r < matrix.length; r++) {
                let sum = 0;
                for (let c = 0; c < termsCount; c++) {
                    sum += matrix[r][c] * coeffs[c];
                }
                if (sum !== 0) {
                    valid = false;
                    break;
                }
            }
            if (valid) return coeffs;

            let i = 0;
            while (i < termsCount) {
                coeffs[i]++;
                if (coeffs[i] <= maxCoeff) break;
                coeffs[i] = 1;
                i++;
            }
            if (i === termsCount) return null;
        }
    }

    function formatBalancedSide(compounds, coeffs, offset) {
        return compounds.map((cmp, idx) => {
            const coeff = coeffs[offset + idx];
            return `${coeff > 1 ? coeff : ''}${cmp.formula}`;
        }).join(' + ');
    }

    function autoBalanceRuleEquation(equation) {
        if (!equation || /\n/.test(equation)) return equation;
        const parts = String(equation).split(/→|->|=/);
        if (parts.length !== 2) return equation;
        const reactants = parts[0].split('+').map(parseEquationCompound).filter((x) => x.formula);
        const products = parts[1].split('+').map(parseEquationCompound).filter((x) => x.formula);
        const termsCount = reactants.length + products.length;
        if (!reactants.length || !products.length || termsCount > 6) return equation;

        const matrix = buildBalanceMatrix(reactants, products);
        if (!matrix) return equation;
        const coeffs = solveCoefficientsBruteforce(matrix, termsCount);
        if (!coeffs) return equation;

        const left = formatBalancedSide(reactants, coeffs, 0);
        const right = formatBalancedSide(products, coeffs, reactants.length);
        return `${left} → ${right}`;
    }

    function isGasProductFormula(formula) {
        const clean = stripPhaseMarkers(String(formula || ''));
        const gasSet = new Set([
            'H2', 'O2', 'N2', 'Cl2', 'Br2', 'I2', 'F2',
            'CO2', 'CO', 'SO2', 'SO3', 'NO', 'NO2', 'N2O',
            'NH3', 'H2S', 'PH3', 'CH4', 'C2H2',
            'HCl', 'HBr', 'HI', 'HNO3'
        ]);
        return gasSet.has(clean);
    }

    function isPrecipitateFormula(formula) {
        const clean = stripPhaseMarkers(String(formula || ''));
        const knownPrecipitates = new Set([
            'AgCl', 'AgBr', 'AgI', 'BaSO4', 'PbSO4',
            'CaCO3', 'MgCO3', 'BaCO3',
            'Cu(OH)2', 'Fe(OH)2', 'Fe(OH)3', 'Al(OH)3', 'Zn(OH)2', 'Mg(OH)2',
            'H2SiO3', 'S'
        ]);
        if (knownPrecipitates.has(clean)) return true;

        const salt = detectSalt(clean);
        if (salt) {
            const sol = getSolubility(salt.cationFormula, salt.cationCharge, salt.anionFormula, salt.anionCharge);
            if (isInsoluble(sol)) return true;
        }

        const base = parseBase(clean);
        if (base) {
            const cationCharge = base.ohCount || getIonCharge(base.cationFormula, 'cation', 'min');
            const sol = getSolubility(base.cationFormula, cationCharge, 'OH', -1);
            if (isInsoluble(sol)) return true;
        }

        return false;
    }

    function annotateProductPhases(equation) {
        if (!equation || /\n/.test(equation)) return equation;
        const text = String(equation);
        const arrowMatch = text.match(/(→|->|=|⇌)/);
        if (!arrowMatch) return equation;
        const arrow = arrowMatch[1];
        const parts = text.split(/→|->|=|⇌/);
        if (parts.length !== 2) return equation;
        const left = parts[0].trim();
        const productTerms = parts[1]
            .split('+')
            .map((x) => x.trim())
            .filter(Boolean)
            .map((term) => {
                const m = term.match(/^(\d+)\s*(.+)$/);
                const coeff = m ? `${m[1]}` : '';
                const formulaRaw = m ? m[2].trim() : term;
                const formula = stripPhaseMarkers(formulaRaw);
                if (/[⁰¹²³⁴⁵⁶⁷⁸⁹⁺⁻]/.test(formula)) return `${coeff}${formulaRaw}`;
                if (isGasProductFormula(formula)) return `${coeff}${formula}↑`;
                if (isPrecipitateFormula(formula)) return `${coeff}${formula}↓`;
                return `${coeff}${formula}`;
            });
        return `${left} ${arrow} ${productTerms.join(' + ')}`;
    }

    function isEquationBalanced(equation) {
        if (!equation || /\n/.test(equation)) return false;
        const parts = String(equation).split(/→|->|=|⇌/);
        if (parts.length !== 2) return false;
        const reactants = parts[0].split('+').map((x) => String(x).trim()).filter(Boolean);
        const products = parts[1].split('+').map((x) => String(x).trim()).filter(Boolean);
        if (!reactants.length || !products.length) return false;
        const left = {};
        const right = {};
        const addCounts = (acc, formula, coeff) => {
            const counts = parseFormulaCounts(stripPhaseMarkers(formula));
            Object.keys(counts).forEach((el) => {
                acc[el] = (acc[el] || 0) + counts[el] * coeff;
            });
        };
        reactants.forEach((term) => {
            const m = String(term).match(/^(\d+)\s*(.+)$/);
            const coeff = m ? parseInt(m[1], 10) : 1;
            const f = m ? m[2] : term;
            addCounts(left, f, coeff);
        });
        products.forEach((term) => {
            const m = String(term).match(/^(\d+)\s*(.+)$/);
            const coeff = m ? parseInt(m[1], 10) : 1;
            const f = m ? m[2] : term;
            addCounts(right, f, coeff);
        });
        const elements = new Set([...Object.keys(left), ...Object.keys(right)]);
        for (const el of elements) {
            if ((left[el] || 0) !== (right[el] || 0)) return false;
        }
        return true;
    }

    function postProcessRuleEquation(equation, ruleId) {
        const balanced = autoBalanceRuleEquation(equation);
        return annotateProductPhases(balanced);
    }

    function applyRules(tokens, rawTokens) {
        const handlers = [
            { id: 'R00', fn: ruleSpecialCombination, status: 'Подставлено по специальному шаблону реакции.' },
            { id: 'R83', fn: (t, r) => rulePassivation(t, r), status: 'Реакция не идёт (пассивация).' },
            { id: 'R84', fn: (t, r) => ruleSnPbHNO3(t, r), status: 'Подставлено по правилам химии Sn/Pb с HNO3.' },
            { id: 'R82', fn: (t, r) => ruleExtendedComplexes(t, r), status: 'Подставлено по правилу комплексообразования/разрушения комплексов.' },
            { id: 'R81', fn: (t, r) => ruleSiliconExtended(t, r), status: 'Подставлено по специальному правилу химии кремния.' },
            { id: 'R80', fn: (t, r) => ruleDecompositionNitratesExtended(t, r), status: 'Подставлено по правилу разложения нитратов.' },
            { id: 'R78', fn: (t, r) => ruleIodineStarch(t, r), status: 'Подставлено по качественной реакции I2 с крахмалом.' },
            { id: 'R77', fn: (t, r) => ruleSulfidesSpecific(t, r), status: 'Подставлено по специальному правилу химии сульфидов.' },
            { id: 'R76', fn: (t, r) => rulePhosphorusSpecific(t, r), status: 'Подставлено по специальному правилу химии фосфора.' },
            { id: 'R75', fn: (t, r) => ruleCarbonSpecific(t, r), status: 'Подставлено по специальному правилу химии углерода.' },
            { id: 'R74', fn: (t, r) => ruleHalogenLabPreparation(t, r), status: 'Подставлено по лабораторному способу получения хлора.' },
            { id: 'R73', fn: (t, r) => ruleAmmoniaReducing(t, r), status: 'Подставлено по правилу восстановительных свойств аммиака.' },
            { id: 'R72', fn: (t, r) => ruleComplexQualitative(t, r), status: 'Подставлено по правилу качественных/комплексных реакций.' },
            { id: 'R71', fn: (t, r) => ruleAmphotericSaltExcessAlkali(t, r), status: 'Подставлено по правилу растворения амфотерного гидроксида в избытке щёлочи.' },
            { id: 'R68', fn: (t, r) => ruleSiliconSpecific(t, r), status: 'Подставлено по специальному правилу химии кремния.' },
            { id: 'R67', fn: (t, r) => ruleAmmoniumDecomposition(t, r), status: 'Подставлено по правилу разложения солей аммония.' },
            { id: 'R66', fn: (t, r) => ruleReductionByHydrogen(t, r), status: 'Подставлено по правилу восстановления оксидов водородом.' },
            { id: 'R65', fn: (t, r) => ruleMetalNonmetalSynthesis(t, r), status: 'Подставлено по правилу: металл + неметалл.' },
            { id: 'R64', fn: (t, r) => ruleNonmetalNonmetalSynthesis(t, r), status: 'Подставлено по правилу: неметалл + неметалл.' },
            { id: 'R63', fn: (t, r) => ruleFe2ToFe3Oxidation(t, r), status: 'Подставлено по правилу окисления Fe²⁺ до Fe³⁺.' },
            { id: 'R62', fn: (t, r) => ruleLimewaterCO2(t, r), status: 'Подставлено по качественной реакции с CO2 и Ca(OH)2.' },
            { id: 'R61', fn: (t, r) => ruleLabAcidGeneration(t, r), status: 'Подставлено по лабораторному способу получения летучих кислот.' },
            { id: 'R59', fn: (t, r) => ruleReductionByCarbon(t, r), status: 'Подставлено по правилу восстановления углеродом.' },
            { id: 'R58', fn: (t, r) => ruleReductionByCO(t, r), status: 'Подставлено по правилу восстановления CO.' },
            { id: 'R57', fn: (t, r) => ruleThermalOxidizerDecomposition(t, r), status: 'Подставлено по правилу термолиза окислителей.' },
            { id: 'R56', fn: ruleHalogenWater, status: 'Подставлено по правилу взаимодействия галогена с водой.' },
            { id: 'R55', fn: ruleNO2Alkali, status: 'Подставлено по правилу NO2 + щёлочь (диспропорционирование).' },
            { id: 'R53', fn: ruleCarbidesNitridesPhosphidesHydrolysis, status: 'Подставлено по правилу гидролиза карбидов/нитридов/фосфидов.' },
            { id: 'R52', fn: (t, r) => ruleHydrogenPeroxide(t, r), status: 'Подставлено по правилу диспропорционирования H2O2.' },
            { id: 'R51', fn: ruleQualitativeRedox, status: 'Подставлено по качественной ОВР-реакции.' },
            { id: 'R50', fn: ruleAmmoniaWithAcids, status: 'Подставлено по правилу: NH3 + кислоты.' },
            { id: 'R49', fn: ruleHalogenHalideAq, status: 'Подставлено по правилу вытеснения галогенов из галогенидов.' },
            { id: 'R48', fn: (t, r) => ruleSOxOxidation(t, r), status: 'Подставлено по правилу превращений SO2/SO3.' },
            { id: 'R47', fn: (t, r) => ruleAmmoniaAndNOx(t, r), status: 'Подставлено по правилу NH3/NOx.' },
            { id: 'R45', fn: (t, r) => ruleComplexFormation(t, r), status: 'Подставлено по правилу комплексообразования.' },
            { id: 'R44', fn: rulePeroxideSuperoxide, status: 'Подставлено по правилу для пероксидов/супероксидов.' },
            { id: 'R43', fn: (t, r) => ruleThermite(t, r), status: 'Подставлено по правилу металлотермии.' },
            { id: 'R42', fn: (t, r) => ruleConcH2SO4WithHalogenHydrides(t, r), status: 'Подставлено по правилу: конц. H2SO4 + HBr/HI.' },
            { id: 'R41', fn: (t, r) => ruleHalogenAlkaliDisproportionation(t, r), status: 'Подставлено по правилу диспропорционирования галогенов.' },
            { id: 'R40', fn: (t, r) => ruleMetalSteam(t, r), status: 'Подставлено по правилу: металл + водяной пар.' },
            { id: 'R39', fn: (t, r) => ruleAmphotericInAlkali(t, r), status: 'Подставлено по правилу амфотерных соединений в щёлочи.' },
            { id: 'R79', fn: (t, r) => ruleChromiumAmphoteric(t, r), status: 'Подставлено по правилу амфотерности и окисления соединений Cr(III) в щёлочи.' },
            { id: 'R30', fn: (t, r) => ruleElectrolysis(t, r), status: 'Подставлено по правилу электролиза.' },
            { id: 'R31', fn: (t, r) => ruleElectrolysis(t, r), status: 'Подставлено по правилу электролиза.' },
            { id: 'R32', fn: ruleDehydration, status: 'Подставлено по правилу водоотнимающих реакций.' },
            { id: 'R33', fn: ruleAquaRegia, status: 'Подставлено по правилу царской водки.' },
            { id: 'R34', fn: ruleSilicicAcid, status: 'Подставлено по правилу получения кремниевой кислоты.' },
            { id: 'R35', fn: ruleUnstableAcids, status: 'Подставлено по правилу разложения нестойких кислот.' },
            { id: 'R36', fn: ruleKMnO4, status: 'Подставлено по правилу ОВР с KMnO4 (кислая/нейтр. среда).' },
            { id: 'R37', fn: ruleK2Cr2O7FeSO4, status: 'Подставлено по правилу для K2Cr2O7 + FeSO4.' },
            { id: 'R38', fn: (t, r) => ruleK2Cr2O7(t, r), status: 'Подставлено по правилу ОВР с K2Cr2O7/CrO4²⁻.' },
            { id: 'R20', fn: (t, r) => ruleDecompositionNitrates(t, r), status: 'Подставлено по правилу разложения нитратов.' },
            { id: 'R21', fn: (t, r) => ruleDecompositionCarbonates(t, r), status: 'Подставлено по правилу разложения карбонатов.' },
            { id: 'R22', fn: (t, r) => ruleDecompositionHydroxides(t, r), status: 'Подставлено по правилу разложения гидроксидов.' },
            { id: 'R23', fn: ruleHydrolysis, status: 'Подставлено по правилу гидролиза.' },
            { id: 'R26', fn: ruleAcidSaltBase, status: 'Подставлено по правилу: кислая соль + щёлочь.' },
            { id: 'R27', fn: ruleSaltAcidSalt, status: 'Подставлено по правилу: средняя соль + кислота.' },
            { id: 'R14', fn: ruleNeutralization, status: 'Подставлено по правилу нейтрализации.' },
            { id: 'R11', fn: ruleBasicOxideWater, status: 'Подставлено по правилу образования щёлочи.' },
            { id: 'R13', fn: ruleAcidicOxideWater, status: 'Подставлено по правилу образования кислоты.' },
            { id: 'R10', fn: ruleBasicOxideAcid, status: 'Подставлено по правилу: оксид + кислота.' },
            { id: 'R12', fn: (t, r) => ruleAcidicOxideBase(t, r), status: 'Подставлено по правилу: кислотный оксид + щёлочь.' },
            { id: 'R09', fn: ruleBasicOxideAcidicOxide, status: 'Подставлено по правилу: оксид + оксид.' },
            { id: 'R15', fn: ruleAmphotericAcid, status: 'Подставлено по правилу: амфотерное + кислота.' },
            { id: 'R16', fn: (t, r) => ruleAmphotericBase(t, r), status: 'Подставлено по правилу: амфотерное + щёлочь.' },
            { id: 'R17', fn: (t, r) => ruleAmphotericFusion(t, r), status: 'Подставлено по правилу: амфотерное + щёлочь (сплавление).' },
            { id: 'R18', fn: ruleMetalWater, status: 'Подставлено по правилу: металл + вода.' },
            { id: 'R19', fn: ruleMetalOxygen, status: 'Подставлено по правилу: металл + O2.' },
            { id: 'R25', fn: (t, r) => ruleNonmetalOxygen(t, r), status: 'Подставлено по правилу: неметалл + O2.' },
            { id: 'R99', fn: ruleSpecialCombination, status: 'Подставлено по специальному правилу соединения/горения.' },
            { id: 'R24', fn: ruleHalogenDisplacement, status: 'Подставлено по правилу: галогены.' },
            { id: 'R02', fn: (t, r) => ruleMetalHNO3(t, r), status: 'Подставлено по правилу: металл + HNO3 (\u0440\u0430\u0437\u0431.).' },
            { id: 'R03', fn: (t, r) => ruleMetalHNO3(t, r), status: 'Подставлено по правилу: металл + HNO3 (\u043a\u043e\u043d\u0446.).' },
            { id: 'R04', fn: (t, r) => ruleMetalH2SO4Conc(t, r), status: 'Подставлено по правилу: металл + H2SO4 (\u043a\u043e\u043d\u0446.).' },
            { id: 'R01', fn: (t, r) => ruleMetalAcid(t, r), status: 'Подставлено по правилу: металл + кислота.' },
            { id: 'R05', fn: ruleSaltAcid, status: 'Подставлено по правилу: соль + кислота.' },
            { id: 'R06', fn: ruleSaltBase, status: 'Подставлено по правилу: соль + щёлочь.' },
            { id: 'R07', fn: ruleSaltSalt, status: 'Подставлено по правилу: соль + соль.' },
            { id: 'R08', fn: ruleMetalSalt, status: 'Подставлено по правилу: металл + соль.' }
        ];

        for (const handler of handlers) {
            const result = handler.fn(tokens, rawTokens);
            if (result) {
                const processedEquation = postProcessRuleEquation(result, handler.id);
                // ALLOW non-balanced strings if they contain "↛" or "(пассивация)" or are ionic
                const isNoRx = processedEquation.includes('\u21cf') || processedEquation.includes('нет реакции');
                if (!isNoRx && !isEquationBalanced(processedEquation) && !/[⁰¹²³⁴⁵⁶⁷⁸⁹⁺⁻]/.test(processedEquation)) {
                    continue;
                }
                return {
                    equation: processedEquation,
                    status: handler.status,
                    tags: REACTION_CATEGORIES[handler.id] || []
                };
            }
        }

        return null;
    }

    function normalizeRawInput(raw) {
        return normalizeDigits(String(raw || '')).replace(/\s+/g, '');
    }

    function splitAlternatives(str) {
        return str.split('/').map((s) => s.trim()).filter(Boolean);
    }

    function patternMatchesInput(pattern, rawInput) {
        if (!pattern) return false;
        const raw = normalizeRawInput(rawInput);
        const parts = pattern.split('+').map((s) => s.trim()).filter(Boolean);
        if (!parts.length) return false;
        return parts.every((part) => {
            const variants = splitAlternatives(part);
            return variants.some((v) => raw.includes(normalizeRawInput(v)));
        });
    }

    function detectCandidateRule(tokens, rawInput) {
        if (tokens.length !== 2) return null;
        const a = normalizeToken(tokens[0], { stripConditions: true });
        const b = normalizeToken(tokens[1], { stripConditions: true });
        const acidA = parseAcid(a);
        const acidB = parseAcid(b);
        const metalA = classifyFormula(a).kind === 'metal';
        const metalB = classifyFormula(b).kind === 'metal';
        const acid = acidA ? a : (acidB ? b : null);
        const metal = metalA ? a : (metalB ? b : null);
        const saltA = isSaltLikeFormula(a);
        const saltB = isSaltLikeFormula(b);
        const baseA = parseBase(a);
        const baseB = parseBase(b);
        if (saltA && acidB || saltB && acidA) return 'R05';
        if (saltA && baseB || saltB && baseA) return 'R06';
        if (saltA && saltB) return 'R07';
        if ((metalA && saltB) || (metalB && saltA)) return 'R08';
        if (!acid || !metal) return null;

        if (/HNO3/i.test(acid)) {
            if (/конц/i.test(rawInput)) return 'R03';
            return 'R02';
        }
        if (/H2SO4/i.test(acid) && /конц/i.test(rawInput)) {
            return 'R04';
        }
        return 'R01';
    }

    function detectNoReaction(tokens, rawInput) {
        if (!dataMaps) return null;
        const candidateRule = detectCandidateRule(tokens, rawInput);

        if (Array.isArray(window.REACTIONS_DB?.rule_exceptions)) {
            for (const ex of window.REACTIONS_DB.rule_exceptions) {
                if (ex.rule_id && (!candidateRule || ex.rule_id !== candidateRule)) continue;
                if (ex.forbidden_pattern && patternMatchesInput(ex.forbidden_pattern, rawInput)) {
                    return { reason: ex.reason || ex.description || 'Реакция не идёт' };
                }
                if (Array.isArray(ex.forbidden_substances)) {
                    const normTokens = tokens.map((t) => normalizeToken(t, { stripConditions: true }));
                    const hit = ex.forbidden_substances.some((s) => normTokens.includes(normalizeToken(s, { stripConditions: true })));
                    if (hit) {
                        return { reason: ex.reason || ex.description || 'Реакция не идёт' };
                    }
                }
            }
        }

        // Passivation in concentrated oxidizing acids (cold)
        if (tokens.length === 2) {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const metal = classifyFormula(a).kind === 'metal' ? a : (classifyFormula(b).kind === 'metal' ? b : null);
            const acid = parseAcid(a) ? a : (parseAcid(b) ? b : null);
            if (metal && acid && ['Fe', 'Al', 'Cr'].includes(metal) && hasKeyword(rawInput, ['холод'])) {
                if (/HNO3/i.test(acid) && hasKeyword(rawInput, ['конц'])) {
                    return { reason: 'Пассивирование Fe/Al/Cr в холодной концентрированной HNO3.' };
                }
                if (/H2SO4/i.test(acid) && hasKeyword(rawInput, ['конц'])) {
                    return { reason: 'Пассивирование Fe/Al/Cr в холодной концентрированной H2SO4.' };
                }
            }
        }

        // Generic: metal after H with non-oxidizing acid
        if (candidateRule === 'R01') {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const acid = parseAcid(a) ? a : (parseAcid(b) ? b : null);
            const metal = classifyFormula(a).kind === 'metal' ? a : (classifyFormula(b).kind === 'metal' ? b : null);
            if (acid && metal) {
                const metalRank = dataMaps.activityMap.get(metal);
                const hRank = dataMaps.activityMap.get('H');
                const acidInfo = dataMaps.classMap.get(acid)?.info;
                if (metalRank && hRank && metalRank > hRank && !(acidInfo && acidInfo.is_oxidizer)) {
                    return { reason: 'Металл стоит после H в ряду активности — не вытесняет H2 из кислот' };
                }
            }
        }

        // Basic oxide + water that does not react (weak/insoluble hydroxide)
        if (tokens.length === 2) {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const tryPair = (oxideStr, waterStr) => {
                if (classifyFormula(oxideStr).kind !== 'oxide') return null;
                if (classifyFormula(waterStr).kind !== 'water') return null;
                const oxideInfo = dataMaps.metalOxideMap.get(oxideStr);
                if (!oxideInfo || !oxideInfo.hydroxide) return { reason: 'Оксид не реагирует с водой.' };
                const hydroxideClass = dataMaps.classMap.get(oxideInfo.hydroxide);
                const subclass = hydroxideClass?.subclass || '';
                if (!/strong/i.test(String(subclass))) {
                    return { reason: 'Основный оксид не реагирует с водой (основание слабое/нерастворимое).' };
                }
                return null;
            };
            const res = tryPair(a, b) || tryPair(b, a);
            if (res) return res;
        }

        // Acidic oxide + water that does not react (SiO2)
        if (tokens.length === 2) {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const tryPair = (oxideStr, waterStr) => {
                if (classifyFormula(oxideStr).kind !== 'oxide') return null;
                if (classifyFormula(waterStr).kind !== 'water') return null;
                if (oxideStr === 'SiO2') {
                    return { reason: 'Образующаяся H2SiO3 нерастворима — реакция в воде не идёт.' };
                }
                return null;
            };
            const res = tryPair(a, b) || tryPair(b, a);
            if (res) return res;
        }

        // Acidic oxide + weak/insoluble base does not react (needs strong alkali)
        if (tokens.length === 2) {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const tryPair = (oxideStr, baseStr) => {
                const info = classifyFormula(oxideStr);
                if (info.kind !== 'oxide') return null;
                if (!parseBase(baseStr)) return null;
                const baseClass = dataMaps.classMap.get(baseStr);
                const baseSubclass = baseClass?.subclass || '';
                if (/strong/i.test(String(baseSubclass))) return null;
                return { reason: 'Кислотный оксид реагирует только со щёлочами (сильными основаниями).' };
            };
            const res = tryPair(a, b) || tryPair(b, a);
            if (res) return res;
        }

        // Weak acid + weak basic oxide -> no reaction
        if (tokens.length === 2) {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const tryPair = (acidStr, oxideStr) => {
                if (!parseAcid(acidStr)) return null;
                const oxideInfo = classifyFormula(oxideStr);
                if (oxideInfo.kind !== 'oxide') return null;
                const acidClass = dataMaps.classMap.get(acidStr);
                const acidSubclass = String(acidClass?.subclass || '');
                if (!/weak/i.test(acidSubclass)) return null;
                if (!/basic/i.test(String(oxideInfo.subclass || ''))) return null;
                const oxidePair = dataMaps.metalOxideMap.get(oxideStr);
                const hydroxide = oxidePair?.hydroxide;
                const hydroxideClass = hydroxide ? dataMaps.classMap.get(hydroxide) : null;
                const hydroxideSubclass = String(hydroxideClass?.subclass || '');
                if (/strong/i.test(hydroxideSubclass)) return null;
                return { reason: 'Слабая кислота и слабый основный оксид не реагируют.' };
            };
            const res = tryPair(a, b) || tryPair(b, a);
            if (res) return res;
        }

        // Salt + acid/base/salt: no driving force
        if (tokens.length === 2) {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const saltA = detectSalt(a);
            const saltB = detectSalt(b);
            const acidA = parseAcid(a);
            const acidB = parseAcid(b);
            const baseA = parseBase(a);
            const baseB = parseBase(b);

            if ((saltA && acidB) || (saltB && acidA)) {
                const salt = saltA || saltB;
                const acid = acidB ? b : a;
                const acidParsed = parseAcid(acid);
                const newSaltSol = getSolubility(salt.cationFormula, salt.cationCharge, acidParsed.anionFormula, getIonCharge(acidParsed.anionFormula, 'anion', 'min'));
                const newAcid = buildAcidFormula(salt.anionFormula, salt.anionCharge);
                if (!isInsoluble(newSaltSol) && !isWeakAcid(newAcid) && !isGasProduct(newAcid)) {
                    return { reason: 'Нет осадка/газа/слабого электролита — реакция обмена не идёт.' };
                }
            }

            if ((saltA && baseB) || (saltB && baseA)) {
                const salt = saltA || saltB;
                const base = baseB ? b : a;
                const baseParsed = parseBase(base);
                const newSaltSol = getSolubility(baseParsed.cationFormula, getIonCharge(baseParsed.cationFormula, 'cation', 'min'), salt.anionFormula, salt.anionCharge);
                const newBase = buildSaltFormula(salt.cationFormula, salt.cationCharge, 'OH', -1);
                if (!isInsoluble(newSaltSol) && !isWeakBase(newBase) && newBase !== 'NH4OH') {
                    return { reason: 'Нет осадка/газа/слабого электролита — реакция обмена не идёт.' };
                }
            }

            if (saltA && saltB) {
                const sol1 = getSolubility(saltA.cationFormula, saltA.cationCharge, saltB.anionFormula, saltB.anionCharge);
                const sol2 = getSolubility(saltB.cationFormula, saltB.cationCharge, saltA.anionFormula, saltA.anionCharge);
                if (!isInsoluble(sol1) && !isInsoluble(sol2)) {
                    return { reason: 'Осадок/газ/слабый электролит не образуются — реакция не идёт.' };
                }
            }
        }

        // Metal + salt: metal not active enough
        if (tokens.length === 2) {
            const a = normalizeToken(tokens[0], { stripConditions: true });
            const b = normalizeToken(tokens[1], { stripConditions: true });
            const metal = classifyFormula(a).kind === 'metal' ? a : (classifyFormula(b).kind === 'metal' ? b : null);
            const salt = isSaltLikeFormula(a) ? a : (isSaltLikeFormula(b) ? b : null);
            if (metal && salt) {
                const saltInfo = detectSalt(salt);
                const metalRank = dataMaps.activityMap.get(metal);
                const saltMetalRank = dataMaps.activityMap.get(saltInfo.cationFormula);
                if (metalRank && saltMetalRank && metalRank >= saltMetalRank) {
                    return { reason: 'Металл менее активен, чем металл в соли — вытеснение не идёт.' };
                }
            }
        }

        return null;
    }

    function parseExampleReactants(exampleStr) {
        if (!exampleStr) return [];
        const left = exampleStr.split(/\u2192|->|=|⇌/)[0] || '';
        return left
            .split('+')
            .map((t) => normalizeToken(t, { stripConditions: true }))
            .filter(Boolean);
    }

    function ruleHintFromExamples(tokens) {
        if (!ruleMap) return null;
        const normalized = tokens
            .map((t) => normalizeToken(t, { stripConditions: true }))
            .filter(Boolean);
        if (!normalized.length) return null;

        for (const rule of ruleMap.values()) {
            if (!Array.isArray(rule.examples)) continue;
            for (const example of rule.examples) {
                const exTokens = parseExampleReactants(example);
                if (!exTokens.length) continue;
                const exSet = new Set(exTokens);
                const allMatch = normalized.every((tok) => exSet.has(tok));
                if (allMatch) {
                    const hint = `По правилу ${rule.rule_id}: ${rule.products_pattern}\nПример: ${example}`;
                    return { equation: hint, status: `Подсказка по правилу ${rule.rule_id}.` };
                }
            }
        }
        return null;
    }

    async function loadReactionsDB() {
        if (window.REACTIONS_DB && window.REACTIONS_DB.reaction_examples) {
            reactionsIndex = buildIndex(window.REACTIONS_DB.reaction_examples || []);
            ionMaps = buildIonMaps(window.REACTIONS_DB);
            dataMaps = buildDataMaps(window.REACTIONS_DB);
            ruleMap = new Map((window.REACTIONS_DB.reaction_rules || []).map((r) => [r.rule_id, r]));
            dbLoaded = true;
            dbError = null;
            return;
        }

        try {
            const res = await fetch(DB_URL, { cache: 'force-cache' });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const examples = data.reaction_examples || [];
            reactionsIndex = buildIndex(examples);
            ionMaps = buildIonMaps(data);
            dataMaps = buildDataMaps(data);
            ruleMap = new Map((data.reaction_rules || []).map((r) => [r.rule_id, r]));
            if (!window.REACTIONS_DB) {
                window.REACTIONS_DB = data;
            }
            dbLoaded = true;
        } catch (err) {
            if (window.REACTIONS_DB && window.REACTIONS_DB.reaction_examples) {
                reactionsIndex = buildIndex(window.REACTIONS_DB.reaction_examples || []);
                ionMaps = buildIonMaps(window.REACTIONS_DB);
                dataMaps = buildDataMaps(window.REACTIONS_DB);
                ruleMap = new Map((window.REACTIONS_DB.reaction_rules || []).map((r) => [r.rule_id, r]));
                dbLoaded = true;
                dbError = null;
                return;
            }
            dbError = err;
            dbLoaded = false;
        }
    }

    function findMatches(tokens) {
        if (!reactionsIndex) return [];
        const strictKey = buildKey(tokens, { stripConditions: false });
        let matches = strictKey ? (reactionsIndex.strict.get(strictKey) || []) : [];
        if (matches.length > 0) return matches;

        const relaxedKey = buildKey(tokens, { stripConditions: true });
        matches = relaxedKey ? (reactionsIndex.relaxed.get(relaxedKey) || []) : [];
        return matches;
    }

    function findSuggestions(tokens) {
        if (!reactionsIndex || tokens.length === 0) return [];
        const relaxedTokens = tokens
            .map((t) => normalizeToken(t, { stripConditions: true }))
            .filter(Boolean);
        if (relaxedTokens.length === 0) return [];
        const tokenSet = new Set(relaxedTokens);
        const suggestions = [];

        for (const entry of reactionsIndex.entries) {
            const entrySet = new Set(entry.relaxedTokens);
            let allMatch = true;
            for (const tok of tokenSet) {
                if (!entrySet.has(tok)) {
                    allMatch = false;
                    break;
                }
            }
            if (allMatch) {
                suggestions.push(entry.example);
                if (suggestions.length >= MAX_SUGGESTIONS) break;
            }
        }
        return suggestions;
    }

    function formatExampleEquation(example) {
        if (!example) return '';
        if (example.equation) return String(example.equation);
        if (example.reactants && example.products) {
            return `${example.reactants} → ${example.products}`;
        }
        return '';
    }

    function isCorruptedDbText(text) {
        const t = String(text || '');
        if (!t) return false;
        if (/\?{2,}/.test(t)) return true;
        if (/\s\?\s/.test(t)) return true;
        if (/[A-Za-zА-Яа-я0-9\])]\?(?=\s|$|\+|\))/u.test(t)) return true;
        return false;
    }

    function pickBestExampleMatch(matches) {
        for (const example of (matches || [])) {
            const equation = formatExampleEquation(example);
            if (!equation) continue;
            if (isCorruptedDbText(equation)) continue;
            return { example, equation };
        }
        return null;
    }

    function appendFusionVariantIfRelevant(equation, statusText, tokens, rawInput) {
        const raw = rawInput || '';
        if (!equation) return { equation: '', status: statusText || '' };
        if (hasConditionHint(raw)) return { equation, status: statusText };
        if (hasKeyword(equation, ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv'])) {
            return { equation, status: statusText };
        }

        const fusionVariantRaw = ruleAmphotericFusion(tokens, 'расплав');
        if (!fusionVariantRaw) return { equation, status: statusText };

        const fusionVariant = postProcessRuleEquation(fusionVariantRaw, 'R17');
        if (!fusionVariant || fusionVariant === equation) {
            return { equation, status: statusText };
        }

        const mergedEquation = `${equation}\n(расплав): ${fusionVariant}`;
        const mergedStatus = statusText
            ? `${statusText} Добавлен вариант для расплава.`
            : 'Подставлено по правилу. Добавлен вариант для расплава.';
        return { equation: mergedEquation, status: mergedStatus };
    }

    function renderOutput(outputEl, statusEl, tagsEl, tokens, rawInput) {
        if (!outputEl) return;

        const updateTags = (tags) => {
            if (!tagsEl) return;
            tagsEl.innerHTML = '';
            if (!tags || !tags.length) return;

            tags.forEach(tag => {
                const label = TAG_LABELS[tag] || tag;
                const span = document.createElement('span');
                span.className = `reaction-tag tag-${tag}`;
                span.textContent = label;
                tagsEl.appendChild(span);
            });
        };

        if (!tokens.length) {
            outputEl.value = '';
            if (statusEl) {
                statusEl.textContent = 'Введите реагенты — продукты подставятся автоматически.';
            }
            updateTags([]);
            return;
        }
        if (dbError) {
            outputEl.value = 'Не удалось загрузить базу реакций.';
            if (statusEl) {
                statusEl.textContent = 'Ошибка загрузки базы реакций.';
            }
            return;
        }
        if (!dbLoaded) {
            outputEl.value = 'База реакций загружается...';
            if (statusEl) {
                statusEl.textContent = 'База реакций загружается...';
            }
            return;
        }

        if (hasKeyword(rawInput || '', ['элект', 'электролиз', 'electrolysis', 'electro'])) {
            const electroRuleHit = applyRules(tokens, rawInput || '');
            if (electroRuleHit) {
                outputEl.value = electroRuleHit.equation;
                if (statusEl) {
                    statusEl.textContent = electroRuleHit.status || 'Подставлено по правилу.';
                }
                updateTags(electroRuleHit.tags);
                return;
            }
        }

        if (hasKeyword(rawInput || '', ['сплав', 'сплавл', 'расплав', 'melt', 'molten', 'fusion', 'splav', 'spalv'])) {
            const fusionRuleHit = applyRules(tokens, rawInput || '');
            if (fusionRuleHit) {
                outputEl.value = fusionRuleHit.equation;
                if (statusEl) {
                    statusEl.textContent = fusionRuleHit.status || 'Подставлено по правилу.';
                }
                updateTags(fusionRuleHit.tags);
                return;
            }
        }

        const strictKey = buildKey(tokens, { stripConditions: false });
        const strictMatches = strictKey ? (reactionsIndex.strict.get(strictKey) || []) : [];
        const strictBest = pickBestExampleMatch(strictMatches);
        if (strictBest) {
            const bestMatch = strictBest.example;
            const statusText = bestMatch.notes && !isCorruptedDbText(bestMatch.notes)
                ? `Найдено совпадение: ${bestMatch.notes}`
                : 'Найдено точное совпадение.';
            const withFusion = appendFusionVariantIfRelevant(strictBest.equation, statusText, tokens, rawInput);
            outputEl.value = withFusion.equation;
            if (statusEl) {
                statusEl.textContent = withFusion.status;
            }
            updateTags([]);
            return;
        }

        if (hasConditionHint(rawInput || '')) {
            const conditionedRuleHit = applyRules(tokens, rawInput || '');
            if (conditionedRuleHit) {
                outputEl.value = conditionedRuleHit.equation;
                if (statusEl) {
                    statusEl.textContent = conditionedRuleHit.status || 'Подставлено по правилу.';
                }
                updateTags(conditionedRuleHit.tags);
                return;
            }
        }

        const relaxedKey = buildKey(tokens, { stripConditions: true });
        const relaxedMatches = relaxedKey ? (reactionsIndex.relaxed.get(relaxedKey) || []) : [];
        const relaxedBest = pickBestExampleMatch(relaxedMatches);
        if (relaxedBest) {
            const bestMatch = relaxedBest.example;
            const statusText = bestMatch.notes && !isCorruptedDbText(bestMatch.notes)
                ? `Найдено совпадение: ${bestMatch.notes}`
                : 'Найдено совпадение.';
            const withFusion = appendFusionVariantIfRelevant(relaxedBest.equation, statusText, tokens, rawInput);
            outputEl.value = withFusion.equation;
            if (statusEl) {
                statusEl.textContent = withFusion.status;
            }
            updateTags([]);
            return;
        }

        const ruleHit = applyRules(tokens, rawInput || '');
        if (ruleHit) {
            const withFusion = appendFusionVariantIfRelevant(ruleHit.equation, ruleHit.status || 'Подставлено по правилу.', tokens, rawInput);
            outputEl.value = withFusion.equation;
            if (statusEl) {
                statusEl.textContent = withFusion.status;
            }
            updateTags(ruleHit.tags);
            return;
        }

        const noRx = detectNoReaction(tokens, rawInput || '');
        const reactantsText = tokens.map((t) => normalizeToken(t, { stripConditions: false })).join(' + ');
        if (noRx) {
            outputEl.value = `${reactantsText} \u21cf\nПричина: ${noRx.reason}`;
            if (statusEl) {
                statusEl.textContent = 'Реакция не идёт.';
            }
            updateTags(['no_reaction']);
            return;
        }

        const suggestions = findSuggestions(tokens);
        if (suggestions.length > 0) {
            const suggestionLines = suggestions
                .map((example, idx) => `${idx + 1}. ${formatExampleEquation(example) || (example.reactants || '')}`)
                .join('\n');
            outputEl.value = `Точной реакции не найдено. Похожие примеры:\n${suggestionLines}`;
            if (statusEl) {
                statusEl.textContent = 'Показаны похожие примеры из базы реакций.';
            }
            updateTags(['suggestion']);
            return;
        }

        updateTags([]);

        outputEl.value = 'Реакция не найдена по правилам. Проверьте формулы или укажите условия (разб./конц./t°).';
        if (statusEl) {
            statusEl.textContent = 'Реакция не найдена по правилам.';
        }
    }

    function debounce(fn, ms) {
        let timer = null;
        return function (...args) {
            clearTimeout(timer);
            timer = setTimeout(() => fn.apply(this, args), ms);
        };
    }

    function initReactionsUI() {
        const inputEl = document.getElementById('reactions-input');
        const outputEl = document.getElementById('reactions-output');
        const statusEl = document.getElementById('reactions-status');
        const tagsEl = document.getElementById('reactions-tags');
        const goBtn = document.getElementById('reactions-go');
        if (!inputEl || !outputEl) return;

        const update = () => {
            const raw = inputEl.value || '';
            const tokens = splitReactants(raw);
            renderOutput(outputEl, statusEl, tagsEl, tokens, raw);
        };
        window.fillReactionInput = (text) => {
            const value = String(text || '').trim();
            if (!value) return;
            inputEl.value = value;
            update();
            inputEl.focus();
        };

        const debouncedUpdate = debounce(update, 200);
        inputEl.addEventListener('input', debouncedUpdate);
        inputEl.addEventListener('change', update);
        inputEl.addEventListener('keydown', (event) => {
            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                event.preventDefault();
                update();
            }
        });

        if (goBtn) {
            goBtn.addEventListener('click', update);
        }

        const chips = document.querySelectorAll('.reactions-chips button');
        chips.forEach((btn) => {
            btn.addEventListener('click', () => {
                const text = (btn.textContent || '').trim();
                if (text) {
                    inputEl.value = text;
                    update();
                }
            });
        });

        update();
    }

    function bootstrap() {
        initReactionsUI();
        loadReactionsDB();
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bootstrap);
    } else {
        bootstrap();
    }
})();


============================================================
ФАЙЛ: .\js\modules\search-filters.js
============================================================

// =========================================
// МОДУЛЬ: ПОИСК И ФИЛЬТРЫ
// =========================================

console.log('[SEARCH-FILTERS] Модуль загружен');
console.log('[SEARCH-FILTERS] elementsData доступен:', typeof elementsData !== 'undefined');
console.log('[SEARCH-FILTERS] searchInSolubilityTable доступен:', typeof searchInSolubilityTable !== 'undefined');

// =========================================
// ЛОГИКА ПОИСКА
// =========================================
let currentSearchTerm = '';
let defaultCategoriesHTML = '';

function isSolubilityModalOpen() {
    // Проверяем через класс на body, а не через display модалки,
    // т.к. модалка скрывается с задержкой 360ms (анимация),
    // а класс снимается сразу при закрытии
    return document.body.classList.contains('solubility-open');
}

function captureDefaultCategoriesHTML() {
    const categoriesSection = document.getElementById('categories-section');
    if (!categoriesSection) return;
    if (!defaultCategoriesHTML) {
        defaultCategoriesHTML = categoriesSection.innerHTML;
    }
}

function applyCategoryFilterFromButton(btn, event) {
    if (!btn) return;
    if (event) event.stopPropagation();
    if (isSolubilityModalOpen()) return;

    const filterType = btn.dataset.filter;
    if (!filterType) return;

    if (btn.classList.contains('active')) {
        btn.classList.remove('active');
        resetTableDisplay();
        return;
    }

    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applyCategoryFilter(filterType);
}

function attachCategoryFilterHandlers() {
    document.querySelectorAll('#categories-section .filter-btn[data-filter]').forEach(btn => {
        btn.onclick = (e) => applyCategoryFilterFromButton(btn, e);
    });
}

window.attachCategoryFilterHandlers = attachCategoryFilterHandlers;
window.applyCategoryFilterFromButton = applyCategoryFilterFromButton;

window.restoreElementFiltersSafe = function () {
    const categoriesSection = document.getElementById('categories-section');
    if (!categoriesSection) return;
    captureDefaultCategoriesHTML();
    if (!defaultCategoriesHTML) return;
    categoriesSection.innerHTML = defaultCategoriesHTML;
    document.querySelectorAll('#categories-section .filter-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.style.color = '';
    });
    attachCategoryFilterHandlers();
};

function performSearch() {
    const input = document.getElementById('element-search');
    const query = input.value.trim();

    if (query.length < 1) {
        return;
    }

    // 0. Если открыта таблица растворимости - ищем ТОЛЬКО в ней
    const isSolubilityOpen = isSolubilityModalOpen();

    if (isSolubilityOpen && typeof searchInSolubilityTable === 'function') {
        console.log('[SEARCH] Таблица растворимости открыта, ищем в ней:', query);
        searchInSolubilityTable(query);
        return;
    }

    // 1. Сначала проверяем точное совпадение по символу элемента (Приоритет!)
    // Это предотвращает переключение на таблицу растворимости для запросов типа "H", "Cl" и т.д.
    const symbolMatch = findElementBySymbol(query);
    if (symbolMatch) {
        highlightElementInTable(symbolMatch);

        // Умное закрытие панели фильтров: закрываем только если она перекрывает элемент
        checkOverlapAndCloseFilters(document.getElementById(symbolMatch));

        // Очищаем подсветку через 3 секунды
        setTimeout(() => {
            clearElementHighlight();
        }, 3000);
        return;
    }

    // 2. Затем проверяем таблицу растворимости (если не нашли элемент)
    if (typeof searchInSolubilityTable === 'function') {
        const foundInTable = searchInSolubilityTable(query);
        if (foundInTable) {
            return;
        }
    }

    // 3. Если меньше 3 символов и ничего не нашли выше - выходим
    if (query.length < 3) {
        return;
    }

    // 4. Полнотекстовый поиск по всем данным (для 3+ символов)
    currentSearchTerm = query;
    const results = searchElements(query);
    displaySearchResults(results);
}

// Поиск элемента по символу (регистронезависимый)
function findElementBySymbol(query) {
    // Проверяем, доступны ли данные элементов
    if (typeof elementsData === 'undefined') {
        console.error('[SEARCH-FILTERS] elementsData не загружен!');
        return null;
    }

    const queryUpper = query.toUpperCase();

    // Ищем точное совпадение по символу
    for (const symbol in elementsData) {
        if (symbol.toUpperCase() === queryUpper) {
            return symbol;
        }
    }

    return null;
}

// Функция умного закрытия панели фильтров
function checkOverlapAndCloseFilters(element) {
    const filtersPanel = document.getElementById('filters-panel');
    if (!filtersPanel || !filtersPanel.classList.contains('active') || !element) {
        return;
    }

    const panelRect = filtersPanel.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();

    // Проверяем пересечение прямоугольников
    const overlap = !(
        elementRect.right < panelRect.left ||
        elementRect.left > panelRect.right ||
        elementRect.bottom < panelRect.top ||
        elementRect.top > panelRect.bottom
    );

    // Закрываем только если есть пересечение
    if (overlap) {
        console.log('[SEARCH] Элемент перекрыт панелью, закрываем фильтры');
        if (!filtersPanel.classList.contains('closing')) {
            filtersPanel.classList.add('closing');
            setTimeout(() => {
                filtersPanel.classList.remove('active', 'closing');
            }, 360);
        }
    } else {
        console.log('[SEARCH] Элемент виден, панель оставляем открытой');
    }
}

// Подсветка элемента в таблице с анимацией
function highlightElementInTable(symbol) {
    console.log('Попытка подсветить элемент:', symbol);
    const elementDiv = document.getElementById(symbol);
    console.log('Найден элемент:', elementDiv);

    if (!elementDiv) {
        console.error('Элемент не найден в DOM:', symbol);
        return;
    }

    // Убираем предыдущую подсветку, если есть
    clearElementHighlight();

    // Добавляем класс подсветки
    elementDiv.classList.add('search-highlight');
    console.log('Класс search-highlight добавлен к элементу:', symbol);
    console.log('Классы элемента:', elementDiv.className);

    // Прокручиваем к элементу
    elementDiv.scrollIntoView({
        behavior: 'smooth',
        block: 'center',
        inline: 'center'
    });
}

// Очистка подсветки элемента
function clearElementHighlight() {
    const highlighted = document.querySelector('.search-highlight');
    if (highlighted) {
        highlighted.classList.remove('search-highlight');
    }
}

function searchElements(query) {
    const results = [];
    query = query.toLowerCase().trim();

    if (query.length < 3) return results;

    // Проверяем, доступны ли данные элементов
    if (typeof elementsData === 'undefined') {
        console.error('[SEARCH-FILTERS] elementsData не загружен!');
        return results;
    }

    for (const symbol in elementsData) {
        const element = elementsData[symbol];
        const matches = [];

        const searchFields = [
            { key: 'name', label: 'Название' },
            { key: 'facts', label: 'Факты' },
            { key: 'applications', label: 'Применение' },
            { key: 'nameOrigin', label: 'Происхождение названия' },
            { key: 'discoverer', label: 'Первооткрыватель' },
            { key: 'category', label: 'Категория' },
            { key: 'color', label: 'Цвет' },
            { key: 'structure', label: 'Структура' }
        ];

        searchFields.forEach(field => {
            const value = element[field.key];
            if (value && String(value).toLowerCase().includes(query)) {
                matches.push({
                    field: field.label,
                    text: String(value),
                    allotrope: null
                });
            }
        });

        if (element.allotropes) {
            for (const alloKey in element.allotropes) {
                const allo = element.allotropes[alloKey];
                searchInAllotrope(allo, query, matches, alloKey);
            }
        }

        if (element.extraAllotropes) {
            for (const alloKey in element.extraAllotropes) {
                const allo = element.extraAllotropes[alloKey];
                searchInAllotrope(allo, query, matches, alloKey);
            }
        }

        if (matches.length > 0) {
            results.push({
                symbol: symbol,
                name: element.name,
                matches: matches
            });
        }
    }

    return results;
}

function searchInAllotrope(allo, query, matches, alloKey) {
    const alloFields = ['name', 'alloFacts', 'alloDiscoverer', 'properties', 'structure', 'color'];

    alloFields.forEach(field => {
        const value = allo[field];
        if (value && String(value).toLowerCase().includes(query)) {
            matches.push({
                field: allo.name || alloKey,
                text: String(value),
                allotrope: alloKey
            });
        }
    });
}

function displaySearchResults(results) {
    const container = document.getElementById('search-results');
    container.innerHTML = '';

    if (results.length === 0) {
        container.innerHTML = '<div class="search-no-results">Ничего не найдено</div>';
        return;
    }

    results.slice(0, 10).forEach(result => {
        const item = document.createElement('div');
        item.className = 'search-result-item';

        const firstMatch = result.matches[0];
        const contextText = truncateText(firstMatch.text, 50);

        item.innerHTML = `
            <span class="result-symbol">${result.symbol}</span>
            <span class="result-name">${result.name}</span>
            <span class="result-context">${firstMatch.field}: ${contextText}</span>
        `;

        item.onclick = () => openSearchResult(result.symbol, firstMatch.allotrope);
        container.appendChild(item);
    });
}

function truncateText(text, maxLength) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
}

function openSearchResult(symbol, allotropeKey) {
    const elementDiv = document.getElementById(symbol);
    if (!elementDiv) return;

    toggleFilters();
    elementDiv.click();

    if (allotropeKey) {
        setTimeout(() => {
            const alloTab = document.querySelector(`.allotrope-tab[data-allotrope-key="${allotropeKey}"]`);
            if (alloTab) alloTab.click();
        }, 100);
    }

    setTimeout(() => {
        highlightSearchTerm(currentSearchTerm);
    }, 200);
}

function highlightSearchTerm(term) {
    if (!term || term.length < 2) return;

    const elementInfo = document.getElementById('element-info');
    if (!elementInfo) return;

    const regex = new RegExp(`(${escapeRegex(term)})`, 'gi');

    const walker = document.createTreeWalker(
        elementInfo,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );

    const textNodes = [];
    while (walker.nextNode()) {
        if (walker.currentNode.textContent.toLowerCase().includes(term.toLowerCase())) {
            textNodes.push(walker.currentNode);
        }
    }

    textNodes.forEach(node => {
        const span = document.createElement('span');
        span.innerHTML = node.textContent.replace(regex, '<mark class="highlight">$1</mark>');
        node.parentNode.replaceChild(span, node);
    });

    const firstHighlight = elementInfo.querySelector('.highlight');
    if (firstHighlight) {
        firstHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
}

function escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function clearSearch() {
    const input = document.getElementById('element-search');
    const results = document.getElementById('search-results');
    const clearBtn = document.querySelector('.search-clear');

    input.value = '';
    results.innerHTML = '';
    currentSearchTerm = '';
    if (clearBtn) clearBtn.classList.remove('visible');
    clearElementHighlight();
}

(function initSearch() {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupSearch);
    } else {
        setupSearch();
    }

    function setupSearch() {
        captureDefaultCategoriesHTML();
        attachCategoryFilterHandlers();
        const searchInput = document.getElementById('element-search');
        const clearBtn = document.querySelector('.search-clear');

        if (!searchInput) return;

        searchInput.addEventListener('input', (e) => {
            if (e.target.value.length > 0) {
                if (clearBtn) clearBtn.classList.add('visible');
            } else {
                if (clearBtn) clearBtn.classList.remove('visible');
            }
        });

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
    }
})();

// =========================================
// ЛОГИКА ФИЛЬТРОВ
// =========================================
function closeFiltersPanel(panel, animMs) {
    if (!panel || !panel.classList.contains('active')) return;
    if (panel.classList.contains('closing')) return;
    panel.classList.add('closing');

    // Check if mobile to reopen FAB
    const isMobile = window.innerWidth <= 1024;

    setTimeout(() => {
        panel.classList.remove('active', 'closing');

        // Open FAB on mobile after filters close
        if (isMobile) {
            const fab = document.getElementById('fab-container');
            if (fab) {
                fab.classList.add('active');
            }
        }
    }, animMs);
}

function toggleFilters() {
    const PANEL_ANIM_MS = 360;
    const panel = document.getElementById('filters-panel');
    const fab = document.getElementById('fab-container');

    // Закрытие панели всегда должно работать, даже если параллельно активен другой UI.
    if (panel && panel.classList.contains('active')) {
        closeFiltersPanel(panel, PANEL_ANIM_MS);
        return;
    }

    const isElementModalOpen = document.body.classList.contains('modal-open');
    const isBalancerOpen = document.body.classList.contains('balancer-active');
    const isCalcOpen = document.body.classList.contains('calc-active');
    const isReactionsOpen = document.body.classList.contains('reactions-open');
    if (isElementModalOpen || isBalancerOpen || isCalcOpen || isReactionsOpen) return;

    // Проверяем, открыта ли таблица растворимости
    const isSolubilityOpen = isSolubilityModalOpen();

    if (isSolubilityOpen) {
        // Если открыта таблица растворимости, устанавливаем фильтры для растворимости
        if (typeof updateFiltersForSolubility === 'function') {
            updateFiltersForSolubility();
        }
    } else {
        // В противном случае, восстанавливаем фильтры элементов
        if (typeof window.restoreElementFiltersSafe === 'function') {
            window.restoreElementFiltersSafe();
        } else if (typeof restoreElementFilters === 'function') {
            restoreElementFilters();
        }
    }

    if (panel) {
        panel.classList.remove('closing');
        panel.classList.add('active');
    }

    // Скрываем FAB только на мобильных устройствах
    if (window.innerWidth <= 1024 && fab && fab.classList.contains('active')) {
        fab.classList.remove('active');
    }
}

function resetFilters() {
    const searchInput = document.getElementById('element-search');
    if (searchInput) {
        searchInput.value = '';
        searchInput.dispatchEvent(new Event('input'));
    }
    const searchResults = document.getElementById('search-results');
    if (searchResults) searchResults.innerHTML = '';

    // Проверяем, открыта ли таблица растворимости
    const isSolubilityOpen = isSolubilityModalOpen();

    if (isSolubilityOpen) {
        // Если открыта таблица растворимости, сбрасываем фильтры для неё
        document.querySelectorAll('#categories-section .filter-btn').forEach(btn => {
            btn.classList.remove('active');
            // Сбрасываем стили, установленные для цветовых фильтров
            btn.style.background = '';
            btn.style.borderColor = '';
            btn.style.color = '';
        });

        // Вызываем функцию сброса для таблицы растворимости, если она доступна
        if (typeof resetSolubilityTableDisplay === 'function') {
            resetSolubilityTableDisplay();
        } else {
            // Если функция недоступна, пробуем загрузить модуль растворимости
            if (typeof loadSolubility === 'function') {
                loadSolubility().then(() => {
                    if (typeof resetSolubilityTableDisplay === 'function') {
                        resetSolubilityTableDisplay();
                    }
                });
            }
        }
    } else {
        // В противном случае, сбрасываем фильтры для обычных элементов
        document.querySelectorAll('.filter-btn.active').forEach(btn => {
            btn.classList.remove('active');
        });

        resetTableDisplay();
    }

}

// Делегирование кликов для фильтров элементов (устойчиво к замене HTML и мобилкам)
document.addEventListener('click', (event) => {
    const btn = event.target.closest('.filter-btn');
    if (!btn) return;
    // Категории обрабатываются через прямой onclick
    if (btn.dataset.filter) return;
    // Клики по категориям обрабатываются делегированным обработчиком секции
    if (btn.closest('#categories-section')) return;
    const filterType = btn.dataset.filter;
    if (!filterType) return; // игнорируем кнопки растворимости/цветов

    // Если открыта таблица растворимости — не трогаем фильтры элементов
    if (isSolubilityModalOpen()) return;

    if (btn.classList.contains('active')) {
        btn.classList.remove('active');
        resetTableDisplay();
        return;
    }

    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    applyCategoryFilter(filterType);
});

function applyCategoryFilter(categoryClass) {
    // Используем более общий селектор для всех элементов с классом element
    const allElements = document.querySelectorAll('.element');

    allElements.forEach(el => {
        if (el.classList.contains(categoryClass)) {
            el.style.opacity = '1';
            el.style.filter = 'none';
            el.style.pointerEvents = 'auto';
            el.style.transform = 'scale(1)';
        } else {
            el.style.opacity = '0.1';
            el.style.filter = 'grayscale(100%)';
            el.style.pointerEvents = 'none';
            el.style.transform = 'scale(0.9)';
        }
    });
}

function resetTableDisplay() {
    // Сбрасываем стили для всех элементов с классом element
    const allElements = document.querySelectorAll('.element');
    allElements.forEach(el => {
        el.style.opacity = '';
        el.style.filter = '';
        el.style.pointerEvents = '';
        el.style.transform = '';
    });
}


============================================================
ФАЙЛ: .\js\modules\theme-toggle.js
============================================================

// =========================================
// THEME-TOGGLE.JS — Illustrated theme switch
// =========================================

(function () {
    'use strict';

    const toggle = document.getElementById('theme-toggle');
    if (!toggle) return;

    const setState = (isDark) => {
        toggle.classList.toggle('checked', isDark);
        toggle.setAttribute('aria-checked', isDark ? 'true' : 'false');
    };

    const getCurrentTheme = () => {
        if (typeof window.__themeTarget === 'string') {
            return window.__themeTarget;
        }
        return document.body.classList.contains('dark-theme') ? 'dark' : 'light';
    };

    const getNextTheme = () => (getCurrentTheme() === 'dark' ? 'light' : 'dark');

    const handleToggle = () => {
        const nextTheme = getNextTheme();
        setState(nextTheme === 'dark');
        if (typeof toggleTheme === 'function') {
            toggleTheme();
        }
    };

    toggle.addEventListener('click', (event) => {
        if (event.button && event.button !== 0) return;
        handleToggle();
    });

    toggle.addEventListener('keydown', (event) => {
        if (event.key === ' ' || event.key === 'Enter') {
            event.preventDefault();
            handleToggle();
        }
    });

    const observer = new MutationObserver(() => {
        setState(document.body.classList.contains('dark-theme'));
    });

    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class']
    });

    setState(document.body.classList.contains('dark-theme'));
})();


============================================================
ФАЙЛ: .\js\modules\theme.js
============================================================

// =========================================
// МОДУЛЬ: ТЁМНАЯ ТЕМА
// =========================================

let currentThemeTarget = null;
window.__themeTarget = null;
let backgroundCircle = null;

function toggleTheme() {
    const btn = document.querySelector('#theme-toggle');
    const elements = document.querySelectorAll('.element');

    // Определяем куда переключаемся
    let targetTheme;
    if (currentThemeTarget !== null) {
        targetTheme = currentThemeTarget === 'dark' ? 'light' : 'dark';
    } else {
        targetTheme = document.body.classList.contains('dark-theme') ? 'light' : 'dark';
    }

    currentThemeTarget = targetTheme;
    window.__themeTarget = currentThemeTarget;
    const toLight = targetTheme === 'light';

    // Анимация кнопки
    btn.classList.remove('spin');
    void btn.offsetWidth;
    btn.classList.add('spin');
    setTimeout(() => btn.classList.remove('spin'), 400);

    // Позиция кнопки (центр волны)
    const btnRect = btn.getBoundingClientRect();
    const originX = btnRect.left + btnRect.width / 2;
    const originY = btnRect.top + btnRect.height / 2;

    if (window.startParticleWave) window.startParticleWave(originX, originY, targetTheme === 'dark');

    // Создаём круг — начинает с 0
    const circle = document.createElement('div');
    circle.className = 'theme-wave-circle';
    circle.style.left = originX + 'px';
    circle.style.top = originY + 'px';
    circle.style.width = '0px';
    circle.style.height = '0px';
    circle.style.backgroundColor = toLight ? '#f0f0f0' : '#1a1a2e';
    document.body.appendChild(circle);

    // Цвета
    const lightColors = {
        'alkali-metal': '#ff9999',
        'alkaline-earth-metal': '#ffcc99',
        'transition-metal': '#ffff99',
        'post-transition-metal': '#ccff99',
        'metalloid': '#99ffcc',
        'nonmetal': '#99ffff',
        'halogen': '#99ccff',
        'noble-gas': '#cc99ff',
        'lanthanide': '#ff99cc',
        'actinide': '#ff99ff',
        'unknown': '#cccccc'
    };

    const darkColors = {
        'alkali-metal': '#8b3a3a',
        'alkaline-earth-metal': '#8b6914',
        'transition-metal': '#7a7a2e',
        'post-transition-metal': '#4a7a2e',
        'metalloid': '#2e7a5c',
        'nonmetal': '#2e6a7a',
        'halogen': '#2e4a7a',
        'noble-gas': '#5c2e7a',
        'lanthanide': '#7a2e5c',
        'actinide': '#7a2e7a',
        'unknown': '#4a4a4a'
    };

    const waveDuration = 800;
    const targetColors = toLight ? lightColors : darkColors;
    const targetTextColor = toLight ? '#000' : '#eee';
    const targetNameColor = toLight ? '#333' : '#ccc';
    const targetBorder = toLight ? '#ccc' : '#444';

    // Максимальный диаметр — гарантированно покрывает весь экран
    const maxDiameter = 2 * Math.hypot(window.innerWidth, window.innerHeight) + 200;

    // Подготавливаем данные элементов
    const elementsData = [];
    elements.forEach(el => {
        const rect = el.getBoundingClientRect();
        const elX = rect.left + rect.width / 2;
        const elY = rect.top + rect.height / 2;
        const distance = Math.hypot(elX - originX, elY - originY);

        let category = 'unknown';
        for (const cat of Object.keys(targetColors)) {
            if (el.classList.contains(cat)) {
                category = cat;
                break;
            }
        }

        elementsData.push({ el, distance, category, switched: false });
    });

    const thisTarget = targetTheme;
    const thisCircle = circle;
    const startTime = performance.now();

    // ease-out
    function easeOut(t) {
        return 1 - Math.pow(1 - t, 2);
    }

    // Анимация — круг и элементы вместе
    function animate() {
        const elapsed = performance.now() - startTime;
        const progress = Math.min(elapsed / waveDuration, 1);
        const easedProgress = easeOut(progress);

        // Текущий диаметр и радиус
        const currentDiameter = easedProgress * maxDiameter;
        const currentRadius = currentDiameter / 2;

        // Обновляем размер круга
        thisCircle.style.width = currentDiameter + 'px';
        thisCircle.style.height = currentDiameter + 'px';

        // Обновляем элементы
        elementsData.forEach(data => {
            if (data.distance <= currentRadius && !data.switched) {
                data.switched = true;
                data.el.style.transition = 'none';
                data.el.style.backgroundColor = targetColors[data.category];
                data.el.style.borderColor = targetBorder;
                data.el.style.color = targetTextColor;

                const nameEl = data.el.querySelector('.name');
                if (nameEl) {
                    nameEl.style.color = targetNameColor;
                }
            }
        });

        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            finalize();
        }
    }

    function finalize() {
        if (currentThemeTarget !== thisTarget) {
            // Была запущена новая волна — оставляем круг, не удаляем
            return;
        }

        // Удаляем старый фоновый круг
        if (backgroundCircle) {
            backgroundCircle.remove();
        }

        // Этот круг становится фоном — устанавливаем финальный размер
        thisCircle.style.width = maxDiameter + 'px';
        thisCircle.style.height = maxDiameter + 'px';
        backgroundCircle = thisCircle;

        // Обновляем класс body
        if (toLight) {
            document.body.classList.remove('dark-theme');
        } else {
            document.body.classList.add('dark-theme');
        }

        // Добавляем небольшую задержку перед сбросом inline стилей для плавного перехода
        setTimeout(() => {
            // Очищаем inline стили элементов с плавным переходом
            elements.forEach(el => {
                // Устанавливаем плавный переход перед сбросом стилей
                el.style.transition = 'all 0.1s ease';

                // Сбрасываем inline стили, позволяя CSS-классам темы управлять цветами
                el.style.backgroundColor = '';
                el.style.borderColor = '';
                el.style.color = '';

                const nameEl = el.querySelector('.name');
                if (nameEl) {
                    nameEl.style.color = '';
                }
            });

            // Через короткое время убираем transition, чтобы не влиять на будущие изменения
            setTimeout(() => {
                elements.forEach(el => {
                    el.style.transition = '';
                });
            }, 100);
        }, 50); // Небольшая задержка для завершения CSS-переходов темы

        localStorage.setItem('theme', toLight ? 'light' : 'dark');

        // Перерисовать частицы после смены темы
        if (typeof updateParticleColors === 'function') {
            setTimeout(updateParticleColors, 100); // Небольшая задержка для завершения анимации
        }

        currentThemeTarget = null;
        window.__themeTarget = null;
    }

    requestAnimationFrame(animate);

    // Ранее частицы временно поднимались выше элементов таблицы, что вызывало проблему
    // Теперь z-index фонового круга изменен в CSS, чтобы не перекрывать частицы

    if (typeof updateNodeMapTheme === 'function') {
        updateNodeMapTheme(targetTheme === 'dark');
    }
}

// Загрузка сохранённой темы
(function loadTheme() {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark') {
        document.body.classList.add('dark-theme');

        // Создаём фоновый круг
        const circle = document.createElement('div');
        circle.className = 'theme-wave-circle';
        circle.style.left = '50%';
        circle.style.top = '50%';
        circle.style.backgroundColor = '#1a1a2e';
        circle.style.width = '400vmax';
        circle.style.height = '400vmax';
        document.body.appendChild(circle);
        backgroundCircle = circle;
    }

    // Полностью перезапустить систему частиц при начальной загрузке темы
    setTimeout(() => {
        if (typeof initParticles === 'function') {
            initParticles(); // Перезапускаем инициализацию частиц с правильной темой
        } else if (typeof updateParticleColors === 'function') {
            updateParticleColors(); // Обновляем цвета частиц
        } else if (typeof redrawParticles === 'function') {
            redrawParticles(); // Перерисовываем частицы
        }
    }, 150); // Немного увеличиваем задержку для полной установки темы
})();


============================================================
ФАЙЛ: .\js\modules\ui.js
============================================================

// =========================================
// МОДУЛЬ: UI (МЕНЮ И ПРОЧЕЕ)
// =========================================

function toggleMenu() {
    const fab = document.getElementById('fab-container');
    fab.classList.toggle('active');

    const filtersPanel = document.getElementById('filters-panel');
    if (filtersPanel && filtersPanel.classList.contains('active')) {
        if (filtersPanel.classList.contains('closing')) return;
        filtersPanel.classList.add('closing');
        setTimeout(() => {
            filtersPanel.classList.remove('active', 'closing');
        }, 360);
    }
}

let particlesEnabled = true;
function toggleParticles() {
    const canvas = document.getElementById('particles-canvas');
    particlesEnabled = !particlesEnabled;

    if (canvas) {
        canvas.style.display = particlesEnabled ? 'block' : 'none';
    }

    updateParticlesToggleUI();
}

function updateParticlesToggleUI() {
    const particlesBtn = document.querySelector('.fab-option[onclick="toggleParticles()"] .fab-btn');
    const statusBadge = document.getElementById('particles-status');

    if (particlesBtn) {
        particlesBtn.classList.toggle('active', particlesEnabled);
    }
    if (statusBadge) {
        statusBadge.textContent = particlesEnabled ? 'ON' : 'OFF';
        statusBadge.classList.toggle('active', particlesEnabled);
    }
}

function resetFabPosition() {
    const fab = document.getElementById('fab-container');
    if (fab) {
        fab.style.bottom = '';
        fab.style.right = '';
        fab.style.left = '';
        fab.style.top = '';
        fab.style.transform = '';
    }
}

// =========================================
// Drag & Drop Scrolling
// =========================================
function initDragScroll(selector) {
    const slider = document.querySelector(selector);
    if (!slider) return;

    let isDown = false;
    let startX, startY;
    let scrollLeft, scrollTop;

    slider.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.closest('.element')) return;
        isDown = true;
        slider.classList.add('active');
        document.body.classList.add('grabbing');
        startX = e.pageX - slider.offsetLeft;
        startY = e.pageY - slider.offsetTop;
        scrollLeft = slider.scrollLeft;
        scrollTop = slider.scrollTop;
    });

    const stopDrag = () => {
        isDown = false;
        slider.classList.remove('active');
        document.body.classList.remove('grabbing');
    };

    slider.addEventListener('mouseleave', stopDrag);
    slider.addEventListener('mouseup', stopDrag);

    slider.addEventListener('mousemove', (e) => {
        if (!isDown) return;
        e.preventDefault();
        const x = e.pageX - slider.offsetLeft;
        const y = e.pageY - slider.offsetTop;
        const walkX = (x - startX) * 1.5;
        const walkY = (y - startY) * 1.5;
        slider.scrollLeft = scrollLeft - walkX;
        slider.scrollTop = scrollTop - walkY;
    });
}

document.addEventListener('DOMContentLoaded', () => {
    // Скролл для всей страницы
    let isWindowDown = false;
    let winStartX, winStartY, winScrollLeft, winScrollTop;

    window.addEventListener('mousedown', (e) => {
        if (e.target.closest('.modal') || e.target.closest('.filters-panel') || e.target.closest('.calc-panel') || e.target.closest('.fab-container')) return;
        isWindowDown = true;
        document.body.classList.add('grabbing');
        winStartX = e.pageX;
        winStartY = e.pageY;
        winScrollLeft = window.scrollX;
        winScrollTop = window.scrollY;
    });

    window.addEventListener('mouseup', () => {
        isWindowDown = false;
        document.body.classList.remove('grabbing');
    });

    window.addEventListener('mousemove', (e) => {
        if (!isWindowDown) return;
        e.preventDefault();
        const x = e.pageX;
        const y = e.pageY;
        window.scrollTo(winScrollLeft - (x - winStartX) * 1.5, winScrollTop - (y - winStartY) * 1.5);
    });

    initPanHints();
    updateParticlesToggleUI();
});

window.initSolubilityDrag = function() {
    initDragScroll('.solubility-wrapper');
};

// =========================================
// Панорамные подсказки (градиенты + микро-сдвиг)
// =========================================
function initPanHints() {
    const tableContainer = document.querySelector('.periodic-table-container');
    if (tableContainer) {
        const hints = buildPanHints(tableContainer, 'table');

        const update = () => {
            const maxX = Math.max(0, document.documentElement.scrollWidth - window.innerWidth);
            const maxY = Math.max(0, document.documentElement.scrollHeight - window.innerHeight);
            const locked = document.body.classList.contains('scroll-locked');
            const x = window.scrollX;
            const y = window.scrollY;

            setHintVisible(hints.left, locked && x > 2);
            setHintVisible(hints.right, locked && x < maxX - 2);
            setHintVisible(hints.top, locked && y > 2);
            setHintVisible(hints.bottom, locked && y < maxY - 2);
        };

        window.addEventListener('scroll', update, { passive: true });
        window.addEventListener('resize', update);
        update();

        // Микро-анимация 1 раз за сессию
        if (!sessionStorage.getItem('tablePanHintShown')) {
            sessionStorage.setItem('tablePanHintShown', '1');
            setTimeout(() => {
                const maxX = Math.max(0, document.documentElement.scrollWidth - window.innerWidth);
                if (maxX > 0) {
                    window.scrollBy({ left: 10, behavior: 'smooth' });
                    setTimeout(() => {
                        window.scrollBy({ left: -10, behavior: 'smooth' });
                    }, 220);
                }
            }, 450);
        }
    }
}

function buildPanHints(container, prefix) {
    const hints = document.createElement('div');
    hints.className = `pan-hints pan-hints--${prefix}`;

    const left = document.createElement('div');
    left.className = 'pan-hint pan-hint--left';
    const right = document.createElement('div');
    right.className = 'pan-hint pan-hint--right';
    const top = document.createElement('div');
    top.className = 'pan-hint pan-hint--top';
    const bottom = document.createElement('div');
    bottom.className = 'pan-hint pan-hint--bottom';

    hints.appendChild(left);
    hints.appendChild(right);
    hints.appendChild(top);
    hints.appendChild(bottom);
    container.appendChild(hints);

    return { left, right, top, bottom };
}

function setHintVisible(el, visible) {
    if (!el) return;
    el.classList.toggle('is-visible', Boolean(visible));
}

// =========================================
// ОБЕРТКИ ДЛЯ ЛЕНИВОЙ ЗАГРУЗКИ (FIX)
// =========================================

// 1. Калькулятор
window.toggleCalc = async function(event) {
    const PANEL_ANIM_MS = 360;
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }

    const panel = document.getElementById('calc-panel');
    const fab = document.getElementById('fab-container');
    const themeToggle = document.getElementById('theme-toggle');

    // Закрытие всегда доступно, даже если одновременно активировались другие состояния UI.
    if (panel && panel.classList.contains('active')) {
        if (panel.classList.contains('closing')) return;
        panel.classList.add('closing');
        document.body.classList.remove('calc-active');
        if (themeToggle) themeToggle.style.display = '';
        resetFabPosition();
        if (window.mobileLayout && typeof window.mobileLayout.resetTransform === 'function') {
            window.mobileLayout.resetTransform();
        }

        setTimeout(() => {
            panel.classList.remove('active', 'closing');
            if (window.innerWidth <= 1024 && fab) {
                fab.classList.add('active');
            }
        }, PANEL_ANIM_MS);
        return;
    }

    const isElementModalOpen = document.body.classList.contains('modal-open');
    const isBalancerOpen = document.body.classList.contains('balancer-active');
    const isSolubilityOpen = document.body.classList.contains('solubility-open');
    const isReactionsOpen = document.body.classList.contains('reactions-open');
    const filtersPanel = document.getElementById('filters-panel');
    const isFiltersOpen = filtersPanel && filtersPanel.classList.contains('active');

    if (isElementModalOpen || isSolubilityOpen || isFiltersOpen || isBalancerOpen || isReactionsOpen) {
        return;
    }

    // Загружаем модуль если ещё не загружен
    if (window.loadCalculator) await window.loadCalculator();

    const loadedPanel = document.getElementById('calc-panel');
    if (!loadedPanel) return;

    // Открываем
    if (window.innerWidth <= 1024 && fab) {
        fab.classList.remove('active');
        if (themeToggle) themeToggle.style.display = 'none';
    } else if (themeToggle) {
        themeToggle.style.display = '';
    }
    loadedPanel.classList.remove('closing');
    loadedPanel.classList.add('active');
    document.body.classList.add('calc-active');
    if (window.mobileLayout && typeof window.mobileLayout.applyTransform === 'function') {
        setTimeout(() => window.mobileLayout.applyTransform(), 50);
    }

    // Позиционируем на ПК
    if (window.innerWidth > 1024 && typeof positionCalculatorPC === 'function') {
        positionCalculatorPC();
    }
};

// 2. Растворимость (То, чего не хватало!)
window.toggleSolubility = async function() {
    const isElementModalOpen = document.body.classList.contains('modal-open');
    if (isElementModalOpen) return;
    // Проверяем, открыт ли уравниватель
    const isBalancerOpen = document.body.classList.contains('balancer-active');
    if (isBalancerOpen) return;

    // ШАГ 1: Проверяем состояние
    const modal = document.getElementById('solubility-modal');
    const isCurrentlyVisible = modal ? (getComputedStyle(modal).display !== 'none') : false;
    // Если модалки нет или она скрыта -> значит мы ОТКРЫВАЕМ
    const isOpening = !modal || !isCurrentlyVisible;

    // Проверяем, мобильное ли это устройство (как в mobile-layout.js)
    const isMobile = window.innerWidth <= 1024;

    // ШАГ 2: Грузим скрипт
    if (window.loadSolubility) await window.loadSolubility();

    // ШАГ 3: Логика открытия/закрытия
    if (modal) {
        if (!isCurrentlyVisible) {
            // Открываем
            if (typeof openSolubility === 'function') {
                await openSolubility();
            } else {
                modal.style.display = 'flex';
                document.body.classList.add('solubility-open');
                if (isMobile) {
                    const fab = document.getElementById('fab-container');
                    if (fab) fab.style.display = 'none';
                }
            }

            // Если мы на ПК (isMobile === false), кнопки скрывать не нужно,
            // но на всякий случай убедимся, что они видны (если вдруг остались скрыты с прошлого раза)
            if (!isMobile) {
                const fab = document.getElementById('fab-container');
                const themeBtn = document.getElementById('theme-toggle');
                if (fab) fab.style.display = '';
                if (themeBtn) themeBtn.style.display = '';
            }

            if (typeof renderSolubilityTable === 'function' && document.getElementById('solubility-table').innerHTML === "") {
                renderSolubilityTable();
            }
            if (window.initSolubilityDrag) {
                window.initSolubilityDrag();
            }
        } else {
            // Закрываем
            if (typeof closeSolubility === 'function') {
                closeSolubility();
                // Доп. страховка: если тело/фильтры не восстановились
                document.body.classList.remove('solubility-open');
                if (typeof restoreElementFilters === 'function') {
                    restoreElementFilters();
                }
                if (typeof window.restoreElementFiltersSafe === 'function') {
                    window.restoreElementFiltersSafe();
                }
                if (typeof resetTableDisplay === 'function') {
                    resetTableDisplay();
                }
            } else {
                modal.classList.add('closing');
                setTimeout(() => {
                    modal.style.display = 'none';
                    modal.classList.remove('closing');
                    document.body.classList.remove('solubility-open');
                }, 360);

                // Возвращаем кнопки (на случай если модуль не прогрузился)
                const fab = document.getElementById('fab-container');
                const themeBtn = document.getElementById('theme-toggle');
                if (fab) fab.style.display = '';
                if (themeBtn) themeBtn.style.display = '';
            }
        }
    }
};

// 3. Реакции (большая модалка)
window.toggleReactionsModal = function(event) {
    if (event) {
        event.stopPropagation();
        event.preventDefault();
    }

    const modal = document.getElementById('reactions-modal');
    if (!modal) return;
    bindReactionsBackdrop();

    const isCurrentlyVisible = getComputedStyle(modal).display !== 'none';
    const isMobile = window.innerWidth <= 1024;

    // Закрытие всегда должно работать, даже если параллельно открыт другой UI.
    if (isCurrentlyVisible) {
        if (modal.classList.contains('closing')) return;
        modal.classList.add('closing');
        setTimeout(() => {
            modal.style.display = 'none';
            modal.classList.remove('closing');
            document.body.classList.remove('reactions-open');
            document.documentElement.classList.remove('reactions-open');
            const savedScroll = parseInt(document.body.dataset.reactionsScroll || '0', 10);
            document.body.style.position = '';
            document.body.style.top = '';
            document.body.style.width = '';
            delete document.body.dataset.reactionsScroll;
            window.scrollTo(0, isNaN(savedScroll) ? 0 : savedScroll);

            const fab = document.getElementById('fab-container');
            const themeBtn = document.getElementById('theme-toggle');
            if (fab) fab.style.display = '';
            if (themeBtn) themeBtn.style.display = '';
        }, 360);
        return;
    }

    const isElementModalOpen = document.body.classList.contains('modal-open');
    const isCalcOpen = document.body.classList.contains('calc-active');
    const isBalancerOpen = document.body.classList.contains('balancer-active');
    const isSolubilityOpen = document.body.classList.contains('solubility-open');
    const filtersPanel = document.getElementById('filters-panel');
    const isFiltersOpen = filtersPanel && filtersPanel.classList.contains('active');

    if (isElementModalOpen || isCalcOpen || isBalancerOpen || isSolubilityOpen || isFiltersOpen) {
        return;
    }

    modal.style.display = 'flex';
    const scrollY = window.scrollY || window.pageYOffset || 0;
    document.body.dataset.reactionsScroll = String(scrollY);
    document.body.classList.add('reactions-open');
    document.documentElement.classList.add('reactions-open');
    document.body.style.position = 'fixed';
    document.body.style.top = `-${scrollY}px`;
    document.body.style.width = '100%';

    const fab = document.getElementById('fab-container');
    const themeBtn = document.getElementById('theme-toggle');

    // На мобильных скрываем FAB и кнопку темы
    if (isMobile) {
        if (fab) fab.style.display = 'none';
        if (themeBtn) themeBtn.style.display = 'none';
    }
};

function initUI() {
    // Пустая заглушка, если нужна будет доп. логика
}

window.initUI = initUI;

function bindReactionsBackdrop() {
    const modal = document.getElementById('reactions-modal');
    if (!modal || modal.dataset.boundBackdrop === '1') return;
    modal.dataset.boundBackdrop = '1';
    modal.addEventListener('click', (event) => {
        if (event.target === modal) {
            window.toggleReactionsModal(event);
        }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    bindReactionsBackdrop();
});
// Блокировка вертикального скролла на мобильных
function lockVerticalScroll() {
    if (window.innerWidth <= 1024) {
      document.documentElement.style.overflow = 'hidden';
      document.body.style.overflow = 'hidden';
    }
  }
  
  // Разблокировка скролла
  function unlockVerticalScroll() {
    document.documentElement.style.overflow = '';
    document.body.style.overflow = '';
  }
  
// Блокировка ТОЛЬКО вертикального скролла на мобильных
let startY = 0;
let isVerticalScroll = false;

document.body.addEventListener('touchstart', (e) => {
  startY = e.touches[0].clientY;
  isVerticalScroll = false;
}, { passive: true });

document.body.addEventListener('touchmove', (e) => {
  if (window.innerWidth > 1024) return;

  const currentY = e.touches[0].clientY;
  const diffY = Math.abs(currentY - startY);

  // Если вертикальное движение больше горизонтального - блокируем
  if (diffY > 10 && !isVerticalScroll) {
    isVerticalScroll = true;

    // Проверяем, можно ли предотвратить действие по умолчанию
    if (e.cancelable) {
      e.preventDefault();
    }
    return;
  }

  // Разрешаем горизонтальный скролл
  if (!isVerticalScroll) {
    return;
  }
}, { passive: false });

// === ОБРАБОТКА ИЗМЕНЕНИЯ ОРИЕНТАЦИИ ===
function handleOrientationChange() {
    const isLandscape = window.matchMedia('(orientation: landscape)').matches;
    const isMobile = window.innerWidth <= 768;
    
    if (isMobile) {
      // Перезагрузка адаптивных стилей для мобильных в горизонтальном режиме
      setTimeout(() => {
        if (typeof window.mobileLayout?.init === 'function') {
          window.mobileLayout.init();
        }
        
        // Адаптация позиций панелей
        if (document.body.classList.contains('balancer-active') && 
            typeof positionBalancerPC === 'function') {
          positionBalancerPC();
        }
        
        if (document.body.classList.contains('calc-active') && 
            typeof positionCalculatorPC === 'function') {
          positionCalculatorPC();
        }
      }, 300);
    }
  }
  
  // Добавление слушателя событий
  window.addEventListener('orientationchange', handleOrientationChange);
  window.addEventListener('resize', handleOrientationChange);
  
  // Инициализация при загрузке
  document.addEventListener('DOMContentLoaded', () => {
    handleOrientationChange();
  });


============================================================
ФАЙЛ: .\js\nodemap\nodemap-canvas.js
============================================================

// 🎨 NodeMap Canvas - Rendering and Interaction

class NodeMapCanvas {
    constructor(canvas, data) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.data = data;

        // View transform
        this.offsetX = 0;
        this.offsetY = 0;
        this.scale = 1;
        this.minScale = 0.1;
        this.maxScale = 3;

        // Interaction state
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.hoveredNode = null;
        this.selectedNode = null;

        // Visual config
        this.config = {
            nodeMinWidth: 120,
            nodeMaxWidth: 250,
            nodeHeight: 60,
            nodePadding: 8,
            fontSize: 12,
            lineWidth: 2,
            colors: {
                cold: '#6B9BD1',      // Blue
                cool: '#7EC4CF',      // Cyan
                normal: '#82C785',    // Green
                warm: '#F4D03F',      // Yellow
                hot: '#E74C3C',       // Red
                bg: '#2C3E50',
                text: '#ECF0F1',
                textDim: '#95A5A6',
                connection: '#34495E',
                connectionHighlight: '#E67E22',
                selected: '#3498DB'
            },
            icons: {
                entry: '📥',
                leaf: '📤',
                hub: '🔄',
                island: '🏝️',
                normal: '⚡'
            }
        };

        this.setupEventListeners();
        this.resize();
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();

        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;

        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';

        this.width = rect.width;
        this.height = rect.height;
    }

    setupEventListeners() {
        // Сохраняем ссылки на функции для удаления
        this.handlers = {
            mouseDown: (e) => this.onMouseDown(e),
            mouseMove: (e) => this.onMouseMove(e),
            mouseUp: (e) => this.onMouseUp(e),
            wheel: (e) => this.onWheel(e),
            click: (e) => this.onClick(e),
            touchStart: (e) => this.onTouchStart(e),
            touchMove: (e) => this.onTouchMove(e),
            touchEnd: (e) => this.onTouchEnd(e),
            resize: () => { this.resize(); this.render(); }
        };

        // Mouse events
        this.canvas.addEventListener('mousedown', this.handlers.mouseDown);
        this.canvas.addEventListener('mousemove', this.handlers.mouseMove);
        this.canvas.addEventListener('mouseup', this.handlers.mouseUp);
        this.canvas.addEventListener('wheel', this.handlers.wheel);
        this.canvas.addEventListener('click', this.handlers.click);

        // Touch events
        this.canvas.addEventListener('touchstart', this.handlers.touchStart);
        this.canvas.addEventListener('touchmove', this.handlers.touchMove);
        this.canvas.addEventListener('touchend', this.handlers.touchEnd);

        // Window resize
        window.addEventListener('resize', this.handlers.resize);
    }

    // Transform screen coordinates to world coordinates
    screenToWorld(x, y) {
        return {
            x: (x - this.offsetX) / this.scale,
            y: (y - this.offsetY) / this.scale
        };
    }

    // Transform world coordinates to screen coordinates
    worldToScreen(x, y) {
        return {
            x: x * this.scale + this.offsetX,
            y: y * this.scale + this.offsetY
        };
    }

    // Mouse down handler
    onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.isDragging = true;
        this.dragStartX = e.clientX - rect.left - this.offsetX;
        this.dragStartY = e.clientY - rect.top - this.offsetY;
        this.canvas.style.cursor = 'grabbing';
    }

    // Mouse move handler
    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        if (this.isDragging) {
            this.offsetX = mouseX - this.dragStartX;
            this.offsetY = mouseY - this.dragStartY;
            this.render();
        } else {
            // Check hover
            const world = this.screenToWorld(mouseX, mouseY);
            const node = this.getNodeAt(world.x, world.y);

            if (node !== this.hoveredNode) {
                this.hoveredNode = node;
                this.canvas.style.cursor = node ? 'pointer' : 'grab';
                this.render();
            }
        }
    }

    // Mouse up handler
    onMouseUp(e) {
        this.isDragging = false;
        this.canvas.style.cursor = this.hoveredNode ? 'pointer' : 'grab';
    }

    // Mouse wheel handler (zoom)
    onWheel(e) {
        e.preventDefault();

        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Zoom factor
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * delta));

        if (newScale !== this.scale) {
            // Zoom towards mouse position
            const worldBefore = this.screenToWorld(mouseX, mouseY);

            this.scale = newScale;

            const worldAfter = this.screenToWorld(mouseX, mouseY);

            this.offsetX += (worldAfter.x - worldBefore.x) * this.scale;
            this.offsetY += (worldAfter.y - worldBefore.y) * this.scale;

            this.render();
        }
    }

    // Click handler
    onClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const world = this.screenToWorld(mouseX, mouseY);

        const node = this.getNodeAt(world.x, world.y);

        if (node) {
            this.selectedNode = this.selectedNode === node ? null : node;
            this.render();

            // Dispatch event for external handling
            this.canvas.dispatchEvent(new CustomEvent('nodeSelected', {
                detail: { node: this.selectedNode }
            }));
        }
    }

    // Touch handlers
    onTouchStart(e) {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    onTouchMove(e) {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
        }
        if (e.cancelable) {
            e.preventDefault();
        }
    }

    onTouchEnd(e) {
        this.onMouseUp(e);
    }

    // Find node at position
    getNodeAt(x, y) {
        for (const node of this.data.nodes) {
            if (x >= node.x && x <= node.x + node.width &&
                y >= node.y && y <= node.y + this.config.nodeHeight) {
                return node;
            }
        }
        return null;
    }

    // Center view on specific node
    centerOnNode(node) {
        this.offsetX = this.width / 2 - (node.x + node.width / 2) * this.scale;
        this.offsetY = this.height / 2 - (node.y + this.config.nodeHeight / 2) * this.scale;
        this.render();
    }

    // Fit all nodes in view
    fitToView() {
        if (this.data.nodes.length === 0) return;

        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;

        for (const node of this.data.nodes) {
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
            maxX = Math.max(maxX, node.x + node.width);
            maxY = Math.max(maxY, node.y + this.config.nodeHeight);
        }

        const padding = 50;
        const graphWidth = maxX - minX + padding * 2;
        const graphHeight = maxY - minY + padding * 2;

        const scaleX = this.width / graphWidth;
        const scaleY = this.height / graphHeight;
        this.scale = Math.min(scaleX, scaleY, 1);

        this.offsetX = (this.width - (minX + maxX) * this.scale) / 2;
        this.offsetY = (this.height - (minY + maxY) * this.scale) / 2;

        this.render();
    }

    // Main render function
    render() {
        // Clear canvas
        this.ctx.fillStyle = this.config.colors.bg;
        this.ctx.fillRect(0, 0, this.width, this.height);

        // Save state
        this.ctx.save();

        // Apply transform
        this.ctx.translate(this.offsetX, this.offsetY);
        this.ctx.scale(this.scale, this.scale);

        // Render connections first (so they're behind nodes)
        this.renderConnections();

        // Render nodes
        this.renderNodes();

        // Restore state
        this.ctx.restore();

        // Render UI overlay (always on top)
        this.renderOverlay();
    }

    // Render connections between nodes
    renderConnections() {
        for (const connection of this.data.connections) {
            const isHighlighted = this.selectedNode &&
                (connection.from === this.selectedNode || connection.to === this.selectedNode);

            this.ctx.strokeStyle = isHighlighted ?
                this.config.colors.connectionHighlight :
                this.config.colors.connection;
            this.ctx.lineWidth = isHighlighted ? 3 : 1.5;
            this.ctx.globalAlpha = isHighlighted ? 1 : 0.3;

            const fromX = connection.from.x + connection.from.width / 2;
            const fromY = connection.from.y + this.config.nodeHeight / 2;
            const toX = connection.to.x + connection.to.width / 2;
            const toY = connection.to.y + this.config.nodeHeight / 2;

            // Draw curved bezier line
            this.ctx.beginPath();
            this.ctx.moveTo(fromX, fromY);

            const dx = toX - fromX;
            const dy = toY - fromY;
            const curve = Math.abs(dx) * 0.5;

            this.ctx.bezierCurveTo(
                fromX + curve, fromY,
                toX - curve, toY,
                toX, toY
            );

            this.ctx.stroke();

            // Draw arrow head
            if (isHighlighted) {
                this.drawArrowHead(toX, toY, fromX, fromY);
            }
        }

        this.ctx.globalAlpha = 1;
    }

    // Draw arrow head
    drawArrowHead(toX, toY, fromX, fromY) {
        const angle = Math.atan2(toY - fromY, toX - fromX);
        const arrowSize = 10;

        this.ctx.fillStyle = this.config.colors.connectionHighlight;
        this.ctx.beginPath();
        this.ctx.moveTo(toX, toY);
        this.ctx.lineTo(
            toX - arrowSize * Math.cos(angle - Math.PI / 6),
            toY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        this.ctx.lineTo(
            toX - arrowSize * Math.cos(angle + Math.PI / 6),
            toY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        this.ctx.closePath();
        this.ctx.fill();
    }

    // Render all nodes
    renderNodes() {
        for (const node of this.data.nodes) {
            const isHovered = this.hoveredNode === node;
            const isSelected = this.selectedNode === node;

            this.renderNode(node, isHovered, isSelected);
        }
    }

    // Render single node
    renderNode(node, isHovered, isSelected) {
        const x = node.x;
        const y = node.y;
        const w = node.width;
        const h = this.config.nodeHeight;
        const p = this.config.nodePadding;

        // Draw shadow if hovered/selected
        if (isHovered || isSelected) {
            this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            this.ctx.shadowBlur = 10;
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 4;
        }

        // Draw background
        this.ctx.fillStyle = this.config.colors.bg;
        this.ctx.fillRect(x, y, w, h);

        // Draw border (color based on temperature)
        this.ctx.strokeStyle = isSelected ?
            this.config.colors.selected :
            this.config.colors[node.data.temperature];
        this.ctx.lineWidth = isSelected ? 4 : 2;
        this.ctx.strokeRect(x, y, w, h);

        // Reset shadow
        this.ctx.shadowColor = 'transparent';
        this.ctx.shadowBlur = 0;

        // Draw icon
        const icon = this.config.icons[node.data.nodeType] || this.config.icons.normal;
        this.ctx.font = '16px sans-serif';
        this.ctx.fillStyle = this.config.colors.text;
        this.ctx.fillText(icon, x + p, y + 22);

        // Draw function name
        this.ctx.font = `bold ${this.config.fontSize}px monospace`;
        this.ctx.fillStyle = this.config.colors.text;
        const nameX = x + p + 25;
        this.ctx.fillText(this.truncateText(node.data.name, w - 40), nameX, y + 22);

        // Draw metrics
        this.ctx.font = `${this.config.fontSize - 2}px monospace`;
        this.ctx.fillStyle = this.config.colors.textDim;
        const metricsY = y + h - p - 8;

        const callsText = `→${node.data.calls.length}`;
        const calledByText = `←${node.data.calledBy.length}`;
        const linesText = `${node.data.lineCount}L`;

        this.ctx.fillText(`${callsText} ${calledByText}`, x + p, metricsY);
        this.ctx.fillText(linesText, x + w - p - this.ctx.measureText(linesText).width, metricsY);
    }

    // Truncate text to fit width
    truncateText(text, maxWidth) {
        const metrics = this.ctx.measureText(text);
        if (metrics.width <= maxWidth) return text;

        let truncated = text;
        while (this.ctx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
            truncated = truncated.slice(0, -1);
        }
        return truncated + '...';
    }

    // Render UI overlay
    renderOverlay() {
        // Zoom indicator
        const zoomText = `${Math.round(this.scale * 100)}%`;
        this.ctx.font = '14px sans-serif';
        this.ctx.fillStyle = this.config.colors.textDim;
        this.ctx.fillText(zoomText, this.width - 60, this.height - 20);
    }

    // === Добавить этот метод в конец класса NodeMapCanvas ===
    updateTheme(isDark) {
        if (isDark) {
            this.config.colors.bg = '#2C3E50';
            this.config.colors.text = '#ECF0F1';
            this.config.colors.textDim = '#95A5A6';
            this.config.colors.connection = '#34495E';
        } else {
            this.config.colors.bg = '#ffffff';
            this.config.colors.text = '#333333';
            this.config.colors.textDim = '#666666';
            this.config.colors.connection = '#e0e0e0';
        }
        // Принудительная перерисовка
        this.render();
    }
    // Очистка ресурсов и удаление слушателей
    // Очистка ресурсов
    destroy() {
        if (!this.handlers) return;

        this.canvas.removeEventListener('mousedown', this.handlers.mouseDown);
        this.canvas.removeEventListener('mousemove', this.handlers.mouseMove);
        this.canvas.removeEventListener('mouseup', this.handlers.mouseUp);
        this.canvas.removeEventListener('wheel', this.handlers.wheel);
        this.canvas.removeEventListener('click', this.handlers.click);

        this.canvas.removeEventListener('touchstart', this.handlers.touchStart);
        this.canvas.removeEventListener('touchmove', this.handlers.touchMove);
        this.canvas.removeEventListener('touchend', this.handlers.touchEnd);

        window.removeEventListener('resize', this.handlers.resize);
    }
}


============================================================
ФАЙЛ: .\js\nodemap\nodemap-flow-canvas.js
============================================================

// 🎨 User Flow Canvas - Flowchart rendering
// Отрисовка блок-схемы с разными фигурами (овалы, ромбы, шестиугольники)

class UserFlowCanvas {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.data = null;

        // Transform
        this.offsetX = 0;
        this.offsetY = 0;
        this.scale = 1;

        // Interaction
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartY = 0;
        this.hoveredNode = null;
        this.selectedNode = null;

        // Стили фигур
        this.styles = {
            terminal: {
                fill: '#238636',
                stroke: '#2ea043',
                shape: 'oval'
            },
            process: {
                fill: '#1f6feb',
                stroke: '#388bfd',
                shape: 'rect'
            },
            decision: {
                fill: '#9e6a03',
                stroke: '#d29922',
                shape: 'diamond'
            },
            modal: {
                fill: '#8957e5',
                stroke: '#a371f7',
                shape: 'hexagon'
            },
            input: {
                fill: '#bd561d',
                stroke: '#db6d28',
                shape: 'parallelogram'
            }
        };

        this.setupEvents();
    }

    setData(data) {
        this.data = data;
        this.render();
    }

    setupEvents() {
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', () => this.onMouseUp());
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e));

        // Touch
        this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
        this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
        this.canvas.addEventListener('touchend', () => this.onMouseUp());
    }

    // ══════════ РЕНДЕРИНГ ══════════

    render() {
        if (!this.data) return;

        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();

        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);

        // Фон
        this.ctx.fillStyle = '#0d1117';
        this.ctx.fillRect(0, 0, rect.width, rect.height);

        this.ctx.save();
        this.ctx.translate(this.offsetX, this.offsetY);
        this.ctx.scale(this.scale, this.scale);

        // Сначала связи
        this.renderConnections();

        // Потом ноды
        this.renderNodes();

        this.ctx.restore();
    }

    renderConnections() {
        for (const conn of this.data.connections) {
            const from = conn.fromNode;
            const to = conn.toNode;
            const isReturn = conn.type === 'return';

            // Стиль линии
            this.ctx.strokeStyle = isReturn ? '#484f58' : '#8b949e';
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash(isReturn ? [6, 4] : []);

            this.ctx.beginPath();

            if (isReturn) {
                // Возвратные линии — обходим справа
                const fromX = from.x + from.width / 2;
                const fromY = from.y;
                const toX = to.x + to.width / 2;
                const toY = to.y + to.height / 2;

                // Отступ вправо (чем ниже нода — тем дальше отступ)
                const rightOffset = 80 + (from.level || 0) * 30;

                this.ctx.moveTo(fromX, fromY);
                this.ctx.lineTo(fromX, fromY - 15);           // Вверх немного
                this.ctx.lineTo(fromX + rightOffset, fromY - 15); // Вправо
                this.ctx.lineTo(fromX + rightOffset, toY);    // Вверх до уровня цели
                this.ctx.lineTo(toX + to.width / 2 + 10, toY); // К ноде

            } else {
                // Обычные линии — строго вертикально + горизонтально
                const fromX = from.x;
                const fromY = from.y + from.height / 2;
                const toX = to.x;
                const toY = to.y - to.height / 2;

                // Средняя точка по Y
                const midY = fromY + (toY - fromY) / 2;

                this.ctx.moveTo(fromX, fromY);
                this.ctx.lineTo(fromX, midY);    // Вниз до середины
                this.ctx.lineTo(toX, midY);      // Горизонтально к цели
                this.ctx.lineTo(toX, toY);       // Вниз к ноде
            }

            this.ctx.stroke();

            // Стрелка (только для обычных связей)
            if (!isReturn) {
                this.drawArrow(to.x, to.y - to.height / 2, 'down');
            }

            // Label на линии
            if (conn.label && !isReturn) {
                const fromX = from.x;
                const fromY = from.y + from.height / 2;
                const toX = to.x;
                const toY = to.y - to.height / 2;
                const midY = fromY + (toY - fromY) / 2;

                // Позиция label — на горизонтальном участке
                const labelX = (fromX + toX) / 2;
                const labelY = midY - 6;

                // Фон для текста
                this.ctx.font = '10px system-ui';
                const textWidth = this.ctx.measureText(conn.label).width;
                this.ctx.fillStyle = '#0d1117';
                this.ctx.fillRect(labelX - textWidth / 2 - 4, labelY - 8, textWidth + 8, 14);

                // Текст
                this.ctx.fillStyle = '#8b949e';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(conn.label, labelX, labelY);
            }
        }

        this.ctx.setLineDash([]);
    }

    drawArrow(x, y, direction = 'down') {
        const size = 6;
        this.ctx.fillStyle = '#8b949e';
        this.ctx.beginPath();

        if (direction === 'down') {
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(x - size, y - size * 1.5);
            this.ctx.lineTo(x + size, y - size * 1.5);
        } else if (direction === 'left') {
            this.ctx.moveTo(x, y);
            this.ctx.lineTo(x + size * 1.5, y - size);
            this.ctx.lineTo(x + size * 1.5, y + size);
        }

        this.ctx.closePath();
        this.ctx.fill();
    }

    renderNodes() {
        for (const node of this.data.nodes) {
            this.renderNode(node);
        }
    }

    renderNode(node) {
        const style = this.styles[node.type] || this.styles.process;
        const x = node.x - node.width / 2;
        const y = node.y - node.height / 2;
        const w = node.width;
        const h = node.height;

        const isHovered = this.hoveredNode === node;
        const isSelected = this.selectedNode === node;

        // Тень при hover
        if (isHovered || isSelected) {
            this.ctx.shadowColor = style.stroke;
            this.ctx.shadowBlur = 15;
        }

        // Рисуем фигуру
        this.ctx.fillStyle = style.fill;
        this.ctx.strokeStyle = isSelected ? '#ffffff' : style.stroke;
        this.ctx.lineWidth = isSelected ? 3 : 2;

        this.drawShape(style.shape, x, y, w, h);

        this.ctx.shadowBlur = 0;

        // Иконка
        this.ctx.font = '18px system-ui';
        this.ctx.fillStyle = '#ffffff';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(node.icon || '●', node.x - w/3, node.y);

        // Заголовок
        this.ctx.font = 'bold 12px system-ui';
        this.ctx.fillText(this.truncate(node.title, 15), node.x + 10, node.y - 5);

        // Подзаголовок
        if (node.subtitle) {
            this.ctx.font = '10px system-ui';
            this.ctx.fillStyle = 'rgba(255,255,255,0.7)';
            this.ctx.fillText(node.subtitle, node.x + 10, node.y + 10);
        }
    }

    drawShape(shape, x, y, w, h) {
        this.ctx.beginPath();

        switch (shape) {
            case 'oval':
                this.ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
                break;

            case 'diamond':
                this.ctx.moveTo(x + w/2, y);
                this.ctx.lineTo(x + w, y + h/2);
                this.ctx.lineTo(x + w/2, y + h);
                this.ctx.lineTo(x, y + h/2);
                this.ctx.closePath();
                break;

            case 'hexagon':
                const inset = 15;
                this.ctx.moveTo(x + inset, y);
                this.ctx.lineTo(x + w - inset, y);
                this.ctx.lineTo(x + w, y + h/2);
                this.ctx.lineTo(x + w - inset, y + h);
                this.ctx.lineTo(x + inset, y + h);
                this.ctx.lineTo(x, y + h/2);
                this.ctx.closePath();
                break;

            case 'parallelogram':
                const skew = 15;
                this.ctx.moveTo(x + skew, y);
                this.ctx.lineTo(x + w, y);
                this.ctx.lineTo(x + w - skew, y + h);
                this.ctx.lineTo(x, y + h);
                this.ctx.closePath();
                break;

            default: // rect
                const r = 8;
                this.ctx.roundRect(x, y, w, h, r);
        }

        this.ctx.fill();
        this.ctx.stroke();
    }

    truncate(text, maxLen) {
        return text.length > maxLen ? text.slice(0, maxLen) + '...' : text;
    }

    // ══════════ СОБЫТИЯ ══════════

    onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        this.isDragging = true;
        this.dragStartX = e.clientX - rect.left - this.offsetX;
        this.dragStartY = e.clientY - rect.top - this.offsetY;
        this.canvas.style.cursor = 'grabbing';
    }

    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        if (this.isDragging) {
            this.offsetX = mx - this.dragStartX;
            this.offsetY = my - this.dragStartY;
            this.render();
        }
    }

    onMouseUp() {
        this.isDragging = false;
        this.canvas.style.cursor = 'grab';
    }

    onWheel(e) {
        e.preventDefault();

        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Позиция мыши в мировых координатах ДО зума
        const worldX = (mouseX - this.offsetX) / this.scale;
        const worldY = (mouseY - this.offsetY) / this.scale;

        // Изменяем масштаб
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = Math.max(0.2, Math.min(3, this.scale * delta));

        // Корректируем offset чтобы точка под курсором осталась на месте
        this.offsetX = mouseX - worldX * newScale;
        this.offsetY = mouseY - worldY * newScale;
        this.scale = newScale;

        this.render();
    }

    onTouchStart(e) {
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    onTouchMove(e) {
        if (e.cancelable) {
            e.preventDefault();
        }
        if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
        }
    }

    // ══════════ УПРАВЛЕНИЕ ══════════

    fitToView() {
        if (!this.data || !this.data.nodes.length) return;

        const rect = this.canvas.getBoundingClientRect();
        const layout = new UserFlowLayout(window.UserFlowData);
        const bounds = layout.getBounds();

        const scaleX = rect.width / bounds.width;
        const scaleY = rect.height / bounds.height;
        this.scale = Math.min(scaleX, scaleY, 1) * 0.9;

        this.offsetX = (rect.width - bounds.width * this.scale) / 2;
        this.offsetY = (rect.height - bounds.height * this.scale) / 2 + 50;

        this.render();
    }
}


============================================================
ФАЙЛ: .\js\nodemap\nodemap-flow-data.js
============================================================

// 🗺️ User Flow Data - Карта пользовательских сценариев
// Описывает путь пользователя по сайту в виде блок-схемы

window.UserFlowData = {

    nodes: [
        // ═══════════ ENTRY ═══════════
        {
            id: 'start',
            type: 'terminal',
            title: 'Пользователь заходит на сайт',
            icon: '🌐',
            level: 0
        },

        // ═══════════ ЗАГРУЗКА ═══════════
        {
            id: 'loading',
            type: 'process',
            title: 'Загрузка модулей',
            subtitle: 'scrypt.js',
            icon: '⚙️',
            level: 1
        },
        {
            id: 'render-table',
            type: 'process',
            title: 'Генерация таблицы',
            icon: '🧪',
            level: 2
        },

        // ═══════════ ГЛАВНЫЙ ВЫБОР ═══════════
        {
            id: 'main-choice',
            type: 'decision',
            title: 'Действие пользователя',
            icon: '🤔',
            level: 3
        },

        // ═══════════ ДЕЙСТВИЯ ═══════════
        {
            id: 'click-element',
            type: 'process',
            title: 'Клик на элемент',
            icon: '👆',
            level: 4
        },
        {
            id: 'open-fab',
            type: 'process',
            title: 'Открыть FAB',
            icon: '📱',
            level: 4
        },
        {
            id: 'change-theme',
            type: 'process',
            title: 'Сменить тему',
            icon: '🌓',
            level: 4
        },
        {
            id: 'press-dot',
            type: 'process',
            title: 'Нажать . (точка)',
            icon: '⌨️',
            level: 4
        },
        {
            id: 'search',
            type: 'input',
            title: 'Поиск элемента',
            icon: '🔍',
            level: 4
        },
        {
            id: 'press-esc',
            type: 'process',
            title: 'Нажать Esc',
            icon: '⎋',
            level: 4
        },

        // ═══════════ РЕЗУЛЬТАТЫ ═══════════
        {
            id: 'element-modal',
            type: 'modal',
            title: 'Модалка элемента',
            subtitle: '3D + свойства',
            icon: '🔬',
            level: 5
        },
        {
            id: 'fab-choice',
            type: 'decision',
            title: 'Выбор в FAB',
            icon: '📋',
            level: 5
        },
        {
            id: 'theme-wave',
            type: 'process',
            title: 'Волна + тема',
            icon: '🌊',
            level: 5
        },
        {
            id: 'nodemap-modal',
            type: 'modal',
            title: 'Node Map',
            icon: '🗺️',
            level: 5
        },
        {
            id: 'search-result',
            type: 'process',
            title: 'Подсветка + скролл',
            icon: '✨',
            level: 5
        },
        {
            id: 'close-modal',
            type: 'process',
            title: 'Закрыть модалку',
            icon: '❌',
            level: 5
        },

        // ═══════════ FAB ПУНКТЫ ═══════════
        {
            id: 'calculator',
            type: 'modal',
            title: 'Калькулятор массы',
            icon: '🔢',
            level: 6
        },
        {
            id: 'solubility',
            type: 'modal',
            title: 'Таблица растворимости',
            icon: '🧫',
            level: 6
        },
        {
            id: 'atom-3d',
            type: 'modal',
            title: '3D модель атома',
            icon: '⚛️',
            level: 6
        },
        {
            id: 'more-options',
            type: 'decision',
            title: 'Ещё опции...',
            icon: '📑',
            level: 6
        }
    ],

    connections: [
        // Линейный путь
        { from: 'start', to: 'loading' },
        { from: 'loading', to: 'render-table' },
        { from: 'render-table', to: 'main-choice' },

        // Разветвление главного выбора
        { from: 'main-choice', to: 'click-element', label: 'Клик' },
        { from: 'main-choice', to: 'open-fab', label: 'FAB' },
        { from: 'main-choice', to: 'change-theme', label: 'Тема' },
        { from: 'main-choice', to: 'press-dot', label: '.' },
        { from: 'main-choice', to: 'search', label: 'Поиск' },
        { from: 'main-choice', to: 'press-esc', label: 'Esc' },

        // Результаты действий
        { from: 'click-element', to: 'element-modal' },
        { from: 'open-fab', to: 'fab-choice' },
        { from: 'change-theme', to: 'theme-wave' },
        { from: 'press-dot', to: 'nodemap-modal' },
        { from: 'search', to: 'search-result' },
        { from: 'press-esc', to: 'close-modal' },

        // FAB подменю
        { from: 'fab-choice', to: 'calculator', label: 'Масса' },
        { from: 'fab-choice', to: 'solubility', label: 'Растворимость' },
        { from: 'fab-choice', to: 'atom-3d', label: '3D' },
        { from: 'fab-choice', to: 'more-options', label: '...' },

        // Возврат (пунктирные линии)
        { from: 'element-modal', to: 'main-choice', type: 'return' },
        { from: 'theme-wave', to: 'main-choice', type: 'return' },
        { from: 'search-result', to: 'main-choice', type: 'return' },
        { from: 'nodemap-modal', to: 'main-choice', type: 'return' },
        { from: 'calculator', to: 'main-choice', type: 'return' },
        { from: 'solubility', to: 'main-choice', type: 'return' },
        { from: 'atom-3d', to: 'main-choice', type: 'return' },
        { from: 'close-modal', to: 'main-choice', type: 'return' }
    ]
};


============================================================
ФАЙЛ: .\js\nodemap\nodemap-flow-layout.js
============================================================

// 📐 User Flow Layout - Hierarchical positioning
// Размещает ноды блок-схемы по уровням с автоматическим центрированием

class UserFlowLayout {
    constructor(data) {
        this.data = data;
        this.nodeMap = new Map();

        this.config = {
            levelHeight: 120,      // Расстояние между уровнями
            nodeSpacing: 180,      // Расстояние между нодами
            nodeWidth: 150,
            nodeHeight: 60,
            padding: 80
        };
    }

    calculate() {
        // 1. Группировка по уровням
        const levels = this.groupByLevels();

        // 2. Расчёт позиций
        const positions = this.calculatePositions(levels);

        // 3. Подготовка нод с позициями
        const nodes = this.data.nodes.map(node => ({
            ...node,
            x: positions[node.id].x,
            y: positions[node.id].y,
            width: this.config.nodeWidth,
            height: this.config.nodeHeight
        }));

        // 4. Подготовка связей
        const nodeById = new Map(nodes.map(n => [n.id, n]));
        const connections = this.data.connections
            .map(conn => ({
                ...conn,
                fromNode: nodeById.get(conn.from),
                toNode: nodeById.get(conn.to)
            }))
            .filter(conn => conn.fromNode && conn.toNode);

        return { nodes, connections };
    }

    groupByLevels() {
        const levels = {};

        for (const node of this.data.nodes) {
            const level = node.level || 0;
            if (!levels[level]) levels[level] = [];
            levels[level].push(node);
        }

        return levels;
    }

    calculatePositions(levels) {
        const positions = {};

        // Найти максимальную ширину
        let maxNodesInLevel = 0;
        for (const nodes of Object.values(levels)) {
            maxNodesInLevel = Math.max(maxNodesInLevel, nodes.length);
        }

        const totalWidth = maxNodesInLevel * this.config.nodeSpacing;

        // Расположить каждый уровень
        for (const [level, nodes] of Object.entries(levels)) {
            const levelY = this.config.padding + parseInt(level) * this.config.levelHeight;
            const levelWidth = nodes.length * this.config.nodeSpacing;
            const startX = (totalWidth - levelWidth) / 2 + this.config.nodeSpacing / 2;

            nodes.forEach((node, index) => {
                positions[node.id] = {
                    x: startX + index * this.config.nodeSpacing,
                    y: levelY
                };
            });
        }

        return positions;
    }

    getBounds() {
        const levels = this.groupByLevels();
        const levelCount = Object.keys(levels).length;
        let maxNodesInLevel = 0;

        for (const nodes of Object.values(levels)) {
            maxNodesInLevel = Math.max(maxNodesInLevel, nodes.length);
        }

        return {
            width: maxNodesInLevel * this.config.nodeSpacing + this.config.padding * 2,
            height: levelCount * this.config.levelHeight + this.config.padding * 2
        };
    }
}


============================================================
ФАЙЛ: .\js\nodemap\nodemap-init.js
============================================================

// 🚀 NodeMap Initialization

(function() {
    'use strict';

    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    function init() {
        console.log('🗺️ NodeMap initialized');

        // Add keyboard shortcut (.)
        document.addEventListener('keydown', function(e) {
            // Check if '.' key is pressed
            // And not inside an input/textarea
            const isInputField = e.target.tagName === 'INPUT' ||
                                 e.target.tagName === 'TEXTAREA' ||
                                 e.target.isContentEditable;

            if (e.key === '.' && !isInputField && !e.ctrlKey && !e.metaKey && !e.altKey) {
                e.preventDefault();
                openNodeMap();
            }
        });

        // Also add to window for manual access
        window.openNodeMap = openNodeMap;

        console.log('💡 Press "." to open Function Dependency Map');
    }
})();


============================================================
ФАЙЛ: .\js\nodemap\nodemap-layout.js
============================================================



class NodeMapLayout {
    constructor(analyzed) {
        this.analyzed = analyzed;
        this.nodes = [];
        this.connections = [];

        // Layout parameters
        this.config = {
            springLength: 150,
            springStrength: 0.05,
            repulsionStrength: 5000,
            damping: 0.85,
            centeringStrength: 0.01,
            iterations: 300,
            minNodeWidth: 120,
            maxNodeWidth: 250,
            nodeHeight: 60,
            spacing: 50
        };
    }

    // Main layout function
    calculate() {
        console.log('📐 Calculating layout...');

        this.createNodes();
        this.createConnections();
        this.initializePositions();
        this.runSimulation();

        console.log(`✅ Layout complete: ${this.nodes.length} nodes, ${this.connections.length} connections`);

        return {
            nodes: this.nodes,
            connections: this.connections
        };
    }

    // Create node objects
    createNodes() {
        this.nodes = [];

        for (const [name, data] of Object.entries(this.analyzed)) {
            const width = this.calculateNodeWidth(data);

            this.nodes.push({
                id: name,
                data: data,
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                width: width,
                height: this.config.nodeHeight
            });
        }
    }

    // Calculate node width based on name length and importance
    calculateNodeWidth(data) {
        const baseWidth = Math.min(
            this.config.maxNodeWidth,
            Math.max(
                this.config.minNodeWidth,
                data.name.length * 8 + 40
            )
        );

        // Make important nodes (hubs) slightly wider
        const importanceFactor = data.nodeType === 'hub' ? 1.1 : 1;

        return baseWidth * importanceFactor;
    }

    // Create connection objects
    createConnections() {
        this.connections = [];
        const nodeMap = new Map(this.nodes.map(n => [n.id, n]));

        for (const node of this.nodes) {
            for (const targetName of node.data.calls) {
                const targetNode = nodeMap.get(targetName);
                if (targetNode) {
                    this.connections.push({
                        from: node,
                        to: targetNode
                    });
                }
            }
        }
    }

    // Initialize node positions
    initializePositions() {
        const strategy = this.detectLayoutStrategy();

        switch (strategy) {
            case 'hierarchical':
                this.hierarchicalLayout();
                break;
            case 'circular':
                this.circularLayout();
                break;
            default:
                this.randomLayout();
        }
    }

    // Detect best layout strategy
    detectLayoutStrategy() {
        // Check if graph is hierarchical (DAG-like)
        const hasLayers = this.hasLayeredStructure();
        if (hasLayers) return 'hierarchical';

        // Check if graph is small and disconnected
        if (this.nodes.length < 20) return 'circular';

        return 'random';
    }

    // Check if graph has layered structure
    hasLayeredStructure() {
        // Count entry points and leaves
        let entryPoints = 0;
        let leaves = 0;

        for (const node of this.nodes) {
            if (node.data.nodeType === 'entry') entryPoints++;
            if (node.data.nodeType === 'leaf') leaves++;
        }

        // If we have clear entry points and leaves, it's hierarchical
        return entryPoints > 0 && leaves > 0;
    }

    // Hierarchical layout (layer-based)
    hierarchicalLayout() {
        const layers = this.calculateLayers();
        const layerWidth = 800;
        const layerHeight = 150;

        let y = 0;
        for (const layer of layers) {
            const totalWidth = layer.length * layerWidth;
            let x = -totalWidth / 2;

            for (const node of layer) {
                node.x = x + layerWidth / 2;
                node.y = y;
                x += layerWidth / layer.length;
            }

            y += layerHeight;
        }
    }

    // Calculate layers using topological sort
    calculateLayers() {
        const layers = [];
        const visited = new Set();
        const nodeMap = new Map(this.nodes.map(n => [n.id, n]));

        // Find nodes with no incoming edges (entry points)
        const entryNodes = this.nodes.filter(n => n.data.calledBy.length === 0);

        if (entryNodes.length === 0) {
            // No entry points, fall back to all nodes in first layer
            return [this.nodes];
        }

        // BFS to assign layers
        let currentLayer = [...entryNodes];

        while (currentLayer.length > 0) {
            layers.push([...currentLayer]);
            const nextLayer = [];

            for (const node of currentLayer) {
                visited.add(node.id);

                // Add children to next layer
                for (const childName of node.data.calls) {
                    const childNode = nodeMap.get(childName);
                    if (childNode && !visited.has(childName)) {
                        // Check if all parents are visited
                        const allParentsVisited = childNode.data.calledBy.every(p => visited.has(p));
                        if (allParentsVisited && !nextLayer.includes(childNode)) {
                            nextLayer.push(childNode);
                        }
                    }
                }
            }

            currentLayer = nextLayer;
        }

        // Add any remaining nodes (islands or circular deps)
        const remainingNodes = this.nodes.filter(n => !visited.has(n.id));
        if (remainingNodes.length > 0) {
            layers.push(remainingNodes);
        }

        return layers;
    }

    // Circular layout
    circularLayout() {
        const radius = 300;
        const angleStep = (2 * Math.PI) / this.nodes.length;

        for (let i = 0; i < this.nodes.length; i++) {
            const angle = i * angleStep;
            this.nodes[i].x = Math.cos(angle) * radius;
            this.nodes[i].y = Math.sin(angle) * radius;
        }
    }

    // Random layout
    randomLayout() {
        const spread = 500;

        for (const node of this.nodes) {
            node.x = (Math.random() - 0.5) * spread;
            node.y = (Math.random() - 0.5) * spread;
        }
    }

    // Run force-directed simulation
    runSimulation() {
        for (let i = 0; i < this.config.iterations; i++) {
            // Calculate forces
            this.applyRepulsion();
            this.applyAttraction();
            this.applyCentering();

            // Update positions
            this.updatePositions();

            // Cool down (reduce movement over time)
            const coolingFactor = 1 - (i / this.config.iterations);
            this.config.damping = 0.85 + coolingFactor * 0.1;
        }

        // Final adjustment to prevent overlaps
        this.preventOverlaps();
    }

    // Apply repulsion force (nodes push each other away)
    applyRepulsion() {
        for (let i = 0; i < this.nodes.length; i++) {
            for (let j = i + 1; j < this.nodes.length; j++) {
                const nodeA = this.nodes[i];
                const nodeB = this.nodes[j];

                const dx = nodeB.x - nodeA.x;
                const dy = nodeB.y - nodeA.y;
                const distSq = dx * dx + dy * dy;

                if (distSq < 0.01) continue;

                const dist = Math.sqrt(distSq);
                const force = this.config.repulsionStrength / distSq;

                const fx = (dx / dist) * force;
                const fy = (dy / dist) * force;

                nodeA.vx -= fx;
                nodeA.vy -= fy;
                nodeB.vx += fx;
                nodeB.vy += fy;
            }
        }
    }

    // Apply attraction force (connected nodes pull together)
    applyAttraction() {
        for (const connection of this.connections) {
            const dx = connection.to.x - connection.from.x;
            const dy = connection.to.y - connection.from.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 0.01) continue;

            const force = (dist - this.config.springLength) * this.config.springStrength;

            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;

            connection.from.vx += fx;
            connection.from.vy += fy;
            connection.to.vx -= fx;
            connection.to.vy -= fy;
        }
    }

    // Apply centering force (pull towards center)
    applyCentering() {
        for (const node of this.nodes) {
            node.vx -= node.x * this.config.centeringStrength;
            node.vy -= node.y * this.config.centeringStrength;
        }
    }

    // Update node positions
    updatePositions() {
        for (const node of this.nodes) {
            node.vx *= this.config.damping;
            node.vy *= this.config.damping;

            node.x += node.vx;
            node.y += node.vy;
        }
    }

    // Prevent node overlaps
    preventOverlaps() {
        const iterations = 10;
        const minDistance = 20;

        for (let iter = 0; iter < iterations; iter++) {
            for (let i = 0; i < this.nodes.length; i++) {
                for (let j = i + 1; j < this.nodes.length; j++) {
                    const nodeA = this.nodes[i];
                    const nodeB = this.nodes[j];

                    const dx = nodeB.x - nodeA.x;
                    const dy = nodeB.y - nodeA.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    const minDist = (nodeA.width + nodeB.width) / 2 + minDistance;

                    if (dist < minDist && dist > 0) {
                        const push = (minDist - dist) / 2;
                        const nx = dx / dist;
                        const ny = dy / dist;

                        nodeA.x -= nx * push;
                        nodeA.y -= ny * push;
                        nodeB.x += nx * push;
                        nodeB.y += ny * push;
                    }
                }
            }
        }
    }

    // Group nodes by clusters (connected components)
    findClusters() {
        const clusters = [];
        const visited = new Set();

        const dfs = (node, cluster) => {
            if (visited.has(node.id)) return;
            visited.add(node.id);
            cluster.push(node);

            // Visit connected nodes
            for (const targetName of node.data.calls) {
                const targetNode = this.nodes.find(n => n.id === targetName);
                if (targetNode) dfs(targetNode, cluster);
            }

            for (const sourceName of node.data.calledBy) {
                const sourceNode = this.nodes.find(n => n.id === sourceName);
                if (sourceNode) dfs(sourceNode, cluster);
            }
        };

        for (const node of this.nodes) {
            if (!visited.has(node.id)) {
                const cluster = [];
                dfs(node, cluster);
                clusters.push(cluster);
            }
        }

        return clusters;
    }
}


============================================================
ФАЙЛ: .\js\nodemap\nodemap-modal.js
============================================================

// 🖼️ NodeMap Modal - UI and Controls

class NodeMapModal {
    constructor() {
        this.parser = null;
        this.layout = null;
        this.canvas = null;
        this.analyzed = null;
        this.layoutData = null;

        // Режимы: 'graph' или 'flow'
        this.currentMode = 'graph';
        this.flowCanvas = null;

        this.createModal();
        this.setupEventListeners();
    }

    // Create modal HTML
    createModal() {
        const modal = document.createElement('div');
        modal.id = 'nodemap-modal';
        modal.className = 'nodemap-modal';
        modal.innerHTML = `
            <div class="nodemap-overlay"></div>
            <div class="nodemap-container">
                <div class="nodemap-header">
                    <div class="nodemap-title">
                        <span class="nodemap-icon">🗺️</span>
                        <h2>Function Dependency Map</h2>
                    </div>

                    <div class="nodemap-mode-toggle">
                        <button id="nodemap-mode-graph" class="mode-btn active" title="Граф функций">
                            🕸️ Граф
                        </button>
                        <button id="nodemap-mode-flow" class="mode-btn" title="User Flow">
                            📊 Flow
                        </button>
                    </div>

                    <div class="nodemap-stats">
                        <span id="nodemap-stats-functions">0 functions</span>
                        <span id="nodemap-stats-connections">0 connections</span>
                        <span id="nodemap-stats-clusters">0 clusters</span>
                    </div>
                    <button class="nodemap-close" title="Close (Esc)">&times;</button>
                </div>

                <div class="nodemap-toolbar">
                    <div class="nodemap-search">
                        <input type="text" id="nodemap-search" placeholder="🔍 Search functions..." />
                        <button id="nodemap-clear-search" title="Clear search">&times;</button>
                    </div>

                    <div class="nodemap-filters">
                        <button id="nodemap-filter-entry" class="nodemap-filter" title="Entry points">
                            📥 Entry <span class="count">0</span>
                        </button>
                        <button id="nodemap-filter-hub" class="nodemap-filter" title="Hub functions">
                            🔄 Hubs <span class="count">0</span>
                        </button>
                        <button id="nodemap-filter-leaf" class="nodemap-filter" title="Leaf functions">
                            📤 Leaves <span class="count">0</span>
                        </button>
                        <button id="nodemap-filter-island" class="nodemap-filter" title="Isolated functions">
                            🏝️ Islands <span class="count">0</span>
                        </button>
                    </div>

                    <div class="nodemap-actions">
                        <button id="nodemap-fit-view" title="Fit to view">⊡</button>
                        <button id="nodemap-reset-zoom" title="Reset zoom">100%</button>
                        <button id="nodemap-refresh" title="Refresh analysis">🔄</button>
                    </div>
                </div>

                <div class="nodemap-content">
                    <canvas id="nodemap-canvas"></canvas>

                    <div class="nodemap-sidebar">
                        <div class="nodemap-legend">
                            <h3>Legend</h3>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #6B9BD1;"></span>
                                <span>Cold (0-1 calls)</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #82C785;"></span>
                                <span>Normal (2-5 calls)</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #F4D03F;"></span>
                                <span>Warm (6-10 calls)</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: #E74C3C;"></span>
                                <span>Hot (>10 calls)</span>
                            </div>
                        </div>

                        <div class="nodemap-info" id="nodemap-info">
                            <h3>Node Info</h3>
                            <p class="nodemap-info-empty">Click on a node to see details</p>
                        </div>

                        <div class="nodemap-warnings" id="nodemap-warnings"></div>
                    </div>
                </div>

                <div class="nodemap-footer">
                    <div class="nodemap-help">
                        <span>💡 Drag to pan • Scroll to zoom • Click node for details</span>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);
    }

    // Setup event listeners
    setupEventListeners() {
        // Close button
        document.querySelector('.nodemap-close').addEventListener('click', () => this.close());

        // Overlay click
        document.querySelector('.nodemap-overlay').addEventListener('click', () => this.close());

        // Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isOpen()) {
                this.close();
            }
        });

        // Search
        const searchInput = document.getElementById('nodemap-search');
        searchInput.addEventListener('input', (e) => this.onSearch(e.target.value));

        document.getElementById('nodemap-clear-search').addEventListener('click', () => {
            searchInput.value = '';
            this.onSearch('');
        });

        // Filters
        document.getElementById('nodemap-filter-entry').addEventListener('click', () => this.filterByType('entry'));
        document.getElementById('nodemap-filter-hub').addEventListener('click', () => this.filterByType('hub'));
        document.getElementById('nodemap-filter-leaf').addEventListener('click', () => this.filterByType('leaf'));
        document.getElementById('nodemap-filter-island').addEventListener('click', () => this.filterByType('island'));

        // Actions
        document.getElementById('nodemap-fit-view').addEventListener('click', () => this.fitToView());
        document.getElementById('nodemap-reset-zoom').addEventListener('click', () => this.resetZoom());
        document.getElementById('nodemap-refresh').addEventListener('click', () => this.refresh());

        // Canvas events
        const canvasElement = document.getElementById('nodemap-canvas');
        canvasElement.addEventListener('nodeSelected', (e) => this.onNodeSelected(e.detail.node));

        // Mode toggle
        document.getElementById('nodemap-mode-graph').addEventListener('click', () => this.switchMode('graph'));
        document.getElementById('nodemap-mode-flow').addEventListener('click', () => this.switchMode('flow'));
    }

    // Open modal
    open() {
        console.log('🗺️ Opening Node Map...');

        // Show modal
        document.getElementById('nodemap-modal').classList.add('active');

        // Run analysis for current mode
        if (this.currentMode === 'graph') {
            this.runAnalysis();
        } else {
            this.runFlowMode();
        }
    }

    // Switch between modes
    switchMode(mode) {
        if (this.currentMode === mode) return;

        this.currentMode = mode;

        // Update buttons
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`nodemap-mode-${mode}`).classList.add('active');

        // Run appropriate mode
        if (mode === 'graph') {
            this.runAnalysis();
        } else {
            this.runFlowMode();
        }
    }

    // Run User Flow mode
    runFlowMode() {
        try {
            // Clean up previous canvas
            if (this.canvas) {
                this.canvas.destroy();
                this.canvas = null;
            }
            if (this.flowCanvas) {
                this.flowCanvas = null;
            }

            // Hide sidebar with warnings (not needed in flow mode)
            document.querySelector('.nodemap-sidebar').style.display = 'none';

            // Hide filters (not applicable for flow)
            document.querySelector('.nodemap-filters').style.display = 'none';

            // Update title
            document.querySelector('.nodemap-title h2').textContent = 'User Flow';

            // Calculate layout
            const layout = new UserFlowLayout(window.UserFlowData);
            const data = layout.calculate();

            // Create canvas
            const canvasElement = document.getElementById('nodemap-canvas');
            this.flowCanvas = new UserFlowCanvas(canvasElement);
            this.flowCanvas.setData(data);
            this.flowCanvas.fitToView();

            // Update stats for flow mode
            document.getElementById('nodemap-stats-functions').textContent =
                `${data.nodes.length} nodes`;
            document.getElementById('nodemap-stats-connections').textContent =
                `${data.connections.length} connections`;
            document.getElementById('nodemap-stats-clusters').textContent =
                `User journey map`;

        } catch (error) {
            console.error('Error running flow mode:', error);
            this.showError(error.message);
        }
    }

    // Close modal
    close() {
        document.getElementById('nodemap-modal').classList.remove('active');
    }

    // Check if modal is open
    isOpen() {
        return document.getElementById('nodemap-modal').classList.contains('active');
    }

    // Run analysis
    runAnalysis() {
        try {
            if (this.canvas) {
                this.canvas.destroy();
                this.canvas = null;
            }
            if (this.flowCanvas) {
                this.flowCanvas = null;
            }

            // Show sidebar and filters (for graph mode)
            document.querySelector('.nodemap-sidebar').style.display = '';
            document.querySelector('.nodemap-filters').style.display = '';

            // Update title
            document.querySelector('.nodemap-title h2').textContent = 'Function Dependency Map';

            // Parse project
            this.parser = new NodeMapParser();
            this.analyzed = this.parser.analyzeProject();

            // Calculate layout
            this.layout = new NodeMapLayout(this.analyzed);
            this.layoutData = this.layout.calculate();

            // Create canvas
            const canvasElement = document.getElementById('nodemap-canvas');
            this.canvas = new NodeMapCanvas(canvasElement, this.layoutData);

            // Update UI
            this.updateStats();
            this.updateFilters();
            this.checkWarnings();

            // Fit to view
            this.canvas.fitToView();

        } catch (error) {
            console.error('Error running analysis:', error);
            this.showError(error.message);
        }
    }

    // Update statistics
    updateStats() {
        const stats = this.parser.getStatistics(this.analyzed);

        document.getElementById('nodemap-stats-functions').textContent =
            `${stats.totalFunctions} functions`;
        document.getElementById('nodemap-stats-connections').textContent =
            `${stats.totalConnections} connections`;

        const clusters = this.layout.findClusters();
        document.getElementById('nodemap-stats-clusters').textContent =
            `${clusters.length} clusters`;
    }

    // Update filter counts
    updateFilters() {
        const counts = {
            entry: 0,
            hub: 0,
            leaf: 0,
            island: 0
        };

        for (const data of Object.values(this.analyzed)) {
            if (counts.hasOwnProperty(data.nodeType)) {
                counts[data.nodeType]++;
            }
        }

        document.querySelector('#nodemap-filter-entry .count').textContent = counts.entry;
        document.querySelector('#nodemap-filter-hub .count').textContent = counts.hub;
        document.querySelector('#nodemap-filter-leaf .count').textContent = counts.leaf;
        document.querySelector('#nodemap-filter-island .count').textContent = counts.island;
    }

    // Check for warnings
    checkWarnings() {
        const stats = this.parser.getStatistics(this.analyzed);
        const warnings = [];

        // Dead code
        if (stats.deadCode.length > 0) {
            warnings.push({
                type: 'warning',
                icon: '⚠️',
                title: 'Dead Code',
                message: `${stats.deadCode.length} unused functions found`,
                details: stats.deadCode.join(', ')
            });
        }

        // Circular dependencies
        if (stats.circularDeps.length > 0) {
            warnings.push({
                type: 'error',
                icon: '🔄',
                title: 'Circular Dependencies',
                message: `${stats.circularDeps.length} circular dependency chains found`,
                details: stats.circularDeps.map(c => c.join(' → ')).join('\n')
            });
        }

        // High complexity
        const highComplexity = Object.values(this.analyzed)
            .filter(d => d.complexity > 20)
            .map(d => `${d.name} (${d.complexity})`);

        if (highComplexity.length > 0) {
            warnings.push({
                type: 'info',
                icon: '📊',
                title: 'High Complexity',
                message: `${highComplexity.length} functions with complexity > 20`,
                details: highComplexity.join(', ')
            });
        }

        this.renderWarnings(warnings);
    }

    // Render warnings
    renderWarnings(warnings) {
        const container = document.getElementById('nodemap-warnings');

        if (warnings.length === 0) {
            container.innerHTML = '';
            return;
        }

        const html = warnings.map(w => `
            <div class="nodemap-warning ${w.type}">
                <div class="warning-header">
                    <span class="warning-icon">${w.icon}</span>
                    <strong>${w.title}</strong>
                </div>
                <p>${w.message}</p>
                ${w.details ? `<details><summary>Show details</summary><pre>${w.details}</pre></details>` : ''}
            </div>
        `).join('');

        container.innerHTML = `<h3>Warnings</h3>${html}`;
    }

    // Search handler
    onSearch(query) {
        if (!this.canvas) return;

        query = query.toLowerCase().trim();

        if (!query) {
            // Clear highlight
            this.canvas.selectedNode = null;
            this.canvas.render();
            return;
        }

        // Find matching node
        const matchingNode = this.layoutData.nodes.find(n =>
            n.data.name.toLowerCase().includes(query)
        );

        if (matchingNode) {
            this.canvas.selectedNode = matchingNode;
            this.canvas.centerOnNode(matchingNode);
            this.showNodeInfo(matchingNode);
        }
    }

    // Filter by node type
    filterByType(type) {
        if (!this.canvas) return;

        const matchingNodes = this.layoutData.nodes.filter(n => n.data.nodeType === type);

        if (matchingNodes.length > 0) {
            // Highlight first matching node
            const node = matchingNodes[0];
            this.canvas.selectedNode = node;
            this.canvas.centerOnNode(node);
            this.showNodeInfo(node);
        }
    }

    // Node selected handler
    onNodeSelected(node) {
        if (node) {
            this.showNodeInfo(node);
        } else {
            this.clearNodeInfo();
        }
    }

    // Show node info
    showNodeInfo(node) {
        const info = document.getElementById('nodemap-info');
        const data = node.data;

        const html = `
            <h3>${data.name}</h3>
            <div class="info-section">
                <div class="info-item">
                    <span class="info-label">Type:</span>
                    <span>${data.nodeType}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Temperature:</span>
                    <span style="color: ${this.canvas.config.colors[data.temperature]}">${data.temperature}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Lines:</span>
                    <span>${data.lineCount}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Complexity:</span>
                    <span>${data.complexity}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Parameters:</span>
                    <span>${data.params.length > 0 ? data.params.join(', ') : 'none'}</span>
                </div>
            </div>

            <div class="info-section">
                <h4>Calls (${data.calls.length})</h4>
                ${data.calls.length > 0 ? `
                    <ul class="info-list">
                        ${data.calls.map(fn => `<li>${fn}</li>`).join('')}
                    </ul>
                ` : '<p class="info-empty">No calls</p>'}
            </div>

            <div class="info-section">
                <h4>Called by (${data.calledBy.length})</h4>
                ${data.calledBy.length > 0 ? `
                    <ul class="info-list">
                        ${data.calledBy.map(fn => `<li>${fn}</li>`).join('')}
                    </ul>
                ` : '<p class="info-empty">Not called</p>'}
            </div>

            ${data.hasAsync ? '<div class="info-badge">⚡ Async</div>' : ''}
            ${data.hasEvents ? '<div class="info-badge">📡 Events</div>' : ''}
        `;

        info.innerHTML = html;
    }

    // Clear node info
    clearNodeInfo() {
        const info = document.getElementById('nodemap-info');
        info.innerHTML = `
            <h3>Node Info</h3>
            <p class="nodemap-info-empty">Click on a node to see details</p>
        `;
    }

    // Fit to view
    fitToView() {
        if (this.canvas) {
            this.canvas.fitToView();
        }
    }

    // Reset zoom
    resetZoom() {
        if (this.canvas) {
            this.canvas.scale = 1;
            this.canvas.offsetX = this.canvas.width / 2;
            this.canvas.offsetY = this.canvas.height / 2;
            this.canvas.render();
        }
    }

    // Refresh analysis
    refresh() {
        this.runAnalysis();
    }

    // Show error
    showError(message) {
        const container = document.getElementById('nodemap-warnings');
        container.innerHTML = `
            <div class="nodemap-warning error">
                <div class="warning-header">
                    <span class="warning-icon">❌</span>
                    <strong>Error</strong>
                </div>
                <p>${message}</p>
            </div>
        `;
    }
    // ... внутри класса NodeMapModal ...

        // === Добавить этот метод в класс NodeMapModal ===
        updateTheme(isDark) {
            if (this.canvas) {
                this.canvas.updateTheme(isDark);
            }
        }
    } // <-- Конец класса

    // ... существующий код (let nodeMapModalInstance ...) ...

    // === Добавить в самый конец файла (глобально) ===
    function updateNodeMapTheme(isDark) {
        if (nodeMapModalInstance) {
            nodeMapModalInstance.updateTheme(isDark);
        }
    }


// Global instance
let nodeMapModalInstance = null;

// Open function (called by '.' key)
function openNodeMap() {
    if (!nodeMapModalInstance) {
        nodeMapModalInstance = new NodeMapModal();
    }
    nodeMapModalInstance.open();
}


============================================================
ФАЙЛ: .\js\nodemap\nodemap-parser.js
============================================================

// 🧠 NodeMap Parser - Automatic Function Dependency Analysis

class NodeMapParser {
    constructor() {
        this.nativeFunctions = new Set([
            'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
            'console', 'alert', 'confirm', 'prompt',
            'parseInt', 'parseFloat', 'isNaN', 'isFinite',
            'encodeURI', 'decodeURI', 'encodeURIComponent', 'decodeURIComponent',
            'eval', 'Object', 'Array', 'String', 'Number', 'Boolean',
            'Date', 'Math', 'JSON', 'Promise', 'Map', 'Set', 'WeakMap', 'WeakSet',
            'fetch', 'XMLHttpRequest', 'addEventListener', 'removeEventListener',
            'requestAnimationFrame', 'cancelAnimationFrame'
        ]);

        this.domMethods = new Set([
            'getElementById', 'querySelector', 'querySelectorAll',
            'getElementsByClassName', 'getElementsByTagName',
            'createElement', 'createTextNode', 'appendChild', 'removeChild',
            'setAttribute', 'getAttribute', 'classList', 'style',
            'addEventListener', 'removeEventListener', 'dispatchEvent'
        ]);
    }

    // Main analysis function
    analyzeProject() {
        console.log('🔍 Starting project analysis...');
        const functions = this.findGlobalFunctions();
        const analyzed = this.analyzeDependencies(functions);
        this.buildReverseLinks(analyzed);
        this.calculateMetrics(analyzed);

        console.log(`✅ Found ${Object.keys(analyzed).length} functions with ${this.countConnections(analyzed)} connections`);
        return analyzed;
    }

    // Find all global functions
    findGlobalFunctions() {
        const functions = {};
        const seen = new Set();

        // Scan window object
        for (const key of Object.keys(window)) {
            if (seen.has(key)) continue;
            seen.add(key);

            const value = window[key];

            // Check if it's a function and not native
            if (typeof value === 'function' && !this.isNativeFunction(key, value)) {
                functions[key] = value;
            }
        }

        // Also check for object methods (like window.Module.method)
        for (const key of Object.keys(window)) {
            const value = window[key];
            if (value && typeof value === 'object' && !value.nodeType) {
                for (const methodKey of Object.keys(value)) {
                    if (typeof value[methodKey] === 'function' &&
                        !this.isNativeFunction(methodKey, value[methodKey])) {
                        const fullName = `${key}.${methodKey}`;
                        if (!seen.has(fullName)) {
                            functions[fullName] = value[methodKey];
                            seen.add(fullName);
                        }
                    }
                }
            }
        }

        return functions;
    }

    // Check if function is native/built-in
    isNativeFunction(name, fn) {
        if (this.nativeFunctions.has(name)) return true;
        if (this.domMethods.has(name)) return true;

        try {
            const source = fn.toString();
            if (source.includes('[native code]')) return true;
            // Filter out very short functions (likely getters/setters)
            if (source.length < 20) return true;
        } catch (e) {
            return true;
        }

        return false;
    }

    // Analyze function dependencies
    analyzeDependencies(functions) {
        const analyzed = {};
        const functionNames = Object.keys(functions);

        for (const [name, fn] of Object.entries(functions)) {
            const source = fn.toString();

            analyzed[name] = {
                name: name,
                source: source,
                calls: this.extractFunctionCalls(source, functionNames),
                calledBy: [],
                params: this.extractParams(source),
                lineCount: source.split('\n').length,
                complexity: this.calculateComplexity(source),
                hasAsync: source.includes('async ') || source.includes('await '),
                hasEvents: this.hasEventListeners(source)
            };
        }

        return analyzed;
    }

    // Extract function calls using smart regex
    extractFunctionCalls(source, availableFunctions) {
        const calls = new Set();

        // Patterns to match function calls
        const patterns = [
            // Direct calls: functionName(
            /\b([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g,
            // Object methods: obj.method(
            /\.([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(/g,
            // Callbacks: addEventListener('click', handler)
            /addEventListener\s*\(\s*['"][^'"]*['"]\s*,\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\)/g
        ];

        for (const pattern of patterns) {
            let match;
            while ((match = pattern.exec(source)) !== null) {
                const fnName = match[1];

                // Check if it's one of our tracked functions
                if (availableFunctions.includes(fnName)) {
                    calls.add(fnName);
                }

                // Check for Module.method format
                for (const availableName of availableFunctions) {
                    if (availableName.includes('.') && availableName.endsWith('.' + fnName)) {
                        calls.add(availableName);
                    }
                }
            }
        }

        // Remove self-references (recursion is ok but we'll mark it separately)
        const functionName = this.getFunctionName(source);
        calls.delete(functionName);

        return Array.from(calls);
    }

    // Extract function parameters
    extractParams(source) {
        const match = source.match(/function\s*\w*\s*\(([^)]*)\)|^\s*\(([^)]*)\)\s*=>/);
        if (!match) return [];

        const params = (match[1] || match[2] || '').trim();
        if (!params) return [];

        return params.split(',').map(p => p.trim()).filter(p => p);
    }

    // Get function name from source
    getFunctionName(source) {
        const match = source.match(/function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/);
        return match ? match[1] : null;
    }

    // Calculate cyclomatic complexity (simplified)
    calculateComplexity(source) {
        let complexity = 1; // Base complexity

        // Count decision points
        const patterns = [
            /\bif\s*\(/g,
            /\belse\s+if\s*\(/g,
            /\bfor\s*\(/g,
            /\bwhile\s*\(/g,
            /\bcase\s+/g,
            /\bcatch\s*\(/g,
            /&&/g,
            /\|\|/g,
            /\?/g
        ];

        for (const pattern of patterns) {
            const matches = source.match(pattern);
            if (matches) complexity += matches.length;
        }

        return complexity;
    }

    // Check if function has event listeners
    hasEventListeners(source) {
        return /addEventListener|on[A-Z][a-zA-Z]*\s*=/.test(source);
    }

    // Build reverse links (who calls this function)
    buildReverseLinks(analyzed) {
        for (const [name, data] of Object.entries(analyzed)) {
            for (const calledFn of data.calls) {
                if (analyzed[calledFn]) {
                    analyzed[calledFn].calledBy.push(name);
                }
            }
        }
    }

    // Calculate metrics for visualization
    calculateMetrics(analyzed) {
        for (const data of Object.values(analyzed)) {
            // Calculate "temperature" (how often it's called)
            data.temperature = this.getTemperature(data.calledBy.length);

            // Classify node type
            data.nodeType = this.classifyNode(data);

            // Calculate importance score
            data.importance = data.calls.length + data.calledBy.length * 2;
        }
    }

    // Get temperature category
    getTemperature(callCount) {
        if (callCount === 0) return 'cold';
        if (callCount <= 2) return 'cool';
        if (callCount <= 5) return 'normal';
        if (callCount <= 10) return 'warm';
        return 'hot';
    }

    // Classify node type
    classifyNode(data) {
        const isEntry = data.calledBy.length === 0 && data.calls.length > 0;
        const isLeaf = data.calls.length === 0 && data.calledBy.length > 0;
        const isHub = data.calls.length > 3 && data.calledBy.length > 3;
        const isIsland = data.calls.length === 0 && data.calledBy.length === 0;

        if (isIsland) return 'island';
        if (isEntry) return 'entry';
        if (isHub) return 'hub';
        if (isLeaf) return 'leaf';
        return 'normal';
    }

    // Count total connections
    countConnections(analyzed) {
        let total = 0;
        for (const data of Object.values(analyzed)) {
            total += data.calls.length;
        }
        return total;
    }

    // Find circular dependencies
    findCircularDependencies(analyzed) {
        const circles = [];
        const visited = new Set();
        const recursionStack = new Set();

        const dfs = (node, path = []) => {
            if (recursionStack.has(node)) {
                // Found a cycle
                const cycleStart = path.indexOf(node);
                if (cycleStart !== -1) {
                    circles.push(path.slice(cycleStart).concat(node));
                }
                return;
            }

            if (visited.has(node)) return;

            visited.add(node);
            recursionStack.add(node);
            path.push(node);

            const nodeData = analyzed[node];
            if (nodeData) {
                for (const calledFn of nodeData.calls) {
                    dfs(calledFn, [...path]);
                }
            }

            recursionStack.delete(node);
        };

        for (const name of Object.keys(analyzed)) {
            if (!visited.has(name)) {
                dfs(name);
            }
        }

        return circles;
    }

    // Find dead code (unused functions)
    findDeadCode(analyzed) {
        return Object.values(analyzed)
            .filter(data => data.calledBy.length === 0 && data.nodeType !== 'entry')
            .map(data => data.name);
    }

    // Get statistics
    getStatistics(analyzed) {
        const stats = {
            totalFunctions: Object.keys(analyzed).length,
            totalConnections: this.countConnections(analyzed),
            entryPoints: 0,
            hubs: 0,
            leaves: 0,
            islands: 0,
            avgComplexity: 0,
            avgLineCount: 0,
            circularDeps: this.findCircularDependencies(analyzed),
            deadCode: this.findDeadCode(analyzed)
        };

        let totalComplexity = 0;
        let totalLines = 0;

        for (const data of Object.values(analyzed)) {
            switch (data.nodeType) {
                case 'entry': stats.entryPoints++; break;
                case 'hub': stats.hubs++; break;
                case 'leaf': stats.leaves++; break;
                case 'island': stats.islands++; break;
            }
            totalComplexity += data.complexity;
            totalLines += data.lineCount;
        }

        stats.avgComplexity = Math.round(totalComplexity / stats.totalFunctions);
        stats.avgLineCount = Math.round(totalLines / stats.totalFunctions);

        return stats;
    }
}


============================================================
ФАЙЛ: .\js\nodemap\README.md
============================================================

# 🗺️ NodeMap - Автоматическая карта зависимостей функций

Интерактивная визуализация архитектуры JavaScript проекта с автоматическим анализом зависимостей между функциями.

## 🚀 Использование

Нажми клавишу **`.`** (точка) в любом месте страницы, чтобы открыть Function Dependency Map.

Или вызови программно:
```javascript
openNodeMap();
```

## ✨ Возможности

### 🔍 Автоматический анализ
- Сканирование всех глобальных функций из `window`
- Извлечение вызовов других функций из исходного кода
- Построение графа зависимостей (кто кого вызывает)
- Обнаружение циклических зависимостей
- Поиск "мёртвого кода" (неиспользуемых функций)

### 🎨 Визуализация
- **Canvas-рендеринг** с плавными анимациями
- **Pan & Zoom** - перемещайся и масштабируй граф
- **Force-directed layout** - автоматическое расположение нод
- **Цветовая индикация** "температуры" функций:
  - 🔵 Cold (0-1 вызов) - редко используется
  - 🟢 Normal (2-5 вызовов) - обычная функция
  - 🟡 Warm (6-10 вызовов) - важная функция
  - 🔴 Hot (>10 вызовов) - ключевая функция (hub)

### 🏷️ Типы нод
- 📥 **Entry point** - точки входа (никем не вызывается, но вызывает других)
- 📤 **Leaf** - конечные функции (не вызывает других)
- 🔄 **Hub** - узловые функции (много входящих и исходящих связей)
- 🏝️ **Island** - изолированные функции (не вызывает и не вызывается)

### 🔗 Связи
- **Прямые вызовы** - сплошные линии
- **Подсветка связей** - при выборе ноды показываются все её связи
- **Кривые Безье** - плавные соединения между нодами

### 🛠️ Интерактив
- **Поиск** - найди функцию по имени
- **Фильтры** - покажи только entry points, hubs, leaves или islands
- **Клик на ноду** - подробная информация:
  - Параметры функции
  - Количество строк кода
  - Сложность (cyclomatic complexity)
  - Список вызываемых функций
  - Список функций, которые вызывают данную
  - Async/await флаги
  - Event listeners флаги

### ⚠️ Предупреждения
- **Dead code** - функции, которые никто не вызывает
- **Circular dependencies** - циклы в графе зависимостей
- **High complexity** - функции со сложностью > 20

## 📁 Структура файлов

```
js/nodemap/
├── nodemap-parser.js    # 🧠 Парсер функций и зависимостей
├── nodemap-layout.js    # 📐 Force-directed layout алгоритм
├── nodemap-canvas.js    # 🎨 Canvas рендеринг и интерактив
├── nodemap-modal.js     # 🖼️ UI, поиск, фильтры
├── nodemap-init.js      # 🚀 Инициализация и hotkey
└── README.md            # 📖 Эта документация

css/
└── nodemap.css          # 🎨 Стили модального окна
```

## 🎯 Как это работает

### 1. Парсинг (nodemap-parser.js)
```javascript
// Сканируем window для поиска всех функций
for (const key of Object.keys(window)) {
    if (typeof window[key] === 'function' && !isNativeFunction(key)) {
        functions[key] = window[key];
    }
}

// Анализируем исходный код каждой функции
const source = fn.toString();
const calls = extractFunctionCalls(source, functionNames);
```

### 2. Layout (nodemap-layout.js)
```javascript
// Force-directed алгоритм:
// - Repulsion force - ноды отталкиваются друг от друга
// - Attraction force - связанные ноды притягиваются
// - Centering force - ноды стремятся к центру

for (let i = 0; i < iterations; i++) {
    applyRepulsion();
    applyAttraction();
    applyCentering();
    updatePositions();
}
```

### 3. Рендеринг (nodemap-canvas.js)
```javascript
// Canvas с transform:
ctx.translate(offsetX, offsetY);
ctx.scale(scale, scale);

// Рисуем связи (Bezier curves)
ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);

// Рисуем ноды (прямоугольники с иконками)
ctx.fillRect(x, y, width, height);
```

## 🎮 Управление

| Действие | Управление |
|----------|------------|
| **Открыть** | Клавиша `.` |
| **Перемещение** | Зажми и тяни мышью |
| **Зум** | Колесо мыши |
| **Выбрать ноду** | Клик по ноде |
| **Поиск** | Поле поиска вверху |
| **Фильтр** | Кнопки Entry/Hub/Leaf/Island |
| **Fit to view** | Кнопка ⊡ |
| **Закрыть** | `Esc` или кнопка ✕ |

## 📊 Метрики

Для каждой функции вычисляются:

- **Line Count** - количество строк кода
- **Complexity** - цикломатическая сложность (упрощённая)
- **Calls** - сколько функций вызывает
- **Called By** - сколькими функциями вызывается
- **Temperature** - частота использования
- **Importance** - calls + calledBy * 2

## 🔧 Настройка

Можно изменить параметры в конфиге:

```javascript
// nodemap-layout.js
this.config = {
    springLength: 150,        // Длина "пружины" между нодами
    springStrength: 0.05,     // Сила притяжения
    repulsionStrength: 5000,  // Сила отталкивания
    damping: 0.85,            // Затухание движения
    iterations: 300           // Количество итераций симуляции
};

// nodemap-canvas.js
this.config = {
    nodeMinWidth: 120,
    nodeMaxWidth: 250,
    nodeHeight: 60,
    colors: { ... }           // Цвета для разных температур
};
```

## 💡 Советы

1. **Большие проекты** - если функций много (>100), layout может занять время. Будь терпелив!

2. **Поиск проблем** - используй панель Warnings справа для поиска:
   - Неиспользуемого кода
   - Циклических зависимостей
   - Слишком сложных функций

3. **Навигация** - используй поиск для быстрого перехода к нужной функции

4. **Анализ архитектуры** - обрати внимание на:
   - **Hubs** - центральные функции, которые связывают много других
   - **Entry points** - точки входа в разные модули
   - **Islands** - возможно, забытый/мёртвый код

## 🐛 Известные ограничения

1. **Только глобальные функции** - функции внутри IIFE или модулей не видны
2. **Только прямые вызовы** - динамические вызовы через `eval()` или `Function()` не отслеживаются
3. **Ложные срабатывания** - иногда может найти "вызов" в строковых литералах
4. **Методы объектов** - обнаруживаются только если объект в `window`

## 🚀 Будущие улучшения

- [ ] Export в PNG/SVG
- [ ] Группировка по файлам (если добавить `// @file:` комментарии)
- [ ] Режим "diff" - подсветка новых функций
- [ ] Интеграция с source maps
- [ ] Анализ вызовов через webpack/rollup бандлы
- [ ] Оптимизация отображения на мобильных устройствах (адаптация интерфейса под тип устройства)

## 📝 Лицензия

Часть проекта "Интерактивная Таблица Менделеева"

---

**Совет дня**: нажми `.` прямо сейчас и изучи архитектуру своего проекта! 🗺️


============================================================
ФАЙЛ: .\js\solubility\advanced-modal.js
============================================================

// =========================================
// ADVANCED-MODAL.JS — Упрощённое модальное окно
// Версия 2.0: Автогенерация + SVG визуализация
// =========================================

// === ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ===
window.isAdvancedClickMode = false;
const advancedModal = document.getElementById('advanced-substance-modal');
const advancedModalContent = document.getElementById('advanced-substance-content');
const ADVANCED_MODE_HINT_TEXT = 'нажмите на вещество для подробной информации';
const ADVANCED_MODE_HINT_HIDE_DELAY_MS = 3200;
let advancedModeHintTimerId = null;

function ensureAdvancedModeHint() {
    const container = document.querySelector('#solubility-modal .solubility-content');
    if (!container) return null;

    let hint = container.querySelector('.advanced-mode-hint');
    if (!hint) {
        hint = document.createElement('div');
        hint.className = 'advanced-mode-hint';
        hint.setAttribute('role', 'status');
        hint.setAttribute('aria-live', 'polite');
        hint.textContent = ADVANCED_MODE_HINT_TEXT;
        container.appendChild(hint);
    }

    return hint;
}

function hideAdvancedModeHint(immediate = false) {
    if (advancedModeHintTimerId) {
        clearTimeout(advancedModeHintTimerId);
        advancedModeHintTimerId = null;
    }

    const hint = document.querySelector('#solubility-modal .advanced-mode-hint');
    if (!hint) return;

    hint.classList.remove('is-visible');
    if (immediate) {
        hint.style.transition = 'none';
        hint.offsetHeight;
        hint.style.removeProperty('transition');
    }
}

function showAdvancedModeHint() {
    const hint = ensureAdvancedModeHint();
    if (!hint) return;

    hideAdvancedModeHint();

    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            hint.classList.add('is-visible');
        });
    });

    advancedModeHintTimerId = setTimeout(() => {
        hint.classList.remove('is-visible');
        advancedModeHintTimerId = null;
    }, ADVANCED_MODE_HINT_HIDE_DELAY_MS);
}

// === ИНИЦИАЛИЗАЦИЯ ===
function initAdvancedModeButton() {
    const btn = document.getElementById('advanced-mode-info-btn');
    if (!btn) return;

    const activeTitle = '\u0420\u0435\u0436\u0438\u043c \u0432\u043a\u043b\u044e\u0447\u0451\u043d \u2014 \u043a\u043b\u0438\u043a\u043d\u0438\u0442\u0435 \u043d\u0430 \u044f\u0447\u0435\u0439\u043a\u0443 \u0434\u043b\u044f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438';
    const inactiveTitle = '\u0412\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u0440\u0435\u0436\u0438\u043c \u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440\u0430 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438';

    const syncButtonState = () => {
        btn.classList.toggle('active', window.isAdvancedClickMode);
        btn.title = window.isAdvancedClickMode ? activeTitle : inactiveTitle;
    };

    syncButtonState();
    if (!window.isAdvancedClickMode) {
        hideAdvancedModeHint(true);
    }

    btn.onclick = () => {
        window.isAdvancedClickMode = !window.isAdvancedClickMode;
        syncButtonState();

        if (window.isAdvancedClickMode) {
            showAdvancedModeHint();
        } else {
            hideAdvancedModeHint();
        }
    };
}

// === ОТКРЫТИЕ/ЗАКРЫТИЕ ===
function openAdvancedModal(cationFormula, anionFormula) {
    renderAdvancedContent(cationFormula, anionFormula);
    advancedModal.classList.remove('closing');
    advancedModal.style.display = 'flex';
    document.body.classList.add('advanced-modal-open');
}

function closeAdvancedModal() {
    // Добавляем класс для анимации закрытия
    advancedModal.classList.add('closing');

    // Ждём завершения анимации
    setTimeout(() => {
        advancedModal.style.display = 'none';
        advancedModal.classList.remove('closing');
        document.body.classList.remove('advanced-modal-open');
    }, 360);
}

// === ГЕНЕРАЦИЯ ДАННЫХ ===

// Атомные массы элементов
const atomicMasses = {
    H: 1.008, Li: 6.941, Na: 22.990, K: 39.098, Rb: 85.468, Cs: 132.905,
    Be: 9.012, Mg: 24.305, Ca: 40.078, Sr: 87.62, Ba: 137.327,
    Al: 26.982, Ga: 69.723, In: 114.818, Tl: 204.383,
    C: 12.011, N: 14.007, O: 15.999, S: 32.065, P: 30.974, Si: 28.086,
    F: 18.998, Cl: 35.453, Br: 79.904, I: 126.904,
    Fe: 55.845, Cu: 63.546, Zn: 65.38, Ag: 107.868, Au: 196.967,
    Pb: 207.2, Hg: 200.592, Sn: 118.71, Cr: 51.996, Mn: 54.938,
    Co: 58.933, Ni: 58.693, Cd: 112.411
};

// Названия анионов в родительном падеже
const anionNames = {
    "OH-": { name: "гидроксид", gender: "m" },
    "F-": { name: "фторид", gender: "m" },
    "Cl-": { name: "хлорид", gender: "m" },
    "Br-": { name: "бромид", gender: "m" },
    "I-": { name: "иодид", gender: "m" },
    "S2-": { name: "сульфид", gender: "m" },
    "HS-": { name: "гидросульфид", gender: "m" },
    "SO32-": { name: "сульфит", gender: "m" },
    "SO42-": { name: "сульфат", gender: "m" },
    "NO3-": { name: "нитрат", gender: "m" },
    "PO43-": { name: "фосфат", gender: "m" },
    "CO32-": { name: "карбонат", gender: "m" },
    "SiO32-": { name: "силикат", gender: "m" },
    "CrO42-": { name: "хромат", gender: "m" },
    "Cr2O72-": { name: "дихромат", gender: "m" },
    "AlO2-": { name: "алюминат", gender: "m" },
    "ZnO22-": { name: "цинкат", gender: "m" },
    "PbO22-": { name: "плюмбат", gender: "m" },
    "CrO2-": { name: "хромит", gender: "m" },
    "SnO32-": { name: "станнат", gender: "m" },
    "CH3COO-": { name: "ацетат", gender: "m" },
    "MnO4-": { name: "перманганат", gender: "m" }
};

// Названия катионов в родительном падеже
const cationNames = {
    "H+": { name: "водорода", base: "водород" },
    "Li+": { name: "лития", base: "литий" },
    "Na+": { name: "натрия", base: "натрий" },
    "K+": { name: "калия", base: "калий" },
    "Rb+": { name: "рубидия", base: "рубидий" },
    "Cs+": { name: "цезия", base: "цезий" },
    "NH4+": { name: "аммония", base: "аммоний" },
    "Ca2+": { name: "кальция", base: "кальций" },
    "Mg2+": { name: "магния", base: "магний" },
    "Sr2+": { name: "стронция", base: "стронций" },
    "Ba2+": { name: "бария", base: "барий" },
    "Fe2+": { name: "железа(II)", base: "железо" },
    "Fe3+": { name: "железа(III)", base: "железо" },
    "Cu2+": { name: "меди(II)", base: "медь" },
    "Zn2+": { name: "цинка", base: "цинк" },
    "Al3+": { name: "алюминия", base: "алюминий" },
    "Ag+": { name: "серебра", base: "серебро" },
    "Pb2+": { name: "свинца(II)", base: "свинец" },
    "Hg2+": { name: "ртути(II)", base: "ртуть" },
    "Cr3+": { name: "хрома(III)", base: "хром" },
    "Mn2+": { name: "марганца(II)", base: "марганец" },
    "Ni2+": { name: "никеля(II)", base: "никель" },
    "Co2+": { name: "кобальта(II)", base: "кобальт" },
    "Sn2+": { name: "олова(II)", base: "олово" }
};

// Генерация формулы вещества
function generateFormula(cationFormula, anionFormula) {
    // Извлекаем заряды
    const cationCharge = Math.abs(parseInt(cationFormula.match(/(\d+)\+/)?.[1] || '1'));
    const anionCharge = Math.abs(parseInt(anionFormula.match(/(\d+)\-/)?.[1] || '1'));

    // Находим НОК для индексов
    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
    const lcm = (cationCharge * anionCharge) / gcd(cationCharge, anionCharge);

    const cationIndex = lcm / cationCharge;
    const anionIndex = lcm / anionCharge;

    // Убираем заряды и извлекаем символы
    const cation = cationFormula.replace(/[⁺⁻⁰¹²³⁴⁵⁶⁷⁸⁹]/g, '').replace(/[\+\-\d]/g, '');
    const anion = anionFormula.replace(/[⁺⁻⁰¹²³⁴⁵⁶⁷⁸⁹]/g, '').replace(/[\+\-\d]/g, '');

    // Формируем формулу
    let formula = cation;
    if (cationIndex > 1) formula += '₀₁₂₃₄₅₆₇₈₉'[cationIndex] || cationIndex;

    // Анион в скобках, если содержит несколько атомов
    if (anion.length > 1 && anionIndex > 1) {
        formula += `(${anion})`;
        formula += '₀₁₂₃₄₅₆₇₈₉'[anionIndex] || anionIndex;
    } else {
        formula += anion;
        if (anionIndex > 1) formula += '₀₁₂₃₄₅₆₇₈₉'[anionIndex] || anionIndex;
    }

    return formula;
}

// Генерация названия вещества
function generateSubstanceName(cationFormula, anionFormula) {
    const cationKey = normalizeFormula(cationFormula);
    const anionKey = normalizeFormula(anionFormula);

    const cation = cationNames[cationKey];
    const anion = anionNames[anionKey];

    if (!cation || !anion) {
        return null;
    }

    // Особый случай: вода
    if (cationKey === 'H+' && anionKey === 'OH-') {
        return "Вода";
    }

    // Стандартное название: "Хлорид натрия"
    return `${capitalize(anion.name)} ${cation.name}`;
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// Расчёт молярной массы
function calculateMolarMass(formula) {
    // Убираем подстрочные индексы → обычные цифры
    const normalized = formula
        .replace(/₀/g, '0').replace(/₁/g, '1').replace(/₂/g, '2')
        .replace(/₃/g, '3').replace(/₄/g, '4').replace(/₅/g, '5')
        .replace(/₆/g, '6').replace(/₇/g, '7').replace(/₈/g, '8')
        .replace(/₉/g, '9')
        .replace(/[()]/g, ''); // Убираем скобки для упрощения

    let mass = 0;
    const regex = /([A-Z][a-z]?)(\d*)/g;
    let match;

    while ((match = regex.exec(normalized)) !== null) {
        const element = match[1];
        const count = match[2] ? parseInt(match[2]) : 1;

        if (atomicMasses[element]) {
            mass += atomicMasses[element] * count;
        }
    }

    return mass.toFixed(2);
}

// Получение информации о растворимости
function getSolubilityInfo(cationFormula, anionFormula) {
    const solubility = getSolubility(cationFormula, anionFormula);

    const descriptions = {
        'Р': 'Растворимо',
        'М': 'Малорастворимо',
        'Н': 'Нерастворимо',
        '—': 'Разлагается водой или не существует',
        'R': 'Растворимо',
        'N': 'Нерастворимо',
        'M': 'Малорастворимо',
        'D': 'Разлагается водой или не существует',
        'O': 'Особый случай'
    };

    return {
        symbol: solubility,
        description: descriptions[solubility] || 'Нет данных'
    };
}

// Получение цвета вещества
function getSubstanceColor(cationFormula, anionFormula) {
    const key = `${normalizeFormula(cationFormula)}-${normalizeFormula(anionFormula)}`;
    return substanceColors[key] || null;
}

// === SVG ГЕНЕРАТОРЫ ===

function lightenColor(hex, percent) {
    if (!hex || hex === 'colorless') return 'rgb(255,255,255)';
    if (hex === 'white') return 'rgb(255,255,255)';

    // Поддержка rgb() формата
    if (hex.startsWith('rgb')) {
        const match = hex.match(/(\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            const R = Math.min(255, parseInt(match[1]) + Math.round(2.55 * percent));
            const G = Math.min(255, parseInt(match[2]) + Math.round(2.55 * percent));
            const B = Math.min(255, parseInt(match[3]) + Math.round(2.55 * percent));
            return `rgb(${R},${G},${B})`;
        }
    }

    // HEX формат
    const num = parseInt(hex.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    return `#${((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1)}`;
}

function darkenColor(hex, percent) {
    if (!hex || hex === 'colorless') return 'rgb(200,200,200)';
    if (hex === 'white') return 'rgb(220,220,220)';

    // Поддержка rgb() формата
    if (hex.startsWith('rgb')) {
        const match = hex.match(/(\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            const R = Math.max(0, parseInt(match[1]) - Math.round(2.55 * percent));
            const G = Math.max(0, parseInt(match[2]) - Math.round(2.55 * percent));
            const B = Math.max(0, parseInt(match[3]) - Math.round(2.55 * percent));
            return `rgb(${R},${G},${B})`;
        }
    }

    // HEX формат
    const num = parseInt(hex.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max(0, (num >> 16) - amt);
    const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
    const B = Math.max(0, (num & 0x0000FF) - amt);
    return `#${((1 << 24) + (R << 16) + (G << 8) + B).toString(16).slice(1)}`;
}

function generateCrystalSVG(color, size = 120) {
    // Цвет слитка
    const fillColor = color || '#ffffff';

    // Вычисляем оттенки для 3D-эффекта
    const topColor = lightenColor(fillColor, 25);      // Верхняя грань (светлая)
    const frontColor = fillColor;                       // Передняя грань (основной)
    const rightColor = darkenColor(fillColor, 20);     // Правая грань (тёмная)
    const strokeColor = darkenColor(fillColor, 40);    // Обводка

    return `
    <svg width="${size}" height="${size}" viewBox="0 0 100 100">
        <defs>
            <!-- Градиент для верхней грани -->
            <linearGradient id="topGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:${lightenColor(topColor, 10)}" />
                <stop offset="100%" style="stop-color:${topColor}" />
            </linearGradient>
            <!-- Градиент для передней грани -->
            <linearGradient id="frontGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${lightenColor(frontColor, 5)}" />
                <stop offset="100%" style="stop-color:${darkenColor(frontColor, 10)}" />
            </linearGradient>
        </defs>

        <!-- MINECRAFT-STYLE INGOT (слиток) -->

        <!-- Верхняя грань (трапеция) -->
        <polygon
            points="20,30 45,20 80,30 55,40"
            fill="url(#topGrad)"
            stroke="${strokeColor}"
            stroke-width="1.5"
        />

        <!-- Передняя грань (параллелограмм) -->
        <polygon
            points="20,30 55,40 55,75 20,65"
            fill="url(#frontGrad)"
            stroke="${strokeColor}"
            stroke-width="1.5"
        />

        <!-- Правая грань (параллелограмм) -->
        <polygon
            points="55,40 80,30 80,65 55,75"
            fill="${rightColor}"
            stroke="${strokeColor}"
            stroke-width="1.5"
        />

        <!-- Блик на верхней грани -->
        <polygon
            points="25,31 42,23 52,28 35,36"
            fill="white"
            opacity="0.3"
        />

        <!-- Блик на передней грани -->
        <rect x="24" y="35" width="8" height="20" rx="2" fill="white" opacity="0.15"/>
    </svg>`;
}

function isTransparentAppearanceColor(color) {
    if (!color) return false;

    const normalizedColor = String(color).trim().toLowerCase();
    return normalizedColor === 'colorless' ||
        normalizedColor === 'transparent' ||
        normalizedColor === 'rgba(0,0,0,0)' ||
        normalizedColor === 'rgba(0, 0, 0, 0)' ||
        normalizedColor.includes('\u0431\u0435\u0441\u0446\u0432\u0435\u0442') ||
        normalizedColor.includes('\u043f\u0440\u043e\u0437\u0440\u0430\u0447');
}

function generateFlaskSVG(color, solubility, size = 120, forceTransparent = false) {
    // Определяем цвет раствора
    let solutionColor;
    let solutionOpacity;
    const isTransparentColor = forceTransparent ||
        isTransparentAppearanceColor(color) ||
        color === '#ffffff' ||
        color === '#FFFFFF' ||
        color === 'white';

    if (!color || isTransparentColor) {
        // Transparent/colorless solutions are shown as light gray glass
        solutionColor = '#dce2e9';
        solutionOpacity = 0.42;
    } else {
        // Цветной раствор — используем цвет вещества
        solutionColor = color;
        solutionOpacity = 0.5;
    }

    // Для малорастворимых — добавляем муть
    if (solubility === 'М' || solubility === 'M') {
        solutionOpacity = 0.25; // Более прозрачный, но с осадком внизу
    }

    const particleColor = isTransparentColor ? '#c5ced8' : (color || '#888');

    // Частицы осадка для малорастворимых
    const particles = (solubility === 'М' || solubility === 'M') ? `
        <circle cx="35" cy="82" r="3" fill="${particleColor}" opacity="0.7"/>
        <circle cx="50" cy="85" r="2" fill="${particleColor}" opacity="0.8"/>
        <circle cx="62" cy="83" r="2.5" fill="${particleColor}" opacity="0.6"/>
        <circle cx="42" cy="86" r="1.5" fill="${particleColor}" opacity="0.9"/>
    ` : '';

    const transparentLiquidEffects = isTransparentColor ? `
        <path
            d="M31,52 Q50,46 69,52"
            fill="none"
            stroke="rgba(255,255,255,0.6)"
            stroke-width="2"
            stroke-linecap="round"
        />
        <ellipse cx="50" cy="70" rx="20" ry="8" fill="rgba(255,255,255,0.2)"/>
    ` : '';

    return `
    <svg width="${size}" height="${size}" viewBox="0 0 100 100">
        <!-- Колба (контур) -->
        <path
            d="M38,32 L38,12 L42,8 L58,8 L62,12 L62,32 L78,68 Q82,88 50,92 Q18,88 22,68 Z"
            fill="rgba(240,248,255,0.3)"
            stroke="#666"
            stroke-width="2"
        />

        <!-- Раствор (жидкость) -->
        <path
            d="M39,45 L39,32 L61,32 L61,45 L76,68 Q80,86 50,90 Q20,86 24,68 Z"
            fill="${solutionColor}"
            opacity="${solutionOpacity}"
        />

        ${transparentLiquidEffects}

        <!-- Блик на стекле -->
        <path
            d="M26,55 Q22,45 32,38"
            fill="none"
            stroke="white"
            stroke-width="3"
            opacity="0.6"
            stroke-linecap="round"
        />

        <!-- Уровень жидкости (мениск) -->
        <ellipse cx="50" cy="45" rx="22" ry="3" fill="${solutionColor}" opacity="${solutionOpacity + 0.1}"/>

        <!-- Частицы осадка (для малорастворимых) -->
        ${particles}

        <!-- Пробка -->
        <rect x="40" y="3" width="20" height="8" rx="2" fill="#CD853F"/>
        <rect x="40" y="3" width="20" height="3" rx="1" fill="#DEB887"/>
    </svg>`;
}

// === РЕНДЕРИНГ ===

function renderAdvancedContent(cationFormula, anionFormula) {
    const formula = generateFormula(cationFormula, anionFormula);
    const name = generateSubstanceName(cationFormula, anionFormula) || formula;
    const mass = calculateMolarMass(formula);
    const solubility = getSolubilityInfo(cationFormula, anionFormula);
    const color = getSubstanceColor(cationFormula, anionFormula);

    const decompositionKey = `${normalizeFormula(cationFormula)}-${normalizeFormula(anionFormula)}`;
    const decomposition = window.decompositionReactions?.[decompositionKey];
    const noDecompositionClass = decomposition ? '' : ' no-decomposition';

    advancedModalContent.innerHTML = `
        <!-- Заголовок -->
        <div class="advanced-header">
            <div class="advanced-title-group">
                <h2>${formula}</h2>
                <p class="substance-name">${name}</p>
            </div>
        </div>

        <!-- Вкладки -->
        <div class="advanced-tabs">
            <button class="tab-btn active" onclick="switchAdvancedTab('info')">📊 Информация</button>
            <button class="tab-btn" onclick="switchAdvancedTab('appearance')">🎨 Внешний вид</button>
        </div>

        <!-- Контент вкладок -->
        <div class="advanced-content${noDecompositionClass}">
            <div id="tab-info" class="tab-pane active">
                ${renderInfoTab(formula, name, mass, solubility, color, decomposition)}
            </div>
            <div id="tab-appearance" class="tab-pane" style="display:none;">
                ${renderAppearanceTab(color, solubility, decomposition)}
            </div>
        </div>
    `;
}

function renderInfoTab(formula, name, mass, solubility, color, decomposition) {
    const colorName = color ? getColorName(color) : 'неизвестен';

    return `
        <h3>Основная информация</h3>
        <div class="info-grid">
            <div class="info-item">
                <span class="label">Формула:</span>
                <span class="value">${formula}</span>
            </div>
            <div class="info-item">
                <span class="label">Название:</span>
                <span class="value">${name}</span>
            </div>
            <div class="info-item">
                <span class="label">Молярная масса:</span>
                <span class="value">${mass} г/моль</span>
            </div>
            <div class="info-item">
                <span class="label">Растворимость:</span>
                <span class="value solubility-badge solubility-${solubility.symbol}">
                    ${solubility.symbol} — ${solubility.description}
                </span>
            </div>
            ${color ? `
                <div class="info-item">
                    <span class="label">Цвет:</span>
                    <span class="value">${colorName}</span>
                </div>
            ` : ''}
        </div>

        ${decomposition ? `
            <h3>Реакция разложения</h3>
            <div class="decomposition-section">
                <div class="reaction-equation">${decomposition.equation}</div>
                <p class="reaction-description">${decomposition.description}</p>
            </div>
        ` : ''}
    `;
}

function renderAppearanceTab(color, solubility, decomposition) {
    // Если вещество разлагается (— или D)
    if (solubility.symbol === '—' || solubility.symbol === 'D') {
        return `
            <div class="decomposition-notice">
                <h3>⚠️ Вещество неустойчиво</h3>
                <p>Данное вещество разлагается водой или не существует в обычных условиях.</p>
                ${decomposition ? `
                    <div class="decomposition-info">
                        <strong>Реакция:</strong> ${decomposition.equation}<br>
                        <strong>Описание:</strong> ${decomposition.description}
                    </div>
                ` : ''}
            </div>
        `;
    }

    const isTransparentColor = isTransparentAppearanceColor(color);
    const displayColor = isTransparentColor ? '#d6dce3' : (color || '#ffffff');
    const appearanceContainerClass = isTransparentColor
        ? 'appearance-container appearance-container-transparent'
        : 'appearance-container';
    const visualItemClass = isTransparentColor
        ? 'visual-item visual-item-transparent'
        : 'visual-item';

    let content = `<div class="${appearanceContainerClass}">`;

    // Для нерастворимых — только кристалл
    if (solubility.symbol === 'Н' || solubility.symbol === 'N') {
        content += `
            <div class="${visualItemClass}">
                <h4>Твёрдое вещество</h4>
                ${generateCrystalSVG(displayColor, 150)}
                <p class="visual-caption">Кристаллы / Осадок</p>
            </div>
        `;
    } else {
        // Для растворимых и малорастворимых — кристалл + колба
        content += `
            <div class="${visualItemClass}">
                <h4>Твёрдое вещество</h4>
                ${generateCrystalSVG(displayColor, 120)}
                <p class="visual-caption">Кристаллы</p>
            </div>
            <div class="${visualItemClass}">
                <h4>Раствор</h4>
                ${generateFlaskSVG(displayColor, solubility.symbol, 120, isTransparentColor)}
                <p class="visual-caption">${solubility.description}</p>
            </div>
        `;
    }

    content += '</div>';
    return content;
}

function getColorName(colorHex) {
    const colorNames = {
        'white': 'Белый',
        'colorless': 'Бесцветный',
        '#ffffff': 'Белый',
        '#fffacd': 'Бледно-жёлтый',
        '#ffd700': 'Золотисто-жёлтый',
        '#ff4500': 'Красный',
        '#ffff00': 'Жёлтый',
        '#ffa500': 'Оранжевый',
        '#8b0000': 'Тёмно-красный',
        '#ff8c00': 'Оранжевый',
        '#dc143c': 'Малиновый',
        '#cd853f': 'Жёлто-бурый',
        '#87ceeb': 'Голубой',
        '#48d1cc': 'Сине-зелёный',
        '#228b22': 'Зелёный',
        '#90ee90': 'Светло-зелёный',
        '#7fffd4': 'Серо-зелёный',
        '#8b4513': 'Бурый',
        '#ff69b4': 'Розовый',
        '#ffb6c1': 'Бледно-розовый',
        '#8b008b': 'Фиолетовый',
        '#000000': 'Чёрный',
        '#98fb98': 'Бледно-зелёный',
        '#778899': 'Серо-зелёный'
    };

    return colorNames[colorHex] || colorHex;
}

function switchAdvancedTab(tabName) {
    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-pane').forEach(pane => pane.style.display = 'none');

    event.target.classList.add('active');
    document.getElementById(`tab-${tabName}`).style.display = 'block';
}

// Закрытие модального окна при клике вне его
window.addEventListener('click', (event) => {
    if (event.target === advancedModal) {
        closeAdvancedModal();
    }
});

// Инициализация при загрузке
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAdvancedModeButton);
} else {
    initAdvancedModeButton();
}



============================================================
ФАЙЛ: .\js\solubility\colors.js
============================================================

// =========================================
// ФУНКЦИИ РАБОТЫ С ЦВЕТАМИ
// =========================================

// Используем глобальную переменную для состояния режима цвета
console.log('Initial check of window.isColorMode at script load:', typeof window.isColorMode, window.isColorMode);

// Проверяем, есть ли сохраненное значение в localStorage
const savedColorMode = localStorage.getItem('solubilityColorMode');
if (savedColorMode !== null) {
    window.isColorMode = savedColorMode === 'true';
    console.log('Loaded window.isColorMode from localStorage:', window.isColorMode);
} else if (typeof window.isColorMode === 'undefined') {
    window.isColorMode = false;
    console.log('Initialized window.isColorMode to false');
} else {
    console.log('window.isColorMode already exists with value:', window.isColorMode);
}
console.log('Final value of window.isColorMode at script load:', window.isColorMode);

// Убедимся, что переменная доступна глобально
window.isColorMode = window.isColorMode || false;
console.log('Ensured window.isColorMode is set to:', window.isColorMode);

function syncColorModeButtonState() {
    const btn = document.getElementById('color-mode-btn');
    if (!btn) return;

    const isActive = Boolean(window.isColorMode);
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', syncColorModeButtonState);
} else {
    syncColorModeButtonState();
}

// Добавить в глобальную область видимости (например, в начало advanced-modal.js)
function normalizeFormula(formula) {
    return formula
        .replace(/⁺/g, '+')
        .replace(/⁻/g, '-')
        // Надстрочные цифры (для степеней окисления)
        .replace(/⁰/g, '0')
        .replace(/¹/g, '1')
        .replace(/²/g, '2')
        .replace(/³/g, '3')
        .replace(/⁴/g, '4')
        .replace(/⁵/g, '5')
        .replace(/⁶/g, '6')
        .replace(/⁷/g, '7')
        .replace(/⁸/g, '8')
        .replace(/⁹/g, '9')
        // Подстрочные цифры (для индексов)
        .replace(/₀/g, '0')
        .replace(/₁/g, '1')
        .replace(/₂/g, '2')
        .replace(/₃/g, '3')
        .replace(/₄/g, '4')
        .replace(/₅/g, '5')
        .replace(/₆/g, '6')
        .replace(/₇/g, '7')
        .replace(/₈/g, '8')
        .replace(/₉/g, '9');
}
window.normalizeFormula = normalizeFormula; // Делаем доступной везде

// Определяем, тёмный ли цвет (для выбора цвета текста)
function isColorDark(hexColor) {
    if (!hexColor || hexColor.length < 7) return false;

    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);

    // Формула относительной яркости (luminance)
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

    return luminance < 0.5;
}

// Переключение режима цветов
function toggleColorMode() {
    console.log('toggleColorMode called, current window.isColorMode:', window.isColorMode);
    window.isColorMode = !window.isColorMode;
    console.log('window.isColorMode after toggle:', window.isColorMode);

    // Сохраняем состояние в localStorage
    localStorage.setItem('solubilityColorMode', window.isColorMode);
    console.log('Saved window.isColorMode to localStorage:', window.isColorMode);

    syncColorModeButtonState();
    console.log('Synchronized button active state');

    // Перерисовываем таблицу
    renderSolubilityTable();
    console.log('Table re-rendered');

    // Обновляем фильтры в зависимости от режима
    if (typeof updateFiltersForSolubility === 'function') {
        console.log('Calling updateFiltersForSolubility');
        updateFiltersForSolubility();
    } else {
        console.error('updateFiltersForSolubility function not found');
    }
}

// Функция для конвертации цвета в русское название
function getColorName(color) {
    if (!color) return 'Неизвестный';

    color = color.toLowerCase().trim();

    // Словарь распространённых значений
    const colorNames = {
        'colorless': 'Бесцветный',
        'бесцветный': 'Бесцветный',
        'white': 'Белый',
        'белый': 'Белый',
        'black': 'Чёрный',
        'чёрный': 'Чёрный',
        'красный': 'Красный',
        'синий': 'Синий',
        'зелёный': 'Зелёный',
        'жёлтый': 'Жёлтый',
        'коричневый': 'Коричневый',
        'фиолетовый': 'Фиолетовый',
        'оранжевый': 'Оранжевый',
        'розовый': 'Розовый',
        'голубой': 'Голубой',
        'серый': 'Серый'
    };

    // Проверяем прямое совпадение
    if (colorNames[color]) return colorNames[color];

    // Если это HEX код, конвертируем в название
    if (color.startsWith('#')) {
        // Простое определение по популярным HEX кодам
        const hexMap = {
            '#ffffff': 'Белый',
            '#000000': 'Чёрный',
            '#ff0000': 'Красный',
            '#0000ff': 'Синий',
            '#00ff00': 'Зелёный',
            '#ffff00': 'Жёлтый',
            '#ffa500': 'Оранжевый',
            '#800080': 'Фиолетовый',
            '#ffc0cb': 'Розовый',
            '#808080': 'Серый',
            '#8b4513': 'Коричневый',
            '#fffdd0': 'Кремовый',
            '#fff9b0': 'Бледно-жёлтый',
            '#7fbf7f': 'Зелёный',
            '#6aa9ff': 'Голубой',
            '#48d1cc': 'Сине-зелёный',
            '#50c878': 'Зелёный',
            '#8a2be2': '\u0424\u0438\u043e\u043b\u0435\u0442\u043e\u0432\u044b\u0439'
        };

        if (hexMap[color]) return hexMap[color];

        // Приблизительное определение цвета
        const rgb = hexToRgb(color);
        if (rgb) {
            return approximateColorByRGB(rgb);
        }
    }

    // Если не смогли определить, возвращаем оригинал с заглавной
    return color.charAt(0).toUpperCase() + color.slice(1);
}

// Функция для группировки цветов по общим категориям
function getGroupedColorName(color) {
    if (!color) return 'Неизвестный';

    color = color.toLowerCase().trim();

    // Определяем общую категорию цвета
    if (color === 'colorless' || color === 'бесцветный' ||
        color === 'white' || color === 'белый' ||
        color === '#ffffff') {
        return 'Белый/Бесцветный';
    } else if (color === 'black' || color === 'чёрный' ||
               color === '#000000') {
        return 'Чёрный';
    } else if (color === 'red' || color === 'красный' ||
               color === '#ff0000' ||
               color.includes('красн') || color.includes('алый') ||
               color.includes('борд') || color.includes('малин')) {
        return 'Красный';
    } else if (color === 'blue' || color === 'синий' ||
               color === '#0000ff' ||
               color.includes('син') || color.includes('лазур') ||
               color.includes('голуб') || color.includes('бирюз')) {
        return 'Синий/Голубой';
    } else if (color === 'green' || color === 'зелёный' ||
               color === '#00ff00' ||
               color.includes('зелен') || color.includes('салат')) {
        return 'Зелёный';
    } else if (color === 'yellow' || color === 'жёлтый' ||
               color === '#ffff00' ||
               color.includes('желт') || color.includes('золот') ||
               color === 'orange' || color === 'оранжевый' ||
               color === '#ffa500' || color.includes('оранж')) {
        return 'Жёлтый/Оранжевый';
    } else if (color === 'purple' || color === 'фиолетовый' ||
               color === '#800080' || color.includes('фиолет') ||
               color.includes('пурп') || color.includes('лилов') ||
               color.includes('сирен')) {
        return 'Фиолетовый';
    } else if (color === 'pink' || color === 'розовый' ||
               color === '#ffc0cb' || color.includes('розов') ||
               color.includes('мagenta') || color.includes('фукс')) {
        return 'Розовый/Красноватый';
    } else if (color === 'brown' || color === 'коричневый' ||
               color === '#8b4513' || color.includes('коричн') ||
               color.includes('бур') || color.includes('каштан') ||
               color.includes('шоколад') || color.includes('кофейн')) {
        return 'Коричневый/Бурый';
    } else if (color === 'gray' || color === 'grey' || color === 'серый' ||
               color === '#808080' || color.includes('сер')) {
        return 'Серый';
    } else {
        // Если это HEX код, используем приближенное определение
        if (color.startsWith('#')) {
            const rgb = hexToRgb(color);
            if (rgb) {
                return approximateGroupedColorByRGB(rgb);
            }
        }

        // Попробуем определить по названию
        return approximateGroupedColorByName(color);
    }
}

// Приблизительное определение обобщенной категории по RGB
function approximateGroupedColorByRGB(rgb) {
    const { r, g, b } = rgb;

    // Белый/бесцветный
    if (r > 240 && g > 240 && b > 240) return 'Белый/Бесцветный';

    // Чёрный
    if (r < 30 && g < 30 && b < 30) return 'Чёрный';

    // Серый
    if (Math.abs(r - g) < 40 && Math.abs(g - b) < 40 && Math.abs(r - b) < 40) {
        if (r < 100) return 'Чёрный';
        else if (r > 200) return 'Белый/Бесцветный';
        else return 'Серый';
    }

    // Красный
    if (r > g + 50 && r > b + 50) return 'Красный';

    // Синий
    if (b > r + 50 && b > g + 50) return 'Синий/Голубой';

    // Зелёный
    if (g > r + 50 && g > b + 50) return 'Зелёный';

    // Жёлтый (высокие значения r и g, но низкое b)
    if (r > 200 && g > 200 && b < 100) return 'Жёлтый/Оранжевый';

    // Оранжевый (высокое r, среднее g, низкое b)
    if (r > 200 && g > 100 && g < 200 && b < 100) return 'Жёлтый/Оранжевый';

    // Фиолетовый (высокие r и b, низкое g)
    if (r > 100 && b > 100 && g < 100) return 'Фиолетовый';

    // Розовый (высокие r и b, среднее g)
    if (r > 200 && b > 150 && g < 200) return 'Розовый/Красноватый';

    // Коричневый (высокое r, среднее g, низкое b)
    if (r > 100 && g > 50 && b < 100) return 'Коричневый/Бурый';

    return 'Разноцветный';
}

// Приблизительное определение обобщенной категории по названию
function approximateGroupedColorByName(colorName) {
    // Проверяем наличие ключевых слов в названии цвета
    if (colorName.includes('бел') || colorName.includes('бесцв') ||
        colorName.includes('transparent') || colorName.includes('colorless')) {
        return 'Белый/Бесцветный';
    } else if (colorName.includes('чёрн') || colorName.includes('черн') ||
               colorName.includes('black')) {
        return 'Чёрный';
    } else if (colorName.includes('красн') || colorName.includes('алый') ||
               colorName.includes('борд') || colorName.includes('малин') ||
               colorName.includes('red')) {
        return 'Красный';
    } else if (colorName.includes('син') || colorName.includes('лазур') ||
               colorName.includes('голуб') || colorName.includes('бирюз') ||
               colorName.includes('blue')) {
        return 'Синий/Голубой';
    } else if (colorName.includes('зелен') || colorName.includes('салат') ||
               colorName.includes('green')) {
        return 'Зелёный';
    } else if (colorName.includes('желт') || colorName.includes('золот') ||
               colorName.includes('yellow') || colorName.includes('оранж') ||
               colorName.includes('orange')) {
        return 'Жёлтый/Оранжевый';
    } else if (colorName.includes('фиолет') || colorName.includes('пурп') ||
               colorName.includes('лилов') || colorName.includes('сирен') ||
               colorName.includes('purple') || colorName.includes('violet')) {
        return 'Фиолетовый';
    } else if (colorName.includes('розов') || colorName.includes('magenta') ||
               colorName.includes('фукс') || colorName.includes('pink')) {
        return 'Розовый/Красноватый';
    } else if (colorName.includes('коричн') || colorName.includes('бур') ||
               colorName.includes('каштан') || colorName.includes('шоколад') ||
               colorName.includes('кофейн') || colorName.includes('brown')) {
        return 'Коричневый/Бурый';
    } else if (colorName.includes('сер') || colorName.includes('gray') ||
               colorName.includes('grey')) {
        return 'Серый';
    } else {
        return 'Разноцветный';
    }
}

// Улучшенная функция для определения приблизительного цвета по RGB
function approximateColorByRGB(rgb) {
    const { r, g, b } = rgb;

    // Определяем доминирующий цветовой канал
    const maxVal = Math.max(r, g, b);
    const minVal = Math.min(r, g, b);
    const delta = maxVal - minVal;

    // Если дельта мала, цвет ближе к оттенкам серого
    if (delta < 30) {
        if (maxVal < 50) return 'Чёрный';
        else if (maxVal < 100) return 'Тёмно-серый';
        else if (maxVal < 180) return 'Серый';
        else return 'Светло-серый';
    }

    // Определяем основной цвет
    if (maxVal === r && r > g && r > b) {
        // Красный доминирует
        if (delta > 100) {
            if (g > b) return 'Коричневый';
            else return 'Красный';
        } else {
            return 'Красный';
        }
    } else if (maxVal === g && g > r && g > b) {
        // Зелёный доминирует
        if (delta > 100) return 'Зелёный';
        else return 'Салатовый';
    } else if (maxVal === b && b > r && b > g) {
        // Синий доминирует
        if (delta > 100) return 'Синий';
        else return 'Голубой';
    }

    // Комбинации
    if (r > 200 && g > 200 && b < 100) return 'Жёлтый';
    if (r > 200 && g > 100 && b < 100) return 'Оранжевый';
    if (r > 150 && b > 150 && g < 100) return 'Фиолетовый';
    if (r > 200 && b > 150 && g < 200) return 'Розовый';

    // Если ничего не подошло, возвращаем общий цвет на основе яркости
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    if (brightness > 180) return 'Светлый';
    else if (brightness > 100) return 'Нейтральный';
    else return 'Тёмный';
}


function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}


// Получить уникальные цвета из текущей таблицы
function getUniqueColorsFromTable() {
    console.log('getUniqueColorsFromTable called');
    const colorMap = new Map(); // groupedColorName -> {name, originalColors[]}

    // Проходим по всем данным напрямую из solubilityData
    solubilityData.anions.forEach((anion, anionIndex) => {
        solubilityData.cations.forEach((cation, cationIndex) => {
            // Пропускаем H⁺ (первый катион)
            if (cationIndex === 0) return;

            const catKey = normalizeFormula(cation.f);
            const anionKey = normalizeFormula(anion.f);
            const colorKey = `${catKey}-${anionKey}`;

            const substanceColor = substanceColors[colorKey];

            if (substanceColor) {
                console.log('Found substance color for key:', colorKey, 'color:', substanceColor);

                // Нормализуем цвет с помощью getGroupedColorName для группировки
                const colorName = getGroupedColorName(substanceColor);
                console.log('Grouped color name for', substanceColor, 'is', colorName);

                // Получаем или создаем массив оригинальных цветов для нормализованного имени
                if (!colorMap.has(colorName)) {
                    colorMap.set(colorName, []);
                }

                // Добавляем оригинальный цвет в массив, если его там ещё нет
                const originalColorsArray = colorMap.get(colorName);
                if (!originalColorsArray.includes(substanceColor)) {
                    originalColorsArray.push(substanceColor);
                }
            }
        });
    });

    console.log('Before deduplication, colorMap has', colorMap.size, 'entries');

    // Возвращаем массив объектов {name, originalColors}
    const result = [];
    colorMap.forEach((originalColors, name) => {
        result.push({ name, originalColors });
    });

    // Сортируем по названию
    result.sort((a, b) => a.name.localeCompare(b.name, 'ru'));

    console.log('getUniqueColorsFromTable returning:', result);
    console.log('Total unique color names:', result.length);

    return result;
}

// Переключение между металлами и неметаллами
function toggleNonmetalsSeries() {
    const metalsContainer = document.getElementById('metals-series');
    const nonmetalsContainer = document.getElementById('nonmetals-series');
    const title = document.getElementById('activity-title');
    const toggleBtn = document.getElementById('toggle-nonmetals-btn');

    if (!metalsContainer || !nonmetalsContainer || !title || !toggleBtn) return;

    // Переключаем активный контейнер
    if (metalsContainer.classList.contains('active')) {
        // Переход к неметаллам
        metalsContainer.classList.remove('active');
        nonmetalsContainer.classList.add('active');
        title.textContent = 'Ряд активности неметаллов';
        toggleBtn.textContent = 'Переключить на металлы';
    } else {
        // Переход к металлам
        nonmetalsContainer.classList.remove('active');
        metalsContainer.classList.add('active');
        title.textContent = 'Ряд активности металлов';
        toggleBtn.textContent = 'Переключить на неметаллы';
    }
}


============================================================
ФАЙЛ: .\js\solubility\data.js
============================================================

// =========================================
// ДАННЫЕ ТАБЛИЦЫ РАСТВОРИМОСТИ
// =========================================

// =========================================
// РЕАЛЬНЫЕ ЦВЕТА ВЕЩЕСТВ
// =========================================
const substanceColors = {
    // =============================================
    // БЕЛЫЕ ОСАДКИ (white)
    // =============================================
    // Галогениды
    "Ag+-Cl-": "white",           // AgCl - белый творожистый
    "Pb2+-Cl-": "white",          // PbCl₂ - белый
    "Pb2+-Br-": "white",          // PbBr₂ - белый


    // Сульфаты
    "Ba2+-SO42-": "white",        // BaSO₄ - белый (барит)
    "Pb2+-SO42-": "white",        // PbSO₄ - белый
    "Ca2+-SO42-": "white",        // CaSO₄ - белый (гипс)
    "Sr2+-SO42-": "white",        // SrSO₄ - белый
    "Ag+-SO42-": "white",         // Ag₂SO₄ - белый

    // Карбонаты
    "Ca2+-CO32-": "white",        // CaCO₃ - белый (мел, мрамор)
    "Ba2+-CO32-": "white",        // BaCO₃ - белый
    "Mg2+-CO32-": "white",        // MgCO₃ - белый
    "Sr2+-CO32-": "white",        // SrCO₃ - белый
    "Pb2+-CO32-": "white",        // PbCO₃ - белый
    "Zn2+-CO32-": "white",        // ZnCO₃ - белый

    // Фосфаты
    "Ca2+-PO43-": "white",        // Ca₃(PO₄)₂ - белый
    "Ba2+-PO43-": "white",        // Ba₃(PO₄)₂ - белый
    "Mg2+-PO43-": "white",        // Mg₃(PO₄)₂ - белый
    "Zn2+-PO43-": "white",        // Zn₃(PO₄)₂ - белый
    "Pb2+-PO43-": "white",        // Pb₃(PO₄)₂ - белый
    "Al3+-PO43-": "white",        // AlPO₄ - белый

    // Силикаты
    "Ca2+-SiO32-": "white",       // CaSiO₃ - белый
    "Ba2+-SiO32-": "white",       // BaSiO₃ - белый
    "Mg2+-SiO32-": "white",       // MgSiO₃ - белый
    "Zn2+-SiO32-": "white",       // ZnSiO₃ - белый

    // Сульфиты
    "Ca2+-SO32-": "white",        // CaSO₃ - белый
    "Ba2+-SO32-": "white",        // BaSO₃ - белый
    "Pb2+-SO32-": "white",        // PbSO₃ - белый

    // Гидроксиды белые
    "Al3+-OH-": "white",          // Al(OH)₃ - белый студенистый
    "Zn2+-OH-": "white",          // Zn(OH)₂ - белый
    "Mg2+-OH-": "white",          // Mg(OH)₂ - белый
    "Ca2+-OH-": "white",          // Ca(OH)₂ - белый (известь)
    "Ba2+-OH-": "white",          // Ba(OH)₂ - белый
    "Sn2+-OH-": "white",          // Sn(OH)₂ - белый

    // Сульфид цинка
    "Zn2+-S2-": "white",          // ZnS - белый/серовато‑белый/желтоватый осадок

    // Фториды
    "Ca2+-F-": "white",           // CaF₂ - белый (флюорит)
    "Ba2+-F-": "white",           // BaF₂ - белый
    "Mg2+-F-": "white",           // MgF₂ - белый
    "Sr2+-F-": "white",           // SrF₂ - белый
    "Pb2+-F-": "white",           // PbF₂ - белый

    // =============================================
    // БЕСЦВЕТНЫЕ РАСТВОРЫ (colorless)
    // =============================================
    // Нитраты (все растворимы и бесцветны, кроме окрашенных катионов)
    "Na+-NO3-": "colorless",
    "K+-NO3-": "colorless",
    "Ca2+-NO3-": "colorless",
    "Ba2+-NO3-": "colorless",
    "Mg2+-NO3-": "colorless",
    "Zn2+-NO3-": "colorless",
    "Pb2+-NO3-": "colorless",
    "Al3+-NO3-": "colorless",
    "Ag+-NO3-": "colorless",

    // Хлориды растворимые
    "Na+-Cl-": "colorless",
    "K+-Cl-": "colorless",
    "Ca2+-Cl-": "colorless",
    "Ba2+-Cl-": "colorless",
    "Mg2+-Cl-": "colorless",
    "Zn2+-Cl-": "colorless",
    "Al3+-Cl-": "colorless",

    // Сульфаты растворимые
    "Na+-SO42-": "colorless",
    "K+-SO42-": "colorless",
    "Mg2+-SO42-": "colorless",
    "Zn2+-SO42-": "colorless",
    "Al3+-SO42-": "colorless",

    // Ацетаты
    "Na+-CH3COO-": "colorless",
    "K+-CH3COO-": "colorless",
    "Ca2+-CH3COO-": "colorless",
    "Ba2+-CH3COO-": "colorless",
    "Mg2+-CH3COO-": "colorless",
    "Zn2+-CH3COO-": "colorless",
    "Pb2+-CH3COO-": "colorless",
    "Al3+-CH3COO-": "colorless",

    // =============================================
    // ЖЁЛТЫЕ И ОРАНЖЕВЫЕ
    // =============================================
    "Ag+-Br-": "#fffdd0",         // AgBr - кремовый осадок
    "Ag+-I-": "#fff9b0",          // AgI - бледно‑жёлтый осадок
    "Pb2+-I-": "#ffd700",         // PbI₂ - ярко-жёлтый ("золотой дождь")
    "Hg2+-I-": "#ff4500",         // HgI₂ - красный (алый)
    "Ag+-PO43-": "#ffff00",       // Ag₃PO₄ - жёлтый
    "Cd2+-S2-": "#ffff00",        // CdS - жёлтый осадок (cadmium yellow)

    // Хроматы
    "Ba2+-CrO42-": "#ffff00",     // BaCrO₄ - ярко‑жёлтый (barium yellow)
    "Pb2+-CrO42-": "#ffff00",     // PbCrO₄ - ярко‑жёлтый (chrome yellow)
    "Sr2+-CrO42-": "#fff9b0",     // SrCrO₄ - бледно‑жёлтый осадок
    "Ca2+-CrO42-": "#ffff00",     // CaCrO₄ - жёлтый
    "Ag+-CrO42-": "#8b0000",      // Ag₂CrO₄ - кирпично‑красный

    // Дихроматы (оранжевые растворы/осадки)
    "K+-Cr2O72-": "#ff8c00",      // K₂Cr₂O₇ - оранжевый раствор
    "Na+-Cr2O72-": "#ff8c00",     // Na₂Cr₂O₇ - оранжевый раствор
    "NH4+-Cr2O72-": "#ff8c00",    // (NH₄)₂Cr₂O₇ - оранжевый раствор
    "Ag+-Cr2O72-": "#dc143c",     // Ag₂Cr₂O₇ - рубиново‑красный
    "Pb2+-Cr2O72-": "#ff4500",    // PbCr₂O₇ - малорастворимый оранжево-красный

    // Соли железа(III) - желто-бурые из-за гидролиза
    "Fe3+-Cl-": "#cd853f",        // FeCl₃·6H₂O - жёлтый, раствор жёлто-бурый
    "Fe3+-SO42-": "#cd853f",      // Fe₂(SO₄)₃ - жёлто-бурый (гидролиз)
    "Fe3+-NO3-": "#cd853f",       // Fe(NO₃)₃ - жёлто-бурый (гидролиз)

    // =============================================
    // ГОЛУБЫЕ И СИНИЕ
    // =============================================
    "Cu2+-OH-": "#87ceeb",        // Cu(OH)₂ - голубой/сине-зелёный осадок
    "Cu2+-SO42-": "#87ceeb",      // CuSO₄·5H₂O - голубой
    "Cu2+-NO3-": "#87ceeb",       // Cu(NO₃)₂·xH₂O - голубые/сине-зелёные кристаллы
    "Cu2+-Cl-": "#48d1cc",        // CuCl₂·2H₂O - сине-зелёный
    "Cu2+-CO32-": "#228b22",      // CuCO₃ - зелёный (малахит)

    // =============================================
    // ЗЕЛЁНЫЕ
    // =============================================
    "Fe2+-OH-": "#90ee90",        // Fe(OH)₂ - светло-зелёный осадок (быстро окисляется до бурого)
    "Ni2+-OH-": "#90ee90",        // Ni(OH)₂ - зелёный осадок
    "Ni2+-SO42-": "#48d1cc",      // NiSO₄·6H₂O - бирюзовые кристаллы
    "Ni2+-Cl-": "#90ee90",        // NiCl₂·6H₂O - зелёные кристаллы
    "Ni2+-NO3-": "#50c878",       // Ni(NO₃)₂·6H₂O - изумрудно‑зелёный
    "Cr3+-OH-": "#7fbf7f",        // Cr(OH)₃ - зелёный желатинозный осадок
    "Cr3+-Cl-": "#228b22",        // CrCl₃·6H₂O - тёмно-зелёный (гидрат)

    // =============================================
    // БУРЫЕ И КОРИЧНЕВЫЕ
    // =============================================
    "Fe3+-OH-": "#8b4513",        // Fe(OH)₃ - ржаво-бурый осадок
    "Sn2+-S2-": "#8b4513",        // SnS - коричневый

    // =============================================
    // РОЗОВЫЕ
    // =============================================
    "Co2+-OH-": "#6aa9ff",        // Co(OH)₂ - голубой осадок (α-форма, затем розовеет)
    "Co2+-Cl-": "#ff69b4",        // CoCl₂·6H₂O - розовый (гидрат)
    "Co2+-NO3-": "#ff69b4",       // Co(NO₃)₂·6H₂O - красно‑розовые кристаллы
    "Co2+-SO42-": "#ff69b4",      // CoSO₄·6H₂O - розовый (гидрат)
    "Mn2+-SO42-": "#ffb6c1",      // MnSO₄·H₂O - бледно-розовый
    "Mn2+-S2-": "#8b4513",        // MnS - бурый (вариабельный: красный/зелёный/бурый)

    // =============================================
    // ФИОЛЕТОВЫЕ
    // =============================================
    "K+-MnO4-": "#8b008b",        // KMnO₄ - тёмно-фиолетовый
    "Na+-MnO4-": "#8b008b",       // NaMnO₄ - тёмно-фиолетовый
    "Cr3+-SO42-": "#228b22",      // Cr₂(SO₄)₃ - зелёный (практический цвет)

    // =============================================
    // ЧЁРНЫЕ
    // =============================================
    "Ag+-S2-": "#000000",         // Ag₂S - серо‑чёрный осадок
    "Pb2+-S2-": "#000000",        // PbS - чёрный осадок (галенит)
    "Cu2+-S2-": "#000000",        // CuS - чёрный осадок
    "Fe2+-S2-": "#000000",        // FeS - чёрный/серый осадок
    "Ni2+-S2-": "#000000",        // NiS - чёрный осадок
    "Co2+-S2-": "#000000",        // CoS - чёрный осадок
    "Hg2+-S2-": "#000000",        // HgS - чёрный осадок (метациннабар)

    // =============================================
    // ДОПОЛНИТЕЛЬНЫЕ ЦВЕТНЫЕ СОЛИ
    // =============================================
    // Медь — голубые
    "Cu2+-CH3COO-": "#48d1cc",    // Cu(CH₃COO)₂·H₂O - сине‑зелёные/тёмно‑зелёные кристаллы
    "Cu2+-PO43-": "#87ceeb",      // Cu₃(PO₄)₂ - голубой

    // Никель — зелёные
    "Ni2+-CO32-": "#90ee90",      // NiCO₃ - зелёный
    "Ni2+-PO43-": "#90ee90",      // Ni₃(PO₄)₂ - зелёный
    "Ni2+-CH3COO-": "#90ee90",    // Ni(CH₃COO)₂ - зелёный

    // Кобальт — розовые
    "Co2+-CO32-": "#ff69b4",      // CoCO₃ - розовый
    "Co2+-PO43-": "#8a2be2",      // Co₃(PO₄)₂ - фиолетовый
    "Co2+-CH3COO-": "#ff69b4",    // Co(CH₃COO)₂ - розовый

    // Хром — зелёные (практический цвет)
    "Cr3+-NO3-": "#228b22",       // Cr(NO₃)₃ - зелёный (практический цвет)
    "Cr3+-CH3COO-": "#228b22",    // Cr(CH₃COO)₃ - зелёный

    // Железо(II) — бледно-зелёные
    "Fe2+-SO42-": "#98fb98",      // FeSO₄·7H₂O - бледно-зелёный
    "Fe2+-Cl-": "#98fb98",        // FeCl₂·4H₂O - зеленоватый, растворы бледно‑зелёные
    "Fe2+-NO3-": "#98fb98",       // Fe(NO₃)₂ - бледно-зелёный
    "Fe2+-CO32-": "#778899",      // FeCO₃ - серо-зелёный

    // Марганец — бледно-розовые (только растворимые!)
    "Mn2+-Cl-": "#ffb6c1",        // MnCl₂·4H₂O - розовые кристаллы
    "Mn2+-NO3-": "#ffb6c1",       // Mn(NO₃)₂ - бледно-розовый
    "Mn2+-CH3COO-": "#ffb6c1",    // Mn(CH₃COO)₂ - бледно-розовый
};

const solubilityData = {
    // 24 Катиона (Полный набор)
    cations: [
        { f: "H⁺", n: "Водород" },
        { f: "NH₄⁺", n: "Аммоний" },
        { f: "Li⁺", n: "Литий" },
        { f: "K⁺", n: "Калий" },
        { f: "Na⁺", n: "Натрий" },
        { f: "Rb⁺", n: "Рубидий" },
        { f: "Cs⁺", n: "Цезий" },
        { f: "Ag⁺", n: "Серебро" },
        { f: "Mg²⁺", n: "Магний" },
        { f: "Ca²⁺", n: "Кальций" },
        { f: "Sr²⁺", n: "Стронций" },
        { f: "Ba²⁺", n: "Барий" },
        { f: "Zn²⁺", n: "Цинк" },
        { f: "Hg²⁺", n: "Ртуть" },
        { f: "Pb²⁺", n: "Свинец" },
        { f: "Cu²⁺", n: "Медь" },
        { f: "Fe²⁺", n: "Железо(II)" },
        { f: "Fe³⁺", n: "Железо(III)" },
        { f: "Al³⁺", n: "Алюминий" },
        { f: "Cr³⁺", n: "Хром" },
        { f: "Mn²⁺", n: "Марганец" },
        { f: "Ni²⁺", n: "Никель" },
        { f: "Co²⁺", n: "Кобальт" },
        { f: "Sn²⁺", n: "Олово" }
    ],

    // 22 Анионов (расширено)
    anions: [
        { f: "OH⁻", n: "Гидроксид" },
        { f: "F⁻", n: "Фторид" },
        { f: "Cl⁻", n: "Хлорид" },
        { f: "Br⁻", n: "Бромид" },
        { f: "I⁻", n: "Иодид" },
        { f: "S²⁻", n: "Сульфид" },
        { f: "HS⁻", n: "Гидросульфид" },
        { f: "SO₃²⁻", n: "Сульфит" },
        { f: "SO₄²⁻", n: "Сульфат" },
        { f: "NO₃⁻", n: "Нитрат" },
        { f: "PO₄³⁻", n: "Фосфат" },
        { f: "CO₃²⁻", n: "Карбонат" },
        { f: "SiO₃²⁻", n: "Силикат" },
        { f: "CrO₄²⁻", n: "Хромат" },
        { f: "Cr₂O₇²⁻", n: "Дихромат" },
        { f: "AlO₂⁻", n: "Алюминат" },
        { f: "ZnO₂²⁻", n: "Цинкат" },
        { f: "PbO₂²⁻", n: "Плюмбат" },
        { f: "CrO₂⁻", n: "Хромит" },
        { f: "SnO₃²⁻", n: "Станнат" },
        { f: "CH₃COO⁻", n: "Ацетат" },
        { f: "MnO₄⁻", n: "Перманганат" }
    ],

    // ПРАВИЛА ПО УМОЛЧАНИЮ (по Лурье)
    defaults: {
        "OH-": "N",      // Гидроксиды нерастворимы
        "F-": "R",       // Фториды растворимы
        "Cl-": "R",      // Хлориды растворимы
        "Br-": "R",      // Бромиды растворимы
        "I-": "R",       // Йодиды растворимы
        "S2-": "N",      // Сульфиды нерастворимы
        "HS-": "R",      // Гидросульфиды растворимы
        "SO32-": "R",    // Сульфиты растворимы
        "SO42-": "R",    // Сульфаты растворимы
        "NO3-": "R",     // Нитраты все растворимы
        "PO43-": "N",    // Фосфаты нерастворимы
        "CO32-": "N",    // Карбонаты нерастворимы
        "SiO32-": "N",   // Силикаты нерастворимы
        "CrO42-": "R",   // Хроматы растворимы
        "Cr2O72-": "R",  // Дихроматы растворимы
        "AlO2-": "R",    // Алюминаты растворимы (в щелочах)
        "ZnO22-": "R",   // Цинкаты растворимы (в щелочах)
        "PbO22-": "R",   // Плюмбаты растворимы (в щелочах)
        "CrO2-": "R",    // Хромиты растворимы (в щелочах)
        "SnO32-": "R",   // Станнаты растворимы (в щелочах)
        "CH3COO-": "R",  // Ацетаты растворимы
        "MnO4-": "R"     // Перманганаты растворимы
    },

    // ИСКЛЮЧЕНИЯ (только отклонения от правил по умолчанию)
    // Источник: Лурье Ю.Ю. "Справочник по аналитической химии"
    exceptions: {
        // === ГИДРОКСИДЫ (по умолчанию N) ===
        "H+-OH-": "O",         // Не существует (вода)
        "NH4+-OH-": "R",       // Растворим
        "Li+-OH-": "R",        // Растворим
        "K+-OH-": "R",         // Растворим
        "Na+-OH-": "R",        // Растворим
        "Rb+-OH-": "R",        // Растворим
        "Cs+-OH-": "R",        // Растворим
        "Ca2+-OH-": "M",       // Малорастворим (известковая вода)
        "Sr2+-OH-": "M",       // Малорастворим
        "Ba2+-OH-": "R",       // РАСТВОРИМ (важно!)
        "Ag+-OH-": "D",
        "Hg2+-OH-": "D",     // Разлагается → Ag2O

        // === ФТОРИДЫ (по умолчанию R) ===
        "Li+-F-": "M",
        "Mg2+-F-": "N",        // Нерастворим
        "Ca2+-F-": "N",        // Нерастворим (флюорит)
        "Sr2+-F-": "N",        // Малорастворим
        "Ba2+-F-": "M",        // Малорастворим
        "Pb2+-F-": "N",        // Нерастворим
        "Ag+-F-": "R",         // Растворим (исключение из правила для солей Ag⁺)
        "Al3+-F-": "M",
        "Cr3+-F-": "N",
        "Fe2+-F-": "N",
        "Fe3+-F-": "N",
        "Hg2+-F-": "D",        // Разлагается (Гидролиз)

        // === ХЛОРИДЫ (по умолчанию R) ===
        "Ag+-Cl-": "N",        // Нерастворим
        "Pb2+-Cl-": "M",       // Малорастворим (растворимость сильно зависит от температуры)
        // HgCl₂ (Сулема) - растворим. (Hg₂Cl₂ - нерастворим, но здесь катион Hg²⁺)

        // === БРОМИДЫ (по умолчанию R) ===
        "Ag+-Br-": "N",        // Нерастворим
        "Pb2+-Br-": "M",       // Малорастворим
        "Hg2+-Br-": "M",       // Малорастворим (0.6 г/100мл)

        // === ЙОДИДЫ (по умолчанию R) ===
        "Ag+-I-": "N",         // Нерастворим
        "Pb2+-I-": "N",        // Нерастворим (золотой дождь)
        "Hg2+-I-": "N",        // Нерастворим (красный HgI2)
        "Cu2+-I-": "D",        // Разлагается: 2Cu2+ + 4I- → 2CuI↓ + I2
        "Fe3+-I-": "D",        // ОВР: 2Fe3+ + 2I- → 2Fe2+ + I2

        // === СУЛЬФИДЫ (по умолчанию N) ===
        "H+-S2-": "R",         // H2S растворим
        "NH4+-S2-": "R",       // Растворим
        "Li+-S2-": "R",        // Растворим
        "K+-S2-": "R",         // Растворим
        "Na+-S2-": "R",        // Растворим
        "Rb+-S2-": "R",        // Растворим
        "Cs+-S2-": "R",        // Растворим
        "Mg2+-S2-": "D",       // Гидролиз
        "Ca2+-S2-": "D",       // Гидролиз
        "Sr2+-S2-": "D",       // Гидролиз
        "Ba2+-S2-": "D",       // Гидролиз
        "Al3+-S2-": "D",       // Гидролиз
        "Cr3+-S2-": "D",       // Гидролиз
        "Fe3+-S2-": "D",       // Гидролиз

        // === ГИДРОСУЛЬФИДЫ (по умолчанию R) ===
        "Ag+-HS-": "N",        // Нерастворим
        "Hg2+-HS-": "N",       // Нерастворим
        "Pb2+-HS-": "N",       // Нерастворим
        "Cu2+-HS-": "N",       // Нерастворим
        "Fe3+-HS-": "D",       // Гидролиз
        "Al3+-HS-": "D",       // Гидролиз
        "Cr3+-HS-": "D",       // Гидролиз
        "Sn2+-HS-": "D",       // Гидролиз

        // === СУЛЬФИТЫ (по умолчанию R) ===
        "H+-SO32-": "D",       // Неустойчива (SO2↑)
        "Ag+-SO32-": "N",      // Нерастворим
        "Mg2+-SO32-": "M",     // Малорастворим
        "Ca2+-SO32-": "M",     // Малорастворим
        "Sr2+-SO32-": "N",     // Нерастворим
        "Ba2+-SO32-": "N",     // Нерастворим
        "Pb2+-SO32-": "N",     // Нерастворим
        "Al3+-SO32-": "D",     // Гидролиз
        "Cr3+-SO32-": "D",     // Гидролиз
        "Fe3+-SO32-": "D",     // Гидролиз

        // === СУЛЬФАТЫ (по умолчанию R) ===
        "Ca2+-SO42-": "M",     // Малорастворим (гипс)
        "Sr2+-SO42-": "N",     // Нерастворим
        "Ba2+-SO42-": "N",     // Нерастворим (барит)
        "Pb2+-SO42-": "N",     // Нерастворим
        "Ag+-SO42-": "M",      // Малорастворим
        "Hg2+-SO42-": "M",     // Малорастворим

        // === ФОСФАТЫ (по умолчанию N) ===
        "H+-PO43-": "R",       // Растворим
        "NH4+-PO43-": "R",     // Растворим
        "Li+-PO43-": "N",      // Нерастворим (0.039 г/100мл)
        "K+-PO43-": "R",       // Растворим
        "Na+-PO43-": "R",      // Растворим
        "Rb+-PO43-": "R",      // Растворим
        "Cs+-PO43-": "R",      // Растворим
        "Ag+-PO43-": "N",      // Нерастворим (жёлтый осадок)

        // === КАРБОНАТЫ (по умолчанию N) ===
        "H+-CO32-": "D",       // Разлагается (H2CO3 → CO2 + H2O)
        "NH4+-CO32-": "R",     // Растворим
        "Li+-CO32-": "R",      // Растворим
        "K+-CO32-": "R",       // Растворим
        "Na+-CO32-": "R",      // Растворим
        "Rb+-CO32-": "R",      // Растворим
        "Cs+-CO32-": "R",      // Растворим
        "Al3+-CO32-": "D",     // Гидролиз
        "Cr3+-CO32-": "D",     // Гидролиз
        "Fe3+-CO32-": "D",     // Гидролиз
        "Fe2+-CO32-": "N",     // Нерастворим (серо-зелёный осадок)

        // === СИЛИКАТЫ (по умолчанию N) ===
        "H+-SiO32-": "N",      // H2SiO3 нерастворим (гель кремниевой кислоты)
        "NH4+-SiO32-": "R",    // Растворим
        "Li+-SiO32-": "N",     // Нерастворим (по таблице ЕГЭ)
        "K+-SiO32-": "R",      // Растворим (жидкое стекло)
        "Na+-SiO32-": "R",     // Растворим (жидкое стекло)
        "Rb+-SiO32-": "R",     // Растворим
        "Cs+-SiO32-": "R",     // Растворим
        "Al3+-SiO32-": "D",    // Гидролиз
        "Cr3+-SiO32-": "D",    // Гидролиз
        "Fe3+-SiO32-": "D",    // Гидролиз

        // === ХРОМАТЫ (по умолчанию R) ===
        "Ag+-CrO42-": "N",     // Нерастворим (кирпично-красный)
        "Pb2+-CrO42-": "N",    // Нерастворим (оранжево-жёлтый)
        "Ba2+-CrO42-": "N",    // Нерастворим (жёлтый)
        "Sr2+-CrO42-": "N",    // Нерастворим (по таблице ЕГЭ)
        "Ca2+-CrO42-": "M",    // Малорастворим
        "Hg2+-CrO42-": "N",    // Нерастворим

        // === АЦЕТАТЫ (по умолчанию R) ===
        "Ag+-CH3COO-": "R",    // Растворим (>1 г/100г, по таблице ЕГЭ - Р)

        // === ПЕРМАНГАНАТЫ (все растворимы, исключений нет) ===

        // === ДИХРОМАТЫ (по умолчанию R) ===
        "Ag+-Cr2O72-": "M",    // Малорастворим (красный)
        "Pb2+-Cr2O72-": "M",   // Малорастворим (оранжевый)
        "Ba2+-Cr2O72-": "M",   // Малорастворим

        // === АЛЮМИНАТЫ (по умолчанию R — растворимы в щелочах) ===
        // Большинство катионов не образуют алюминаты, только щелочные металлы растворимы
        "H+-AlO2-": "D",       // Не существует (разложение)
        "Mg2+-AlO2-": "N",     // Нерастворим
        "Ca2+-AlO2-": "N",     // Нерастворим
        "Sr2+-AlO2-": "N",     // Нерастворим
        "Ba2+-AlO2-": "N",     // Нерастворим
        "Zn2+-AlO2-": "N",     // Нерастворим
        "Al3+-AlO2-": "D",     // Не существует
        "Fe2+-AlO2-": "N",     // Нерастворим
        "Fe3+-AlO2-": "N",     // Нерастворим
        "Cu2+-AlO2-": "N",     // Нерастворим
        "Ag+-AlO2-": "N",      // Нерастворим
        "Pb2+-AlO2-": "N",     // Нерастворим
        "Hg2+-AlO2-": "N",     // Нерастворим
        "Cr3+-AlO2-": "N",     // Нерастворим
        "Mn2+-AlO2-": "N",     // Нерастворим
        "Ni2+-AlO2-": "N",     // Нерастворим
        "Co2+-AlO2-": "N",     // Нерастворим
        "Sn2+-AlO2-": "N",     // Нерастворим

        // === ЦИНКАТЫ (по умолчанию R — растворимы в щелочах) ===
        "H+-ZnO22-": "D",      // Не существует (разложение)
        "Mg2+-ZnO22-": "N",    // Нерастворим
        "Ca2+-ZnO22-": "N",    // Нерастворим
        "Sr2+-ZnO22-": "N",    // Нерастворим
        "Ba2+-ZnO22-": "N",    // Нерастворим
        "Zn2+-ZnO22-": "D",    // Не существует
        "Al3+-ZnO22-": "N",    // Нерастворим
        "Fe2+-ZnO22-": "N",    // Нерастворим
        "Fe3+-ZnO22-": "N",    // Нерастворим
        "Cu2+-ZnO22-": "N",    // Нерастворим
        "Ag+-ZnO22-": "N",     // Нерастворим
        "Pb2+-ZnO22-": "N",    // Нерастворим
        "Hg2+-ZnO22-": "N",    // Нерастворим
        "Cr3+-ZnO22-": "N",    // Нерастворим
        "Mn2+-ZnO22-": "N",    // Нерастворим
        "Ni2+-ZnO22-": "N",    // Нерастворим
        "Co2+-ZnO22-": "N",    // Нерастворим
        "Sn2+-ZnO22-": "N",    // Нерастворим

        // === ПЛЮМБАТЫ (по умолчанию R — растворимы в щелочах) ===
        "H+-PbO22-": "D",      // Не существует (разложение)
        "Mg2+-PbO22-": "N",    // Нерастворим
        "Ca2+-PbO22-": "N",    // Нерастворим
        "Sr2+-PbO22-": "N",    // Нерастворим
        "Ba2+-PbO22-": "N",    // Нерастворим
        "Zn2+-PbO22-": "N",    // Нерастворим
        "Al3+-PbO22-": "N",    // Нерастворим
        "Fe2+-PbO22-": "N",    // Нерастворим
        "Fe3+-PbO22-": "N",    // Нерастворим
        "Cu2+-PbO22-": "N",    // Нерастворим
        "Ag+-PbO22-": "N",     // Нерастворим
        "Pb2+-PbO22-": "D",    // Не существует
        "Hg2+-PbO22-": "N",    // Нерастворим
        "Cr3+-PbO22-": "N",    // Нерастворим
        "Mn2+-PbO22-": "N",    // Нерастворим
        "Ni2+-PbO22-": "N",    // Нерастворим
        "Co2+-PbO22-": "N",    // Нерастворим
        "Sn2+-PbO22-": "N",    // Нерастворим

        // === ХРОМИТЫ (по умолчанию R — растворимы в щелочах) ===
        "H+-CrO2-": "D",       // Не существует (разложение)
        "Mg2+-CrO2-": "N",     // Нерастворим
        "Ca2+-CrO2-": "N",     // Нерастворим
        "Sr2+-CrO2-": "N",     // Нерастворим
        "Ba2+-CrO2-": "N",     // Нерастворим
        "Zn2+-CrO2-": "N",     // Нерастворим
        "Al3+-CrO2-": "N",     // Нерастворим
        "Fe2+-CrO2-": "N",     // Нерастворим
        "Fe3+-CrO2-": "N",     // Нерастворим
        "Cu2+-CrO2-": "N",     // Нерастворим
        "Ag+-CrO2-": "N",      // Нерастворим
        "Pb2+-CrO2-": "N",     // Нерастворим
        "Hg2+-CrO2-": "N",     // Нерастворим
        "Cr3+-CrO2-": "D",     // Не существует
        "Mn2+-CrO2-": "N",     // Нерастворим
        "Ni2+-CrO2-": "N",     // Нерастворим
        "Co2+-CrO2-": "N",     // Нерастворим
        "Sn2+-CrO2-": "N",     // Нерастворим

        // === СТАННАТЫ (по умолчанию R — растворимы в щелочах) ===
        "H+-SnO32-": "D",      // Не существует (разложение)
        "Mg2+-SnO32-": "N",    // Нерастворим
        "Ca2+-SnO32-": "N",    // Нерастворим
        "Sr2+-SnO32-": "N",    // Нерастворим
        "Ba2+-SnO32-": "N",    // Нерастворим
        "Zn2+-SnO32-": "N",    // Нерастворим
        "Al3+-SnO32-": "N",    // Нерастворим
        "Fe2+-SnO32-": "N",    // Нерастворим
        "Fe3+-SnO32-": "N",    // Нерастворим
        "Cu2+-SnO32-": "N",    // Нерастворим
        "Ag+-SnO32-": "N",     // Нерастворим
        "Pb2+-SnO32-": "N",    // Нерастворим
        "Hg2+-SnO32-": "N",    // Нерастворим
        "Cr3+-SnO32-": "N",    // Нерастворим
        "Mn2+-SnO32-": "N",    // Нерастворим
        "Ni2+-SnO32-": "N",    // Нерастворим
        "Co2+-SnO32-": "N",    // Нерастворим
        "Sn2+-SnO32-": "D"     // Не существует
    }
};

// Данные для ряда активности
const activityData = {
    metals: ["Li", "Rb", "K", "Ba", "Sr", "Ca", "Na", "Mg", "Al", "Mn", "Zn", "Cr", "Fe", "Cd", "Co", "Ni", "Sn", "Pb", "H", "Sb", "Bi", "Cu", "Hg", "Ag", "Pt", "Au"],
    nonMetals: ["F", "O", "N", "Cl", "Br", "I", "S", "C", "P", "Si"]
};

// Делаем solubilityData и таблицу цветов глобально доступными
window.solubilityData = solubilityData;
window.substanceColors = substanceColors;

// =========================================
// РЕАКЦИИ РАЗЛОЖЕНИЯ НЕУСТОЙЧИВЫХ ВЕЩЕСТВ
// =========================================
const decompositionReactions = {
    // Гидроксиды
    "NH4+-OH-": {
        equation: "NH₄OH → NH₃↑ + H₂O",
        description: "Гидроксид аммония неустойчив, разлагается на аммиак и воду"
    },
    "Fe3+-OH-": {
        equation: "2Fe(OH)₃ →(t°) Fe₂O₃ + 3H₂O",
        description: "При нагревании теряет воду"
    },
    "Al3+-OH-": {
        equation: "2Al(OH)₃ →(t°) Al₂O₃ + 3H₂O",
        description: "Разлагается при прокаливании"
    },
    "Ag+-OH-": {
        equation: "2AgOH → Ag₂O + H₂O",
        description: "Неустойчив, мгновенно превращается в оксид серебра"
    },
    "Hg2+-OH-": {
        equation: "Hg(OH)₂ → HgO + H₂O",
        description: "Неустойчив, разлагается до оксида ртути"
    },

    // Карбонаты
    "H+-CO32-": {
        equation: "H₂CO₃ → H₂O + CO₂↑",
        description: "Угольная кислота неустойчива"
    },
    "NH4+-CO32-": {
        equation: "(NH₄)₂CO₃ →(t°) 2NH₃↑ + H₂O + CO₂↑",
        description: "Разлагается при нагревании"
    },
    "Al3+-CO32-": {
        equation: "Al₂(CO₃)₃ + 3H₂O → 2Al(OH)₃↓ + 3CO₂↑",
        description: "Гидролизуется водой"
    },
    "Cr3+-CO32-": {
        equation: "Cr₂(CO₃)₃ + 3H₂O → 2Cr(OH)₃↓ + 3CO₂↑",
        description: "Гидролизуется водой"
    },
    "Fe3+-CO32-": {
        equation: "Fe₂(CO₃)₃ + 3H₂O → 2Fe(OH)₃↓ + 3CO₂↑",
        description: "Гидролизуется водой"
    },

    // Сульфиты
    "Al3+-SO32-": {
        equation: "Al₂(SO₃)₃ + 3H₂O → 2Al(OH)₃↓ + 3SO₂↑",
        description: "Гидролизуется водой"
    },
    "Cr3+-SO32-": {
        equation: "Cr₂(SO₃)₃ + 3H₂O → 2Cr(OH)₃↓ + 3SO₂↑",
        description: "Гидролизуется водой"
    },
    "Fe3+-SO32-": {
        equation: "Fe₂(SO₃)₃ + 3H₂O → 2Fe(OH)₃↓ + 3SO₂↑",
        description: "Гидролизуется водой"
    },

    // Сульфиды (гидролизуемые)
    "Al3+-S2-": {
        equation: "Al₂S₃ + 6H₂O → 2Al(OH)₃↓ + 3H₂S↑",
        description: "Полностью гидролизуется водой"
    },
    "Cr3+-S2-": {
        equation: "Cr₂S₃ + 6H₂O → 2Cr(OH)₃↓ + 3H₂S↑",
        description: "Полностью гидролизуется водой"
    },
    "Fe3+-S2-": {
        equation: "Fe₂S₃ + 6H₂O → 2Fe(OH)₃↓ + 3H₂S↑",
        description: "Полностью гидролизуется водой"
    },
    "Mg2+-S2-": {
        equation: "MgS + 2H₂O → Mg(OH)₂↓ + H₂S↑",
        description: "Гидролизуется водой"
    },
    "Ca2+-S2-": {
        equation: "CaS + 2H₂O → Ca(OH)₂ + H₂S↑",
        description: "Гидролизуется водой"
    },
    "Sr2+-S2-": {
        equation: "SrS + 2H₂O → Sr(OH)₂ + H₂S↑",
        description: "Гидролизуется водой"
    },
    "Ba2+-S2-": {
        equation: "BaS + 2H₂O → Ba(OH)₂ + H₂S↑",
        description: "Гидролизуется водой"
    },

    // Гидросульфиды
    "Fe3+-HS-": {
        equation: "Fe(HS)₃ + 3H₂O → Fe(OH)₃↓ + 3H₂S↑",
        description: "Гидролизуется водой"
    },
    "Al3+-HS-": {
        equation: "Al(HS)₃ + 3H₂O → Al(OH)₃↓ + 3H₂S↑",
        description: "Гидролизуется водой"
    },
    "Cr3+-HS-": {
        equation: "Cr(HS)₃ + 3H₂O → Cr(OH)₃↓ + 3H₂S↑",
        description: "Гидролизуется водой"
    },
    "Sn2+-HS-": {
        equation: "Sn(HS)₂ + 2H₂O → Sn(OH)₂↓ + 2H₂S↑",
        description: "Гидролизуется водой"
    },

    // Силикаты
    "Al3+-SiO32-": {
        equation: "Al₂(SiO₃)₃ + 6H₂O → 2Al(OH)₃↓ + 3H₂SiO₃↓",
        description: "Гидролизуется водой"
    },
    "Cr3+-SiO32-": {
        equation: "Cr₂(SiO₃)₃ + 6H₂O → 2Cr(OH)₃↓ + 3H₂SiO₃↓",
        description: "Гидролизуется водой"
    },
    "Fe3+-SiO32-": {
        equation: "Fe₂(SiO₃)₃ + 6H₂O → 2Fe(OH)₃↓ + 3H₂SiO₃↓",
        description: "Гидролизуется водой"
    },

    // Алюминаты, цинкаты и др. (разложение водой)
    "H+-AlO2-": {
        equation: "HAlO₂ + H₂O → Al(OH)₃↓",
        description: "Гидролизуется с образованием гидроксида"
    },
    "H+-ZnO22-": {
        equation: "H₂ZnO₂ + H₂O → Zn(OH)₂↓",
        description: "Гидролизуется с образованием гидроксида"
    },
    "H+-PbO22-": {
        equation: "H₂PbO₂ → PbO₂ + H₂O",
        description: "Разлагается до оксида"
    },
    "H+-CrO2-": {
        equation: "HCrO₂ + H₂O → Cr(OH)₃↓",
        description: "Гидролизуется с образованием гидроксида"
    },
    "H+-SnO32-": {
        equation: "H₂SnO₃ + H₂O → Sn(OH)₄↓",
        description: "Гидролизуется с образованием гидроксида"
    },

    // Несуществующие соединения
    "Al3+-AlO2-": {
        equation: "—",
        description: "Соединение не может существовать (один и тот же элемент)"
    },
    "Zn2+-ZnO22-": {
        equation: "—",
        description: "Соединение не может существовать (один и тот же элемент)"
    },
    "Pb2+-PbO22-": {
        equation: "—",
        description: "Соединение не может существовать (один и тот же элемент)"
    },
    "Cr3+-CrO2-": {
        equation: "—",
        description: "Соединение не может существовать (один и тот же элемент)"
    },
    "Sn2+-SnO32-": {
        equation: "—",
        description: "Соединение не может существовать (один и тот же элемент)"
    },

    // Йодид меди (окислительно-восстановительная реакция)
    "Cu2+-I-": {
        equation: "2CuI₂ → 2CuI↓ + I₂",
        description: "Окислительно-восстановительная реакция"
    },

    // Йодид железа(III) (окислительно-восстановительная реакция)
    "Fe3+-I-": {
        equation: "2Fe³⁺ + 2I⁻ ⇌ 2Fe²⁺ + I₂",
        description: "Окислительно-восстановительная реакция"
    },

    // Сернистая кислота
    "H+-SO32-": {
        equation: "H₂SO₃ ⇌ H₂O + SO₂↑",
        description: "Сернистая кислота неустойчива, разлагается"
    },

    // Фторид ртути
    "Hg2+-F-": {
        equation: "HgF₂ + H₂O → HgO + 2HF",
        description: "Гидролизуется с образованием оксида"
    }
};

// Делаем глобально доступным
window.decompositionReactions = decompositionReactions;

// Функция получения растворимости
function getSolubility(cationFormula, anionFormula) {
    // Нормализуем формулы для ключа
    const cationKey = normalizeFormula(cationFormula);
    const anionKey = normalizeFormula(anionFormula);
    const exceptionKey = `${cationKey}-${anionKey}`;

    // Сначала проверяем исключения
    if (solubilityData.exceptions[exceptionKey] !== undefined) {
        return solubilityData.exceptions[exceptionKey];
    }

    // Иначе возвращаем правило по умолчанию
    return solubilityData.defaults[anionKey] || "R";
}


============================================================
ФАЙЛ: .\js\solubility\filters.js
============================================================

// =========================================
// ФИЛЬТРЫ ТАБЛИЦЫ РАСТВОРИМОСТИ
// =========================================

var originalCategoriesHTML = ''; 

function updateFiltersForSolubility() {
    console.log('updateFiltersForSolubility called, window.isColorMode:', window.isColorMode);

    const categoriesSection = document.getElementById('categories-section');
    if (!categoriesSection) {
        console.log('categories-section not found');
        return;
    }

    if (!originalCategoriesHTML) {
        originalCategoriesHTML = categoriesSection.innerHTML;
        console.log('Stored originalCategoriesHTML:', originalCategoriesHTML);
    }

    console.log('Current window.isColorMode value:', window.isColorMode);

    if (window.isColorMode) {
        console.log('Entering color mode branch');
        const uniqueColors = getUniqueColorsFromTable();
        console.log('Unique colors found:', uniqueColors);

        let buttonsHTML = '';
        uniqueColors.forEach(colorObj => {
            const safeColors = encodeURIComponent(JSON.stringify(colorObj.originalColors));
            buttonsHTML += `<button class="filter-btn" data-color-name="${colorObj.name}" data-encoded-colors="${safeColors}">${colorObj.name}</button>`;
        });

        categoriesSection.innerHTML = `
            <h4>Цвета веществ</h4>
            <div class="filter-buttons">${buttonsHTML}</div>
        `;
        console.log('Set color mode filters with', uniqueColors.length, 'unique colors');
    } else {
        console.log('Entering solubility mode branch');
        categoriesSection.innerHTML = `
            <h4>Растворимость</h4>
            <div class="filter-buttons">
                <button class="filter-btn" data-solubility="Р">Растворимые (Р)</button>
                <button class="filter-btn" data-solubility="М">Малорастворимые (М)</button>
                <button class="filter-btn" data-solubility="Н">Нерастворимые (Н)</button>
                <button class="filter-btn" data-solubility="-">Не существует (-)</button>
            </div>
        `;
        console.log('Set solubility mode filters');
    }

    // Обработчики событий устанавливаются на уровне документа и не требуют повторной установки
    // после обновления содержимого

    // После обновления содержимого нужно заново установить обработчики для всех кнопок
    setupFilterEventHandlers();
}

function filterByColor(targetColors) {
    const table = document.getElementById('solubility-table');
    if (!table) return;
    const targetColorsLower = targetColors.map(c => c.toLowerCase().trim());
    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
        if (rowIndex === 0) return;
        const cells = row.children;
        for (let i = 1; i < cells.length; i++) {
            const cell = cells[i];
            const cationIndex = i - 1;
            const anionIndex = rowIndex - 1;
            const anion = solubilityData.anions[anionIndex];
            const cation = solubilityData.cations[cationIndex];
            if (!anion || !cation) continue;

            const solubility = getSolubility(cation.f, anion.f);
            const substanceKey = `${normalizeFormula(cation.f)}-${normalizeFormula(anion.f)}`;
            const dbColor = substanceColors[substanceKey];

            let effectiveColor = null;
            if (dbColor) effectiveColor = dbColor.color || dbColor;
            else if (solubility === 'R') effectiveColor = 'colorless';
            else if (solubility === 'M' || solubility === 'N') effectiveColor = 'white';

            let isMatch = false;
            if (effectiveColor) {
                // Определяем группу цвета для сравнения
                const groupedColor = getGroupedColorName(effectiveColor).toLowerCase().trim();

                if (targetColorsLower.includes(groupedColor)) isMatch = true;
                else {
                    // Проверяем также оригинальный цвет
                    const effLower = effectiveColor.toLowerCase().trim();
                    if (targetColorsLower.includes(effLower)) isMatch = true;
                    else if (effLower.startsWith('#') && targetColorsLower.some(tc => tc === effLower)) isMatch = true;
                }
            }

            if (isMatch) { cell.style.opacity = '1'; cell.style.filter = 'none'; }
            else { cell.style.opacity = '0.05'; cell.style.filter = 'grayscale(100%)'; }
        }
    });
}

function filterBySolubility(solubility) {
    const table = document.getElementById('solubility-table');
    if (!table) return;
    const rows = table.querySelectorAll('tr');
    rows.forEach((row, rowIndex) => {
        if (rowIndex === 0) return;
        const cells = row.children;
        for (let i = 1; i < cells.length; i++) {
            const cell = cells[i];
            if (cell.textContent.trim() === solubility) { cell.style.opacity = '1'; cell.style.filter = 'none'; }
            else { cell.style.opacity = '0.1'; cell.style.filter = 'grayscale(100%)'; }
        }
    });
}

function resetSolubilityTableDisplay() {
    const table = document.getElementById('solubility-table');
    if (!table) return;
    const cells = table.querySelectorAll('td');
    cells.forEach(cell => {
        cell.style.opacity = '';
        cell.style.filter = '';
    });
}

// Экспортируем функцию в глобальную область
window.resetSolubilityTableDisplay = resetSolubilityTableDisplay;

function restoreElementFilters() {
    const categoriesSection = document.getElementById('categories-section');
    if (!categoriesSection || !originalCategoriesHTML) return;
    categoriesSection.innerHTML = originalCategoriesHTML;

    // Сбрасываем active-состояние у восстановленных кнопок
    document.querySelectorAll('#categories-section .filter-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.style.color = '';
    });

    // Переподключаем обработчики через единую функцию из search-filters.js
    if (typeof window.attachCategoryFilterHandlers === 'function') {
        window.attachCategoryFilterHandlers();
    }
}



// Глобальная переменная для хранения observer
let filterObserver = null;

// Функция для присоединения обработчика к конкретной кнопке
function attachHandlerToButton(button) {
    console.log('Attaching handler to button:', button);
    // Проверяем, не установлен ли уже обработчик
    if (button.dataset.handlerAttached === 'true') {
        console.log('Handler already attached to button:', button);
        return;
    }

    button.addEventListener('click', function() {
        console.log('Filter button clicked:', this);
        console.log('Current window.isColorMode:', window.isColorMode);

        // Handle color filter buttons
        if (this.hasAttribute('data-encoded-colors')) {
            console.log('Color filter clicked:', this.dataset.colorName);
            const originalColors = JSON.parse(decodeURIComponent(this.dataset.encodedColors));
            console.log('Original colors:', originalColors);

            if (this.classList.contains('active')) {
                console.log('Removing active class and resetting display');
                this.classList.remove('active');
                // Remove inline styles when deactivating
                this.style.background = '';
                this.style.borderColor = '';
                this.style.color = '';
                resetSolubilityTableDisplay();
            } else {
                console.log('Setting active class and applying color filter');
                document.querySelectorAll('#categories-section .filter-btn').forEach(b => {
                    b.classList.remove('active');
                    // Reset inline styles for other buttons
                    b.style.background = '';
                    b.style.borderColor = '';
                    b.style.color = '';
                });

                // Apply the color of the filter to the button
                if (originalColors && originalColors.length > 0) {
                    let color = originalColors[0]; // Use the first color

                    // Convert named colors to HEX if needed
                    if (typeof color === 'string' && !color.startsWith('#') && !color.startsWith('rgb')) {
                        // Map common color names to HEX values
                        const colorMap = {
                            'Белый': '#FFFFFF',
                            'Бесцветный': '#F0F8FF', // AliceBlue as a light transparent substitute
                            'Чёрный': '#000000',
                            'Красный': '#FF0000',
                            'Синий': '#0000FF',
                            'Зелёный': '#008000',
                            'Жёлтый': '#FFFF00',
                            'Оранжевый': '#FFA500',
                            'Фиолетовый': '#800080',
                            'Розовый': '#FFC0CB',
                            'Голубой': '#00BFFF',
                            'Серый': '#808080',
                            'Коричневый': '#A52A2A'
                        };

                        if (colorMap[color]) {
                            color = colorMap[color];
                        } else {
                            // If we don't have a mapping, use a default color
                            color = '#2196F3'; // Default blue color
                        }
                    }

                    this.style.background = color;
                    this.style.borderColor = color;

                    // Determine if the color is light or dark to adjust text color
                    if (isColorDarkForFilters(color)) {
                        this.style.color = '#ffffff';
                    } else {
                        this.style.color = '#000000';
                    }
                }

                this.classList.add('active');
                filterByColor(originalColors);
            }
        }
        // Handle solubility filter buttons
        else if (this.hasAttribute('data-solubility')) {
            console.log('Solubility filter clicked:', this.dataset.solubility);
            const solubility = this.dataset.solubility;

            if (this.classList.contains('active')) {
                console.log('Removing active class and resetting solubility display');
                this.classList.remove('active');
                resetSolubilityTableDisplay();
            } else {
                console.log('Setting active class and applying solubility filter:', solubility);
                document.querySelectorAll('#categories-section .filter-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                filterBySolubility(solubility);
            }
        }
    });

    // Помечаем, что обработчик уже установлен
    button.dataset.handlerAttached = 'true';
    console.log('Handler attached to button and marked as attached');
}

// Используем MutationObserver для отслеживания изменений в DOM и установки обработчиков
function setupFilterEventHandlers() {
    console.log('setupFilterEventHandlers called');

    // Останавливаем предыдущий observer, если он существует
    if (filterObserver) {
        filterObserver.disconnect();
        console.log('Disconnected previous observer');
    }

    // Наблюдатель за изменениями в DOM
    filterObserver = new MutationObserver(function(mutations) {
        console.log('MutationObserver triggered with', mutations.length, 'mutations');
        mutations.forEach(function(mutation) {
            // Проверяем, были ли добавлены новые узлы
            mutation.addedNodes.forEach(function(node) {
                if (node.nodeType === 1) { // ELEMENT_NODE
                    console.log('Processing added node:', node);
                    // Проверяем, является ли добавленный узел кнопкой фильтра или содержит такие кнопки
                    if (node.classList && node.classList.contains('filter-btn')) {
                        console.log('Found filter-btn element, attaching handler');
                        attachHandlerToButton(node);
                    } else if (node.querySelectorAll) {
                        const filterButtons = node.querySelectorAll('.filter-btn');
                        console.log('Found', filterButtons.length, 'filter buttons in added node');
                        filterButtons.forEach(attachHandlerToButton);
                    }
                }
            });
        });
    });

    // Начинаем наблюдение за изменениями в #categories-section
    const targetNode = document.getElementById('categories-section');
    if (targetNode) {
        console.log('Starting observer on categories-section');
        filterObserver.observe(targetNode, {
            childList: true,
            subtree: true
        });
    } else {
        console.log('Could not find categories-section element');
    }

    // Также устанавливаем обработчики для уже существующих кнопок
    setTimeout(() => {
        const existingButtons = document.querySelectorAll('#categories-section .filter-btn');
        console.log('Setting up handlers for', existingButtons.length, 'existing buttons');
        existingButtons.forEach(attachHandlerToButton);
    }, 100);
}

// Инициализируем обработчики при загрузке
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupFilterEventHandlers);
} else {
    setupFilterEventHandlers();
}

// Функция для определения, является ли цвет темным (локальная версия для фильтров)
function isColorDarkForFilters(color) {
    // Удалить пробелы и преобразовать в нижний регистр
    color = color.replace(/\s/g, '').toLowerCase();

    // Если цвет в формате RGB
    if (color.indexOf('rgb') === 0) {
        // Извлекаем значения RGB
        const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        if (match) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);

            // Вычисляем яркость по формуле
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness < 128;
        }
    }
    // Если цвет в формате HEX
    else if (color.charAt(0) === '#') {
        const hex = color.substring(1);

        // Преобразуем 3-значный HEX в 6-значный
        const shorthandRegex = /^([a-f0-9])([a-f0-9])([a-f0-9])$/i;
        const fullHex = hex.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });

        const r = parseInt(fullHex.substr(0, 2), 16);
        const g = parseInt(fullHex.substr(2, 2), 16);
        const b = parseInt(fullHex.substr(4, 2), 16);

        // Вычисляем яркость по формуле
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    // Если это название цвета, преобразуем его в HEX и повторим проверку
    else {
        // Map common color names to HEX values for brightness calculation
        const colorMap = {
            'white': '#FFFFFF',
            'colorless': '#F0F8FF', // AliceBlue as a light transparent substitute
            'black': '#000000',
            'red': '#FF0000',
            'blue': '#0000FF',
            'green': '#008000',
            'yellow': '#FFFF00',
            'orange': '#FFA500',
            'purple': '#800080',
            'pink': '#FFC0CB',
            'cyan': '#00BFFF',
            'gray': '#808080',
            'brown': '#A52A2A',
            'белый': '#FFFFFF',
            'бесцветный': '#F0F8FF',
            'чёрный': '#000000',
            'красный': '#FF0000',
            'синий': '#0000FF',
            'зелёный': '#008000',
            'жёлтый': '#FFFF00',
            'оранжевый': '#FFA500',
            'фиолетовый': '#800080',
            'розовый': '#FFC0CB',
            'голубой': '#00BFFF',
            'серый': '#808080',
            'коричневый': '#A52A2A'
        };

        if (colorMap[color]) {
            const hexColor = colorMap[color];
            return isColorDarkForFilters(hexColor); // Recursive call with HEX value
        }
    }

    // Для других форматов (например, неизвестные названия цветов) будем считать, что цвет не темный
    return false;
}

// Экспорт функций в window (на всякий случай)
window.updateFiltersForSolubility = updateFiltersForSolubility;
window.restoreElementFilters = restoreElementFilters;


============================================================
ФАЙЛ: .\js\solubility\modal.js
============================================================

// =========================================
// МОДАЛЬНОЕ ОКНО ТАБЛИЦЫ РАСТВОРИМОСТИ
// =========================================

// Объявляем функции глобально для доступа из HTML
if (!window.toggleSolubility) {
    window.toggleSolubility = async function () {
        const modal = document.getElementById('solubility-modal');
        if (modal && (getComputedStyle(modal).display === 'flex' || getComputedStyle(modal).display === 'block')) {
            closeSolubility();
        } else {
            await openSolubility();
        }
    };
}

window.openSolubility = async function () {
    // 1. Загрузка модуля растворимости, если он еще не загружен
    if (window.loadSolubility) {
        await window.loadSolubility();
    }

    const modal = document.getElementById('solubility-modal');
    if (!modal) return;

    // 2. Генерация таблицы, если контейнер пуст
    const table = document.getElementById('solubility-table');
    if (table && table.innerHTML.trim() === "") {
        if (typeof renderSolubilityTable === 'function') {
            renderSolubilityTable();
        }
    }

    // 3. Открытие окна

    // 3. Открытие окна
    // ... animation removed for simplicity reversion ...

    modal.classList.remove('closing');
    modal.style.display = 'flex';
    document.body.classList.add('solubility-open');

    // 4. Управление интерфейсом
    const fabContainer = document.getElementById('fab-container');
    const themeToggle = document.getElementById('theme-toggle');
    const isMobile = window.innerWidth <= 1024;
    if (fabContainer) fabContainer.style.display = isMobile ? 'none' : '';
    if (themeToggle) themeToggle.style.display = '';

    // Явно восстанавливаем видимость кнопок внутри FAB (если они были скрыты ранее)
    const calcButton = document.querySelector('.fab-option[onclick="toggleCalc()"]');
    const particlesButton = document.querySelector('.fab-option[onclick="toggleParticles()"]');
    if (calcButton) calcButton.style.display = '';
    if (particlesButton) particlesButton.style.display = '';

    // 5. Инициализация подмодулей (продвинутый режим, ряд активности, поиск)
    if (typeof initAdvancedModeButton === 'function') initAdvancedModeButton();
    if (typeof initActivitySeriesUI === 'function') initActivitySeriesUI();
    if (typeof updateFiltersForSolubility === 'function') {
        console.log('openSolubility: Calling filter initialization, window.isColorMode:', window.isColorMode);
        // Используем лоадер для инициализации фильтров
        if (typeof window.initializeSolubilityFilters === 'function') {
            console.log('Using initializeSolubilityFilters');
            window.initializeSolubilityFilters();
        } else {
            console.log('Directly calling updateFiltersForSolubility');
            updateFiltersForSolubility();
        }
    } else {
        console.log('updateFiltersForSolubility function is not available');
    }

    // Дополнительно вызываем обновление фильтров, чтобы убедиться, что они установлены правильно
    setTimeout(() => {
        if (typeof updateFiltersForSolubility === 'function') {
            console.log('openSolubility: Second call to updateFiltersForSolubility after delay, window.isColorMode:', window.isColorMode);
            updateFiltersForSolubility();
        }
    }, 200);

    // 6. Инициализация перетаскивания (Drag Scroll)
    const wrapper = document.querySelector('.solubility-wrapper');
    if (wrapper) {
        if (!wrapper.dataset.dragScrollEnabled && typeof enableDragScroll === 'function') {
            enableDragScroll(wrapper);
            wrapper.dataset.dragScrollEnabled = 'true';
        }
        // Горизонтальный скролл колесиком мыши + Ctrl
        if (!wrapper.dataset.ctrlScrollEnabled) {
            wrapper.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    wrapper.scrollLeft += e.deltaY;
                }
            }, { passive: false });
            wrapper.dataset.ctrlScrollEnabled = 'true';
        }
    }

    setupSolubilityPanHints();

    // ПРИНУДИТЕЛЬНАЯ ПРИВЯЗКА СОБЫТИЙ ЗАКРЫТИЯ
    bindCloseEvents();
};

window.closeSolubility = function () {
    const modal = document.getElementById('solubility-modal');
    if (!modal) return;

    // Снимаем флаг сразу, чтобы фильтры элементов не оставались заблокированными
    document.body.classList.remove('solubility-open');

    // Добавляем класс для анимации закрытия
    modal.classList.add('closing');

    // Ждём завершения анимации
    setTimeout(() => {
        modal.style.display = 'none';
        modal.classList.remove('closing');
    }, 360);

    // Восстанавливаем интерфейс (сбрасываем стили скрытия)
    const fabContainer = document.getElementById('fab-container');
    const themeToggle = document.getElementById('theme-toggle');
    if (fabContainer) fabContainer.style.display = '';
    if (themeToggle) themeToggle.style.display = '';

    // Восстанавливаем кнопки FAB (калькулятор и частицы)
    const calcButton = document.querySelector('.fab-option[onclick="toggleCalc()"]');
    const particlesButton = document.querySelector('.fab-option[onclick="toggleParticles()"]');
    if (calcButton) calcButton.style.display = '';
    if (particlesButton) particlesButton.style.display = '';

    // Сбрасываем состояния поиска и фильтров
    const searchPanel = document.getElementById('solubility-search-panel');
    if (searchPanel) searchPanel.classList.remove('active');

    const searchBtn = document.getElementById('solubility-search-btn');
    if (searchBtn) searchBtn.classList.remove('active');
    if (typeof hideAdvancedModeHint === 'function') hideAdvancedModeHint(true);

    if (typeof clearTableSelection === 'function') clearTableSelection();

    // Восстанавливаем фильтры элементов (единственный вызов, чтобы избежать дублирования обработчиков)
    if (typeof window.restoreElementFiltersSafe === 'function') {
        window.restoreElementFiltersSafe();
    } else if (typeof restoreElementFilters === 'function') {
        restoreElementFilters();
    }

    // Сбрасываем отображение таблицы элементов
    if (typeof resetTableDisplay === 'function') {
        resetTableDisplay();
    }
};

// Функция для надежной привязки закрытия
function bindCloseEvents() {
    const closeButtons = document.querySelectorAll('.close-solubility');
    closeButtons.forEach(btn => {
        if (btn.dataset.boundClose === '1') return;
        btn.dataset.boundClose = '1';
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeSolubility();
        });
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeSolubility();
        });
    });

    const modal = document.getElementById('solubility-modal');
    if (modal && modal.dataset.boundBackdrop !== '1') {
        modal.dataset.boundBackdrop = '1';
        const onBackdrop = (e) => {
            if (e.target.closest('.modal-content')) return;
            closeSolubility();
        };
        modal.addEventListener('click', onBackdrop);
        modal.addEventListener('pointerdown', onBackdrop, true);
    }
}

// Запускаем привязку событий сразу при загрузке скрипта
bindCloseEvents();
// Глобальный клик по фону (надежнее, чем обработчик на модалке)
if (!window.__solubilityBackdropListener) {
    window.__solubilityBackdropListener = true;
    document.addEventListener('pointerdown', (e) => {
        const modal = document.getElementById('solubility-modal');
        if (!modal) return;
        const isOpen = getComputedStyle(modal).display !== 'none';
        if (!isOpen) return;
        // Не закрываем таблицу, если взаимодействие происходит с другой модалкой (например, advanced).
        const otherModal = e.target.closest('.modal');
        if (otherModal && otherModal.id !== 'solubility-modal') return;
        // Не закрываем модалку при взаимодействии с FAB или панелью фильтров
        if (
            e.target.closest('.fab-container') ||
            e.target.closest('#theme-toggle') ||
            e.target.closest('#filters-panel') ||
            e.target.closest('#solubility-search-panel')
        ) return;
        if (e.target.closest('.modal-content')) return;
        closeSolubility();
    }, true);
}
function setupSolubilityPanHints() {
    const content = document.querySelector('.solubility-content');
    const wrapper = document.querySelector('.solubility-wrapper');
    if (!content || !wrapper) return;

    let hints = wrapper.querySelector('.pan-hints--solubility');
    if (!hints) {
        const existingInContent = content.querySelector('.pan-hints--solubility');
        if (existingInContent) {
            hints = existingInContent;
            wrapper.appendChild(hints);
        } else {
        hints = document.createElement('div');
        hints.className = 'pan-hints pan-hints--solubility';
        hints.innerHTML = `
            <div class="pan-hint pan-hint--left"></div>
            <div class="pan-hint pan-hint--right"></div>
            <div class="pan-hint pan-hint--top"></div>
            <div class="pan-hint pan-hint--bottom"></div>
        `;
        wrapper.appendChild(hints);
        }
    }

    const left = hints.querySelector('.pan-hint--left');
    const right = hints.querySelector('.pan-hint--right');
    const top = hints.querySelector('.pan-hint--top');
    const bottom = hints.querySelector('.pan-hint--bottom');

    const update = () => {
        const maxX = Math.max(0, wrapper.scrollWidth - wrapper.clientWidth);
        const maxY = Math.max(0, wrapper.scrollHeight - wrapper.clientHeight);
        const x = wrapper.scrollLeft;
        const y = wrapper.scrollTop;

        left.classList.toggle('is-visible', x > 2);
        right.classList.toggle('is-visible', x < maxX - 2);
        top.classList.toggle('is-visible', y > 2);
        bottom.classList.toggle('is-visible', y < maxY - 2);
    };

    wrapper.addEventListener('scroll', update, { passive: true });
    window.addEventListener('resize', update);
    update();

    if (!sessionStorage.getItem('solubilityPanHintShown')) {
        sessionStorage.setItem('solubilityPanHintShown', '1');
        setTimeout(() => {
            const maxX = Math.max(0, wrapper.scrollWidth - wrapper.clientWidth);
            if (maxX > 0) {
                wrapper.scrollLeft += 10;
                setTimeout(() => {
                    wrapper.scrollLeft -= 10;
                }, 220);
            }
        }, 400);
    }
}


============================================================
ФАЙЛ: .\js\solubility\MODULES_STRUCTURE.md
============================================================

# Структура модулей таблицы растворимости

## Описание модулей

Файл `js/solubility.js` был разделен на 6 логических модулей:

### 1. **solubility-data.js** - Данные таблицы
- `substanceColors` - объект с цветами веществ
- `solubilityData` - данные таблицы (катионы, анионы, правила, исключения)
- `activityData` - данные для ряда активности металлов и неметаллов
- `getSolubility()` - функция получения растворимости

### 2. **solubility-colors.js** - Работа с цветами
- `isColorMode` - флаг режима цветов
- `normalizeFormula()` - нормализация химических формул
- `isColorDark()` - определение темных цветов
- `toggleColorMode()` - переключение режима цветов
- `getColorName()` - конвертация цвета в русское название
- `hexToRgb()` - конвертация HEX в RGB
- `approximateColorByRGB()` - приблизительное определение цвета
- `getUniqueColorsFromTable()` - получение уникальных цветов
- `toggleNonmetalsSeries()` - переключение металлы/неметаллы

### 3. **solubility-table.js** - Рендеринг и подсветка
- `renderSolubilityTable()` - отрисовка таблицы
- `clearTableSelection()` - сброс выделения
- `highlightCrosshair()` - подсветка крестовины
- `highlightColumn()` - подсветка столбца
- `highlightRow()` - подсветка строки
- `enableDragScroll()` - drag-to-scroll для таблицы
- `getCellSubstanceKey()` - получение ключа вещества
- `initActivitySeriesUI()` - инициализация UI ряда активности
- `toggleActivityContainerDisplay()` - показ/скрытие ряда активности
- `renderActivityContent()` - рендер содержимого ряда активности
- `toggleActivitySeries()` - переключение панели рядов активности
- `isMetalsView` - флаг отображения металлов/неметаллов

### 4. **solubility-filters.js** - Фильтрация
- `originalCategoriesHTML` - сохраненные оригинальные категории
- `updateFiltersForSolubility()` - обновление фильтров
- `filterByColor()` - фильтрация по цвету
- `filterBySolubility()` - фильтрация по растворимости
- `resetSolubilityTableDisplay()` - сброс фильтрации
- `restoreElementFilters()` - восстановление фильтров элементов

### 5. **solubility-search.js** - Поиск
- `toggleSolubilitySearch()` - переключение панели поиска
- `clearSolubilitySearch()` - очистка поиска
- `performSolubilitySearch()` - выполнение поиска
- `parseChemicalFormula()` - парсинг химических формул
- `searchInSolubilityTable()` - поиск в таблице
- Автоинициализация обработчиков поиска (IIFE)

### 6. **solubility-modal.js** - Модальное окно
- `toggleSolubility()` - переключение модального окна
- `openSolubility()` - открытие таблицы
- `closeSolubility()` - закрытие таблицы

## Порядок подключения в HTML

**ВАЖНО:** Модули должны подключаться в строго определенном порядке!

```html
<!-- 1. Данные (ПЕРВЫМ!) -->
<script src="js/solubility/solubility-data.js"></script>

<!-- 2. Цвета (использует данные) -->
<script src="js/solubility/solubility-colors.js"></script>

<!-- 3. Таблица (использует данные и цвета) -->
<script src="js/solubility/solubility-table.js"></script>

<!-- 4. Фильтры (использует таблицу и цвета) -->
<script src="js/solubility/solubility-filters.js"></script>

<!-- 5. Поиск (использует таблицу) -->
<script src="js/solubility/solubility-search.js"></script>

<!-- 6. Модальное окно (использует все предыдущие) -->
<script src="js/solubility/solubility-modal.js"></script>
```

## Зависимости между модулями

```
solubility-data.js (независим)
    ↓
solubility-colors.js (использует: normalizeFormula, substanceColors, solubilityData)
    ↓
solubility-table.js (использует: getSolubility, normalizeFormula, substanceColors, isColorMode)
    ↓
solubility-filters.js (использует: getUniqueColorsFromTable, resetSolubilityTableDisplay)
    ↓
solubility-search.js (использует: highlightCrosshair, highlightColumn, highlightRow)
    ↓
solubility-modal.js (использует: renderSolubilityTable, updateFiltersForSolubility, enableDragScroll)
```

## Особенности реализации

1. **НЕ используются ES6 modules** - все функции и переменные глобальные
2. **Порядок загрузки критичен** - каждый модуль зависит от предыдущих
3. **Все комментарии сохранены** из оригинального файла
4. **Функциональность полностью сохранена** - никаких изменений в логике
5. **Самодостаточность модулей** - при условии правильного порядка загрузки

## Внешние зависимости

Модули используют следующие функции из других частей приложения:
- `openAdvancedModal()` - из advanced-modal.js
- `resetTableDisplay()` - из основного скрипта таблицы элементов
- `applyCategoryFilter()` - из фильтров элементов
- `DeviceUtils.getDeviceType()` - из utils.js для определения типа устройства
- `DeviceUtils.addDeviceClassToBody()` - из utils.js для адаптации интерфейса под устройство

## Примечания

- Модуль `solubility-search.js` содержит IIFE для автоинициализации обработчиков
- Модуль `solubility-data.js` должен быть загружен первым, т.к. содержит все данные
- Флаги `isColorMode` и `isMetalsView` являются глобальными переменными состояния


============================================================
ФАЙЛ: .\js\solubility\README.md
============================================================

# Модуль таблицы растворимости

Этот модуль содержит функционал продвинутого режима для таблицы растворимости.

## Структура файлов

### `substances-data.js`
База данных с детальной информацией о веществах (аналог `elements.js` для основной таблицы).

**Структура данных:**
```javascript
{
    "Катион-Анион": {
        // 1. Химическая информация
        name: "Название вещества",
        formula: "Формула",
        molarMass: number,
        oxidationStates: {},
        compoundType: "Тип соединения",

        // 2. Растворимость
        solubility: {
            status: "R/N/M/D",
            value: number,
            ksp: number,
            temperatureDependence: string,
            solubilityTable: []
        },

        // 3. Внешний вид
        appearance: {
            precipitateColor: string,
            crystalColor: string,
            realLifeExample: string
        },

        // 4. Стабильность
        stability: {
            decomposition: boolean,
            characteristicReactions: [],
            analyticalUse: string
        },

        // 5. Применение
        applications: [],
        safety: {},

        // 6. Дополнительно
        additionalInfo: {},
        sources: []
    }
}
```

### `advanced-modal.js`
Логика модального окна продвинутого режима.

**Основные функции:**
- `openAdvancedModal(cationFormula, anionFormula)` - открыть окно
- `closeAdvancedModal()` - закрыть окно
- `switchAdvancedTab(tabName)` - переключение вкладок
- `copyFormula(formula)` - копирование формулы

## Использование

### Открытие модального окна
- **Десктоп:** Двойной клик по ячейке таблицы
- **Мобильные:** Долгое нажатие (500 мс) на ячейку

### Интеграции
- Данные таблицы используются в LaTeX-экспорте (`js/modules/latex-export.js`).

### Добавление данных о новом веществе

1. Определите ключ: `normalizeFormula(катион)-normalizeFormula(анион)`
   - Например: `"Ba2+-SO42-"` для BaSO₄

2. Добавьте объект в `substances-data.js`:
```javascript
"Ba2+-SO42-": {
    name: "Сульфат бария",
    formula: "BaSO₄",
    // ... остальные поля
}
```

3. Заполните все разделы (см. примеры в файле)

## Вкладки модального окна

1. **Химия** - формула, молярная масса, степени окисления
2. **Растворимость** - точные данные, Ksp, зависимость от температуры
3. **Внешний вид** - цвета, кристаллическая система
4. **Реакции** - стабильность, характерные реакции
5. **Применение** - использование, безопасность, интересные факты

## Стили

Стили находятся в `css/advanced-modal.css`:
- Адаптивный дизайн (десктоп + мобильные)
- Поддержка темной темы
- Вкладочная навигация
- Анимации

## TODO

- [ ] Добавить данные для всех веществ из таблицы (528 комбинаций)
- [ ] Добавить графики растворимости vs температура
- [ ] Экспорт данных в PDF/JSON
- [ ] Режим сравнения веществ
- [ ] Поиск по веществам
- [ ] Оптимизация отображения на мобильных устройствах (размеры кнопок и иконок)

## Источники данных

Рекомендуемые источники для заполнения:
- CRC Handbook of Chemistry and Physics
- NIST Chemistry WebBook
- Справочник химика (Никольский Б.П.)
- Лурье Ю.Ю. "Справочник по аналитической химии"


============================================================
ФАЙЛ: .\js\solubility\search.js
============================================================

// =========================================
// ЛОГИКА ПОИСКА В ТАБЛИЦЕ РАСТВОРИМОСТИ (мобильная)
// =========================================
function toggleSolubilitySearch() {
    const panel = document.getElementById('solubility-search-panel');
    const btn = document.getElementById('solubility-search-btn');

    if (panel) {
        panel.classList.toggle('active');
        if (btn) btn.classList.toggle('active');

        // Фокус на поле ввода при открытии
        if (panel.classList.contains('active')) {
            const input = document.getElementById('solubility-search-input');
            if (input) {
                setTimeout(() => input.focus(), 100);
            }
        }
    }
}

function clearSolubilitySearch() {
    const input = document.getElementById('solubility-search-input');
    const clearBtn = document.querySelector('.solubility-search-clear');

    if (input) input.value = '';
    if (clearBtn) clearBtn.classList.remove('visible');

    // Сбрасываем выделение в таблице
    clearTableSelection();
}

function performSolubilitySearch() {
    const input = document.getElementById('solubility-search-input');
    if (!input) return;

    const query = input.value.trim();
    if (query.length < 2) {
        return;
    }

    // Используем уже существующую функцию поиска
    const found = searchInSolubilityTable(query);

    if (found) {
        // Закрываем панель поиска после успешного поиска
        toggleSolubilitySearch();
    }
}

// Инициализация обработчиков для поиска в таблице растворимости
(function initSolubilitySearch() {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupSolubilitySearch);
    } else {
        setupSolubilitySearch();
    }

    function setupSolubilitySearch() {
        const searchInput = document.getElementById('solubility-search-input');
        const clearBtn = document.querySelector('.solubility-search-clear');

        if (!searchInput) return;

        // Показываем/скрываем кнопку очистки при вводе
        searchInput.addEventListener('input', (e) => {
            if (clearBtn) {
                if (e.target.value.length > 0) {
                    clearBtn.classList.add('visible');
                } else {
                    clearBtn.classList.remove('visible');
                }
            }
        });

        // Enter для поиска
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                performSolubilitySearch();
            }
        });
    }
})();

// =========================================
// ПАРСИНГ И ПОИСК ХИМИЧЕСКИХ ФОРМУЛ
// =========================================

function parseChemicalFormula(query) {
    query = query.toLowerCase().trim();

    // Словарь катионов (формула без заряда → индекс в массиве)
    const cationMap = {
        'h': 0, 'nh4': 1, 'li': 2, 'k': 3, 'na': 4, 'rb': 5, 'cs': 6,
        'ag': 7, 'mg': 8, 'ca': 9, 'sr': 10, 'ba': 11, 'zn': 12,
        'hg': 13, 'pb': 14, 'cu': 15, 'fe': 16, 'al': 18, 'cr': 19,
        'mn': 20, 'ni': 21, 'co': 22, 'sn': 23
    };

    // Словарь анионов (формула без заряда → индекс в массиве)
    // Важно: многоатомные анионы с цифрами должны быть включены
    const anionMap = {
        'oh': 0, 'f': 1, 'cl': 2, 'br': 3, 'i': 4, 's': 5, 'hs': 6,
        'so3': 7, 'so4': 8, 'no3': 9, 'po4': 10, 'co3': 11, 'sio3': 12,
        'cro4': 13, 'ch3coo': 14, 'mno4': 15,
        // Альтернативные написания
        'acetate': 14, 'ac': 14
    };

    let foundCatIndex = -1;
    let foundAnIndex = -1;

    // Паттерны для распознавания формул
    // Пробуем найти известные катионы в начале формулы
    const cationKeys = Object.keys(cationMap).sort((a, b) => b.length - a.length); // Сначала длинные
    const anionKeys = Object.keys(anionMap).sort((a, b) => b.length - a.length);

    // Нормализуем запрос: убираем только скобки и символы зарядов, НО оставляем цифры
    const normalizedWithNumbers = query.replace(/[₂₃₄₅²³⁺⁻\(\)\[\]]/g, '');
    // Версия без цифр - для поиска катионов
    const normalizedNoCatNumbers = query.replace(/[₂₃₄₅²³⁺⁻\(\)\[\]]/g, '');

    // Ищем катион в начале
    for (const cat of cationKeys) {
        if (normalizedWithNumbers.startsWith(cat)) {
            foundCatIndex = cationMap[cat];
            // Пробуем найти анион в оставшейся части (с цифрами!)
            let remainder = normalizedWithNumbers.slice(cat.length);
            // Убираем возможную цифру после катиона (например, Ba3 в Ba3(PO4)2)
            remainder = remainder.replace(/^[0-9]+/, '');

            for (const an of anionKeys) {
                if (remainder === an || remainder.startsWith(an)) {
                    foundAnIndex = anionMap[an];
                    break;
                }
            }
            break;
        }
    }

    // Если не нашли анион, ищем отдельно (с цифрами в названии)
    if (foundAnIndex === -1) {
        for (const an of anionKeys) {
            if (normalizedWithNumbers.includes(an)) {
                foundAnIndex = anionMap[an];
                break;
            }
        }
    }

    return { cationIndex: foundCatIndex, anionIndex: foundAnIndex };
}

// Поиск внутри таблицы растворимости (улучшенная версия)
function searchInSolubilityTable(query) {
    query = query.toLowerCase().trim();

    // Сначала пробуем распарсить как полную формулу (NaCl, BaSO4 и т.д.)
    const parsed = parseChemicalFormula(query);
    let foundRowIndex = parsed.anionIndex;
    let foundColIndex = parsed.cationIndex;

    // Если парсинг формулы не дал результата, ищем по названиям
    if (foundRowIndex === -1) {
        // 1. Ищем АНИОН (строку) по названию
        for (let i = 0; i < solubilityData.anions.length; i++) {
            const a = solubilityData.anions[i];
            const name = a.n.toLowerCase();
            const formula = a.f.toLowerCase().replace('-', '').replace('2', '').replace('3', '').replace('⁻', '').replace('₂', '').replace('₃', '');

            if (query.includes(name) || query.includes(formula)) {
                foundRowIndex = i;
                break;
            }
        }
    }

    if (foundColIndex === -1) {
        // 2. Ищем КАТИОН (столбец) по названию
        for (let i = 0; i < solubilityData.cations.length; i++) {
            const c = solubilityData.cations[i];
            const name = c.n.toLowerCase();
            const formula = c.f.toLowerCase().replace('+', '').replace('2', '').replace('3', '').replace('⁺', '').replace('²', '').replace('₂', '');

            // Ищем вхождение запроса в имя/формулу катиона (а не наоборот!)
            if (name.includes(query) || formula.includes(query)) {
                foundColIndex = i;
                break;
            }
        }
    }

    // 3. Открываем таблицу, если нашли хоть что-то
    if (foundRowIndex !== -1 || foundColIndex !== -1) {
        // Открываем модалку (если закрыта)
        const modal = document.getElementById('solubility-modal');
        if (modal.style.display !== 'flex') {
            if (typeof toggleSolubility === 'function') {
                toggleSolubility();
            } else {
                console.error('[SEARCH] toggleSolubility не найдена!');
                modal.style.display = 'flex'; // Фоллбэк: открываем вручную
                renderSolubilityTable(); // И рендерим таблицу
            }
        }

        // Закрываем панель фильтров
        const filtersPanel = document.getElementById('filters-panel');
        if (filtersPanel && filtersPanel.classList.contains('active')) {
            if (!filtersPanel.classList.contains('closing')) {
                filtersPanel.classList.add('closing');
                setTimeout(() => {
                    filtersPanel.classList.remove('active', 'closing');
                }, 360);
            }
        }

        // Выделяем найденное
        setTimeout(() => {
            if (foundRowIndex !== -1 && foundColIndex !== -1) {
                // Нашли И катион, И анион → крестовина
                highlightCrosshair(foundRowIndex, foundColIndex);

                const table = document.getElementById('solubility-table');
                const cell = table.rows[foundRowIndex + 1].cells[foundColIndex + 1];
                cell.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
            } else if (foundColIndex !== -1) {
                // Нашли ТОЛЬКО катион → подсвечиваем столбец
                highlightColumn(foundColIndex);

                const table = document.getElementById('solubility-table');
                const header = table.rows[0].cells[foundColIndex + 1];
                header.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
            } else if (foundRowIndex !== -1) {
                // Нашли ТОЛЬКО анион → подсвечиваем строку
                highlightRow(foundRowIndex);

                const table = document.getElementById('solubility-table');
                const header = table.rows[foundRowIndex + 1].cells[0];
                header.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'start' });
            }
        }, 300);

        return true; // Успех
    }

    return false; // Ничего не нашли
}


============================================================
ФАЙЛ: .\js\solubility\solubility-table.js
============================================================

// =========================================
// РЕНДЕРИНГ ТАБЛИЦЫ РАСТВОРИМОСТИ
// =========================================

// Функция отрисовки (Вызывать 1 раз при старте или открытии)
function renderSolubilityTable() {
    const table = document.getElementById('solubility-table');
    if (!table) return;
    table.innerHTML = '';

    // 1. HEADER (Катионы)
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    // Пустой угол (кнопка сброса выделения)
    const corner = document.createElement('th');
    corner.innerText = "";
    corner.style.cursor = "pointer";
    corner.onclick = clearTableSelection;
    corner.title = "Сбросить выделение";
    headerRow.appendChild(corner);

    // Цикл по катионам (ЗАГОЛОВКИ)
    solubilityData.cations.forEach((cat, colIndex) => {
        const th = document.createElement('th');
        th.innerHTML = cat.f;
        th.title = cat.n;
        th.dataset.col = colIndex;
        th.onclick = () => highlightColumn(colIndex);
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // 2. BODY (Анионы + Данные)
    const tbody = document.createElement('tbody');

    solubilityData.anions.forEach((anion, rowIndex) => {
        const tr = document.createElement('tr');

        // Заголовок ряда (Анион)
        const th = document.createElement('th');
        th.innerHTML = `${anion.f}<br><span style="font-size:0.7em; font-weight:normal">${anion.n}</span>`;
        th.dataset.row = rowIndex;
        // Клик по аниону -> выделяет весь ряд
        th.onclick = () => highlightRow(rowIndex);
        tr.appendChild(th);

        // Данные строки (НОВАЯ СИСТЕМА - используем getSolubility)
        solubilityData.cations.forEach((cat, colIndex) => {
            const td = document.createElement('td');

            // Получаем растворимость через новую функцию
            const solubility = getSolubility(cat.f, anion.f);

            // Расшифровка символа
            let text = '';
            let className = '';

            switch (solubility) {
                case 'R': text = 'Р'; className = 'type-r'; break;
                case 'N': text = 'Н'; className = 'type-n'; break;
                case 'M': text = 'М'; className = 'type-m'; break;
                case 'D': text = '-'; className = 'type-d'; break;
                case 'O': text = ''; className = 'type-d'; break;
                default: text = '?'; className = '';
            }

            td.innerText = text;
            td.className = className;

            // === РЕЖИМ РЕАЛЬНЫХ ЦВЕТОВ ===
            if (window.isColorMode) {
                const catKey = normalizeFormula(cat.f);
                const anionKey = normalizeFormula(anion.f);
                const colorKey = `${catKey}-${anionKey}`;

                const chemColor = substanceColors[colorKey];

                // Пропускаем разлагающиеся вещества (D, O)
                if (solubility === 'D' || solubility === 'O') {
                    // Не красим — оставляем серым
                }
                else if (chemColor) {
                    // Есть конкретный цвет в базе
                    td.classList.add('chem-color-cell');

                    if (chemColor === "white") {
                        td.classList.add('white-precipitate', 'light-bg');
                    } else if (chemColor === "colorless") {
                        td.classList.add('colorless-solution', 'light-bg');
                    } else {
                        td.style.backgroundColor = chemColor;
                        if (isColorDark(chemColor)) {
                            td.classList.add('dark-bg');
                        } else {
                            td.classList.add('light-bg');
                        }
                    }
                }
                else if (solubility === 'R') {
                    // Растворимо, но нет в базе → пробуем анионные цвета (MnO4-, CrO4(2-), Cr2O7(2-))
                    let fallbackColor = null;
                    if (anionKey === 'MnO4-') {
                        fallbackColor = '#8b008b';
                    } else if (anionKey === 'CrO42-') {
                        fallbackColor = '#ffff00';
                    } else if (anionKey === 'Cr2O72-') {
                        fallbackColor = '#ff8c00';
                    }

                    if (fallbackColor) {
                        td.classList.add('chem-color-cell');
                        td.style.backgroundColor = fallbackColor;
                        td.classList.add(isColorDark(fallbackColor) ? 'dark-bg' : 'light-bg');
                    } else {
                        // Растворимо, но нет в базе → бесцветный раствор
                        td.classList.add('chem-color-cell', 'colorless-solution', 'light-bg');
                    }
                }
                else if (solubility === 'N' || solubility === 'M') {
                    // Нерастворимо/малорастворимо, но нет в базе → белый осадок
                    td.classList.add('chem-color-cell', 'white-precipitate', 'light-bg');
                }
            }

            // === КОНЕЦ РЕЖИМА ЦВЕТОВ ===

            td.dataset.r = rowIndex;
            td.dataset.c = colIndex;

            // Одинарный клик - подсветка ИЛИ продвинутый режим
            td.onclick = (e) => {
                e.stopPropagation();

                // Если включён продвинутый режим — открываем модалку
                if (typeof isAdvancedClickMode !== 'undefined' && isAdvancedClickMode) {
                    const cation = solubilityData.cations[colIndex];
                    const anion = solubilityData.anions[rowIndex];
                    if (cation && anion && typeof openAdvancedModal !== 'undefined') {
                        openAdvancedModal(cation.f, anion.f);
                    }
                    return;
                }

                // Иначе — обычная подсветка крестовиной
                highlightCrosshair(rowIndex, colIndex);
            };

            // Двойной клик - продвинутый режим
            td.ondblclick = (e) => {
                e.stopPropagation();
                const cation = solubilityData.cations[colIndex];
                const anion = solubilityData.anions[rowIndex];
                if (cation && anion && typeof openAdvancedModal !== 'undefined') {
                    openAdvancedModal(cation.f, anion.f);
                }
            };

            // Для мобильных: долгое нажатие (500мс)
            let touchTimer;
            let touchHandled = false;

            td.addEventListener('touchstart', (e) => {
                touchHandled = false;
                touchTimer = setTimeout(() => {
                    const cation = solubilityData.cations[colIndex];
                    const anion = solubilityData.anions[rowIndex];
                    if (cation && anion && typeof openAdvancedModal !== 'undefined') {
                        touchHandled = true;
                        openAdvancedModal(cation.f, anion.f);
                    }
                }, 500);
            }, { passive: true }); // Passive: true для улучшения производительности скролла

            td.addEventListener('touchend', () => {
                clearTimeout(touchTimer);
            }, { passive: true });

            td.addEventListener('touchmove', () => {
                clearTimeout(touchTimer);
            }, { passive: true });

            tr.appendChild(td);
        });
        tbody.appendChild(tr);
    });
    table.appendChild(tbody);
}

// =========================================
// ЛОГИКА ПОДСВЕТКИ (КРЕСТОВИНА)
// =========================================

function clearTableSelection() {
    // Удаляем все классы активности
    document.querySelectorAll('.active-row, .active-col, .focused-cell, .active-header')
        .forEach(el => {
            el.classList.remove('active-row', 'active-col', 'focused-cell', 'active-header');
        });
}
// Выделение крестовины (клик по ячейке)
function highlightCrosshair(rIdx, cIdx) {
    const table = document.getElementById('solubility-table');
    const targetCell = table.rows[rIdx + 1].cells[cIdx + 1];

    // ПРОВЕРКА: Если эта ячейка уже активна — сбрасываем всё
    if (targetCell.classList.contains('focused-cell')) {
        clearTableSelection();
        return;
    }

    // Иначе — сначала чистим старое, потом выделяем новое
    clearTableSelection();

    // 1. Подсвечиваем заголовки
    const rowHeader = table.rows[rIdx + 1].cells[0];
    const colHeader = table.rows[0].cells[cIdx + 1];

    rowHeader.classList.add('active-header');
    colHeader.classList.add('active-header');

    // 2. Подсвечиваем ячейку
    targetCell.classList.add('focused-cell');

    // 3. Красим ряд
    const rowCells = table.rows[rIdx + 1].cells;
    for (let i = 1; i < rowCells.length; i++) {
        rowCells[i].classList.add('active-row');
    }

    // 4. Красим столбец
    for (let i = 1; i < table.rows.length; i++) {
        const cell = table.rows[i].cells[cIdx + 1];
        if (cell) cell.classList.add('active-col');
    }
}

// Выделение столбца (клик по катиону)
function highlightColumn(cIdx) {
    const table = document.getElementById('solubility-table');
    const header = table.rows[0].cells[cIdx + 1];

    // ПРОВЕРКА ТОГГЛА
    if (header.classList.contains('active-header')) {
        clearTableSelection();
        return;
    }

    clearTableSelection();

    header.classList.add('active-header');
    for (let i = 1; i < table.rows.length; i++) {
        const cell = table.rows[i].cells[cIdx + 1];
        if (cell) cell.classList.add('active-col');
    }
}

// Выделение строки (клик по аниону)
function highlightRow(rIdx) {
    const table = document.getElementById('solubility-table');
    const header = table.rows[rIdx + 1].cells[0];

    // ПРОВЕРКА ТОГГЛА
    if (header.classList.contains('active-header')) {
        clearTableSelection();
        return;
    }

    clearTableSelection();

    header.classList.add('active-header');
    const rowCells = table.rows[rIdx + 1].cells;
    for (let i = 1; i < rowCells.length; i++) {
        rowCells[i].classList.add('active-row');
    }
}

// =========================================
// DRAG-TO-SCROLL ДЛЯ ТАБЛИЦЫ
// =========================================
function enableDragScroll(element) {
    let isDown = false;
    let startX, startY, scrollLeft, scrollTop;
    let isTouch = false;

    // #region agent log
    // fetch('http://127.0.0.1:7242/ingest/62ca497c-fdce-4d75-9803-1df85cc7de10',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solubility-table.js:266',message:'enableDragScroll called',data:{hasTouchSupport:'ontouchstart' in window,elementTag:element.tagName},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
    // #endregion

    // Mouse events (Desktop)
    element.addEventListener('mousedown', (e) => {
        // #region agent log
        // fetch('http://127.0.0.1:7242/ingest/62ca497c-fdce-4d75-9803-1df85cc7de10',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solubility-table.js:270',message:'mousedown event',data:{targetTag:e.target.tagName,isTouch:false},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        // Не мешаем кликам по ячейкам таблицы и заголовкам
        if (e.target.tagName === 'TD' || e.target.tagName === 'TH') return;

        isDown = true;
        isTouch = false;
        element.style.cursor = 'grabbing';
        element.style.userSelect = 'none';

        startX = e.pageX - element.offsetLeft;
        startY = e.pageY - element.offsetTop;
        scrollLeft = element.scrollLeft;
        scrollTop = element.scrollTop;
    });

    element.addEventListener('mouseleave', () => {
        isDown = false;
        element.style.cursor = 'grab';
    });

    element.addEventListener('mouseup', () => {
        isDown = false;
        element.style.cursor = 'grab';
        element.style.userSelect = '';
    });

    element.addEventListener('mousemove', (e) => {
        if (!isDown || isTouch) return;
        e.preventDefault();

        const x = e.pageX - element.offsetLeft;
        const y = e.pageY - element.offsetTop;
        const walkX = (x - startX) * 1.5; // Множитель для скорости прокрутки
        const walkY = (y - startY) * 1.5;

        element.scrollLeft = scrollLeft - walkX;
        element.scrollTop = scrollTop - walkY;
    });

    // Touch events (Mobile) - ИСПРАВЛЕНИЕ
    element.addEventListener('touchstart', (e) => {
        // #region agent log
        // fetch('http://127.0.0.1:7242/ingest/62ca497c-fdce-4d75-9803-1df85cc7de10',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solubility-table.js:touchstart',message:'touchstart event',data:{touchCount:e.touches.length,targetTag:e.target.tagName},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        // Не мешаем кликам по ячейкам таблицы и заголовкам
        if (e.target.tagName === 'TD' || e.target.tagName === 'TH') return;

        if (e.touches.length === 1) {
            const touch = e.touches[0];
            isDown = true;
            isTouch = true;
            element.style.userSelect = 'none';

            const rect = element.getBoundingClientRect();
            startX = touch.clientX - rect.left;
            startY = touch.clientY - rect.top;
            scrollLeft = element.scrollLeft;
            scrollTop = element.scrollTop;
        }
    }, { passive: true });

    element.addEventListener('touchmove', (e) => {
        if (!isDown || !isTouch) return;
        if (e.touches.length === 1) {
            if (e.cancelable) {
                e.preventDefault();
            }
            const touch = e.touches[0];
            const rect = element.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const walkX = (x - startX) * 1.5;
            const walkY = (y - startY) * 1.5;

            element.scrollLeft = scrollLeft - walkX;
            element.scrollTop = scrollTop - walkY;
        }
    }, { passive: false });

    element.addEventListener('touchend', () => {
        // #region agent log
        // fetch('http://127.0.0.1:7242/ingest/62ca497c-fdce-4d75-9803-1df85cc7de10',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'solubility-table.js:touchend',message:'touchend event',data:{isDown},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        isDown = false;
        isTouch = false;
        element.style.userSelect = '';
    }, { passive: true });
}

// Получить ключ вещества для ячейки
function getCellSubstanceKey(rowIndex, colIndex) {
    const anion = solubilityData.anions[rowIndex];
    const cation = solubilityData.cations[colIndex];

    if (!anion || !cation) return '';

    const catKey = normalizeFormula(cation.f);
    const anionKey = normalizeFormula(anion.f);

    return `${catKey}-${anionKey}`;
}

// ... (весь код выше, до строки "// РЯД АКТИВНОСТИ ...", оставляем без изменений)

// =========================================
// РЯД АКТИВНОСТИ (ФИНАЛЬНАЯ ВЕРСИЯ)
// =========================================

var isMetalsView = true;

function updateActivitySeriesFlow(container) {
    if (!container) return;

    const grid = container.querySelector('.series-container.activity-grid');
    if (!grid) return;

    const items = Array.from(grid.querySelectorAll('.act-item'));
    if (items.length < 2) return;

    items.forEach(item => item.classList.remove('row-end-turn'));

    const gridTemplateColumns = getComputedStyle(grid).gridTemplateColumns || '';
    const columns = gridTemplateColumns
        .split(' ')
        .map(token => token.trim())
        .filter(Boolean)
        .length;

    if (!Number.isFinite(columns) || columns < 1) return;

    for (let i = 0; i < items.length - 1; i++) {
        if ((i + 1) % columns === 0) {
            items[i].classList.add('row-end-turn');
        }
    }
}

if (!window.__activitySeriesResizeBound) {
    window.__activitySeriesResizeBound = true;
    window.addEventListener('resize', () => {
        const panel = document.getElementById('activity-series-panel');
        if (!panel || !panel.classList.contains('active')) return;
        requestAnimationFrame(() => updateActivitySeriesFlow(panel));
    });
}

// 1. Функция отрисовки карточек
window.renderActivitySeries = function () {
    const container = document.getElementById('activity-series-panel');
    if (!container) return;

    // Данные элементов
    const metals = ["Li", "Rb", "K", "Ba", "Sr", "Ca", "Na", "Mg", "Al", "Mn", "Zn", "Cr", "Fe", "Cd", "Co", "Ni", "Sn", "Pb", "H", "Sb", "Bi", "Cu", "Hg", "Ag", "Pt", "Au"];
    const nonMetals = ["F", "O", "N", "Cl", "Br", "I", "S", "C", "P", "Si"];

    // Выбираем список
    const currentList = isMetalsView ? metals : nonMetals;

    // Тексты
    const titleText = isMetalsView
        ? "Ряд активности металлов"
        : "Ряд активности неметаллов";

    const btnText = isMetalsView
        ? "Переключить на неметаллы"
        : "Переключить на металлы";

    const noteText = isMetalsView
        ? "← Активность (восстановители) . . . Пассивность (окислители) →"
        : "← Сильные окислители . . . Слабые окислители →";

    // Генерируем HTML карточек
    const gridClass = isMetalsView ? 'activity-grid--metals' : 'activity-grid--nonmetals';
    let cardsHTML = '';
    currentList.forEach((symbol, idx) => {
        const isHydrogen = (symbol === 'H' && isMetalsView);
        const isLast = idx === currentList.length - 1;
        const className = [
            'act-item',
            isHydrogen ? 'hydrogen' : '',
            isLast ? '' : 'has-next'
        ].filter(Boolean).join(' ');
        const order = idx + 1;

        // Клик открывает модалку элемента
        cardsHTML += `<button type="button" class="${className}" data-order="${order}" title="${order}. ${symbol}" onclick="if(window.openElementModal) window.openElementModal('${symbol}')">${symbol}</button>`;
    });

    // Вставляем в панель
    container.innerHTML = `
        <div class="activity-content-wrapper">
            <div class="activity-header">
                <h4>${titleText}</h4>
                <button id="toggle-series-type-btn" class="toggle-series-btn" type="button">
                    ${btnText}
                </button>
            </div>

            <div class="series-container activity-grid ${gridClass} active">
                ${cardsHTML}
            </div>

            <p class="activity-note">${noteText}</p>
        </div>
    `;

    requestAnimationFrame(() => updateActivitySeriesFlow(container));

    // Вешаем обработчик на внутреннюю кнопку переключения
    const switchBtn = document.getElementById('toggle-series-type-btn');
    if (switchBtn) {
        switchBtn.onclick = function (event) {
            event.preventDefault();
            event.stopPropagation();
            isMetalsView = !isMetalsView;
            window.renderActivitySeries(); // Просто перерисовываем
        };
        switchBtn.addEventListener('pointerdown', (event) => event.stopPropagation());
    }
};

// 2. Главная функция переключения шторки (CSS animation approach)
window.toggleActivitySeries = function () {
    const btn = document.getElementById('activity-mode-btn');
    const panel = document.getElementById('activity-series-panel');

    if (!btn || !panel) return;

    // Инициализация контента при первом клике
    if (!panel.querySelector('.activity-content-wrapper')) {
        window.renderActivitySeries();
    }

    // Просто переключаем класс - CSS делает анимацию
    const isOpening = !panel.classList.contains('active');

    if (isOpening) {
        btn.classList.add('active');
        panel.classList.add('active');
        requestAnimationFrame(() => updateActivitySeriesFlow(panel));
    } else {
        btn.classList.remove('active');
        panel.classList.remove('active');
    }
};


// 3. Инициализация при загрузке
document.addEventListener('DOMContentLoaded', function () {
    const panel = document.getElementById('activity-series-panel');
    if (panel) {
        // Убираем класс active, чтобы панель была скрыта при старте
        panel.classList.remove('active');
    }
});


============================================================
ФАЙЛ: .\latex\README.md
============================================================

# README: Как использовать LaTeX экспорт

## 📦 Что в репозитории

### LaTeX шаблоны:
- `latex/element-template.tex` - основной шаблон документа
- `latex/preamble.tex` - преамбула с пакетами

### JavaScript модуль:
- `js/modules/latex-export.js` - генератор LaTeX файлов

## 🚀 Как это работает

1. Пользователь кликает на элемент в таблице (доступно в веб-версии и Electron)
2. Открывается модальное окно
3. Нажимает кнопку "Экспорт в LaTeX"
4. Скачивается `.tex` файл с данными элемента

## 📝 Формат LaTeX файла

Каждый `.tex` файл содержит:
- Красиво отформатированные химические формулы (через `mhchem`)
- Таблицу базовых свойств
- Таблицу физических свойств
- Историю и применение
- Таблицу всех соединений из таблицы растворимости
> Экспорт доступен для всех 118 элементов.

## 🛠️ Компиляция LaTeX

### Способ 1: Локально (если установлен LaTeX)
```bash
pdflatex H_Водород.tex
```

### Способ 2: Онлайн
Загрузите `.tex` файл на:
- [Overleaf](https://www.overleaf.com/)
- [Papeeria](https://papeeria.com/)
- [ShareLaTeX](https://www.sharelatex.com/)

### Способ 3: GitHub Actions (автоматически)
Можно настроить GitHub Action для автоматической компиляции

## 📦 Необходимые пакеты LaTeX

Для компиляции нужны следующие пакеты:
```latex
inputenc, babel, fontenc,  geometry, graphicx, xcolor,
array, longtable, booktabs, fancyhdr, lastpage, 
hyperref, mhchem
```

Все они входят в стандартную установку TeX Live или MiKTeX.

## 🎨 Кастомизация

### Изменить цвета:
Отредактируйте `latex/element-template.tex`, секцию `\definecolor`

### Изменить структуру:
Модифицируйте секции в `element-template.tex`

### Добавить свои поля:
1. Добавьте плейсхолдер `{{NEW_FIELD}}` в шаблон
2. Добавьте данные в `latex-export.js` в объект `data`

## 🧪 Пример химических формул

LaTeX автоматически отформатирует:
- `\ce{H2O}` → H₂O
- `\ce{Cu^{2+}}` → Cu²⁺
- `\ce{SO4^{2-}}` → SO₄²⁻
- `\ce{Fe(OH)3}` → Fe(OH)₃

## ⚠️ Важно

LaTeX файлы генерируются **в браузере** и скачиваются.
Для получения PDF нужно скомпилировать `.tex` файл отдельно.


============================================================
ФАЙЛ: .\md\AI_CONTEXT.md
============================================================

# AI_CONTEXT.md — Контекст проекта для AI-ассистента

> **Версия:** 1.0.0  
> **Обновлено:** Январь 2026  
> **Назначение:** Быстрое погружение AI в проект без повторных объяснений

---

## 🎯 О проекте

**Химический Ассистент** — интерактивная таблица Менделеева для школьной олимпиады по химии/информатике.

**Ключевые особенности:**
- Работает локально через `file://` протокол
- Никаких сборщиков, фреймворков, серверов
- Модульная динамическая загрузка через `scrypt.js`
- PWA с оффлайн-режимом
- Полностью на русском языке
- **NodeMap** — визуализация архитектуры кода
- **LaTeX экспорт** — генерация `.tex` по элементу
- **Electron Windows/Linux** — десктопные сборки
- **Режим обоев** — только Windows (Electron)

---

## 🛠 Технические ограничения (КРИТИЧНО!)

### ❌ ЗАПРЕЩЕНО:
```javascript
// ES6 модули — CORS ошибка на file://
import { something } from './module.js';  // ❌ НЕЛЬЗЯ
export const data = {};                    // ❌ НЕЛЬЗЯ

// Fetch локальных файлов — CORS ошибка
fetch('./data.json')  // ❌ НЕЛЬЗЯ на file://

// Динамический import
import('./module.js')  // ❌ НЕЛЬЗЯ
```

### ✅ РАЗРЕШЕНО:
```javascript
// Глобальные переменные (window)
const elementsData = { H: {...}, He: {...} };

// IIFE для изоляции
(function() {
    // код модуля
})();

// Динамическая загрузка скриптов (как в scrypt.js)
function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Данные встроены в JS файлы
const solubilityData = { cations: [...], anions: [...], rows: [...] };
```

---

## 📁 Структура проекта

```
mendeleevtable/
├── index.html              # Точка входа, вся HTML-разметка
├── manifest.json           # PWA манифест
├── sw.js                   # Service Worker для оффлайна
│
├── electron-app/           # Electron приложение
│   └── electron/           # main.js, preload.js, wallpaper-api.js
│
├── latex/                  # LaTeX шаблоны экспорта
│   ├── element-template.tex
│   └── preamble.tex
│
├── css/                    # Стили (модульная система)
│   ├── style.css           # Главный файл (только @import)
│   ├── base.css            # Body, canvas, базовые стили
│   ├── table.css           # Сетка периодической таблицы
│   ├── modal.css           # Модальное окно элемента
│   ├── theme.css           # Тёмная тема, волновая анимация
│   ├── fab.css             # FAB-меню (плавающая кнопка)
│   ├── calculator.css      # Калькулятор молярной массы
│   ├── filters.css         # Панель фильтров и поиска
│   ├── solubility.css      # Таблица растворимости
│   ├── advanced-modal.css  # Продвинутая модалка веществ
│   ├── nodemap.css         # NodeMap визуализация
│   └── scroll-collapse.css # Scroll-collapse
│
├── js/
│   ├── scrypt.js           # 🚀 Модульный загрузчик (entry point)
│   ├── icons.js            # SVG-спрайт иконок
│   ├── elements.js         # База данных 118 элементов
│   ├── particles.js        # Canvas: анимация фона + 3D атомы
│   ├── scroll-collapse.js  # Виртуальный скролл и сжатие
│   ├── wallpaper-handler.js # Обои (Electron/Windows)
│   │
│   ├── modules/            # 📦 Основные модули
│   │   ├── modal.js        # Модальное окно элемента
│   │   ├── theme.js        # Тёмная тема + волновая анимация
│   │   ├── calculator.js   # Калькулятор молярной массы
│   │   ├── balancer.js     # Уравниватель реакций
│   │   ├── latex-export.js # Экспорт в LaTeX
│   │   ├── search-filters.js # Поиск и фильтры элементов
│   │   ├── ui.js           # FAB-меню и UI-функции
│   │   └── mobile-layout.js # Мобильная адаптация
│   │
│   ├── solubility/         # 🧪 Таблица растворимости
│   │   ├── data.js         # Данные: катионы, анионы, матрица
│   │   ├── colors.js       # 100+ цветов веществ
│   │   ├── solubility-table.js # Рендеринг таблицы
│   │   ├── filters.js      # Фильтрация и выделение
│   │   ├── search.js       # Поиск веществ
│   │   ├── modal.js        # Открытие/закрытие модалки
│   │   └── advanced-modal.js # Продвинутая модалка
│   │
│   └── nodemap/            # 🗺️ Визуализация архитектуры
│       ├── nodemap-init.js # Инициализация
│       ├── nodemap-parser.js # Парсер функций из window
│       ├── nodemap-layout.js # Force-directed layout
│       ├── nodemap-canvas.js # Canvas рендеринг графа
│       ├── nodemap-modal.js  # UI модального окна
│       ├── nodemap-flow-data.js # Анализ потока данных
│       ├── nodemap-flow-layout.js # Layout для flow-диаграмм
│       └── nodemap-flow-canvas.js # Рендеринг flow-диаграмм
│
└── img/
    ├── favicon.png
    ├── png1.png            # PWA icon 192x192
    └── png2.png            # PWA icon 512x512
```

**Итого:** 11 CSS файлов, 24 JS файла

---

## 🔑 Ключевые структуры данных

### 1. elementsData (js/elements.js)
```javascript
const elementsData = {
    "H": {
        atomicNumber: "1",
        name: "Водород",
        atomicMass: "1.008",
        period: "1",
        group: "1",
        block: "s",
        category: "Неметалл",
        electronConfig: "1s<sup>1</sup>",
        electronegativity: "2.20",
        density: "0.00008988 г/см³",
        meltingPoint: "−259.14 °C",
        boilingPoint: "−252.87 °C",
        state: "Газ",
        color: "Бесцветный",
        discoveryYear: "1766",
        discoverer: "Генри Кавендиш",
        nameOrigin: "От греч. hydro (вода) + genes (рождающий)",
        applications: "...",
        facts: "...",
        // Опционально для элементов с аллотропами:
        allotropes: { 
            graphite: {...}, 
            diamond: {...} 
        },
        extraAllotropes: { 
            fullerene: {...} 
        }
    },
    // ... ещё 117 элементов (до Og)
};
```

### 2. solubilityData (js/solubility/data.js)
```javascript
const solubilityData = {
    cations: [
        { f: "H⁺", n: "Водород" },
        { f: "NH₄⁺", n: "Аммоний" },
        // ... 24 катиона
    ],
    anions: [
        { f: "OH⁻", n: "Гидроксид" },
        { f: "F⁻", n: "Фторид" },
        // ... 16 анионов
    ],
    rows: [
        "ORRRRRR-MMMRNN-NNNNNNNNN", // OH (O=особый, R=раств, M=мало, N=нет)
        "RRRRMMRRMMNNR-RNNRNRRNRR", // F
        // ... 16 строк (по одной на анион)
        // D = разлагается водой
    ]
};
```

### 3. substanceColors (js/solubility/colors.js)
```javascript
const substanceColors = {
    // Гидроксиды
    "Cu(OH)₂": { color: "#7EC8E3", name: "Голубой осадок" },
    "Fe(OH)₃": { color: "#8B4513", name: "Бурый осадок" },
    "Fe(OH)₂": { color: "#228B22", name: "Зеленоватый осадок" },
    
    // Сульфиды (чёрные)
    "CuS": { color: "#1a1a1a", name: "Чёрный осадок" },
    "PbS": { color: "#1a1a1a", name: "Чёрный осадок" },
    "FeS": { color: "#1a1a1a", name: "Чёрный осадок" },
    
    // Иодиды (жёлтые)
    "AgI": { color: "#FFD700", name: "Жёлтый осадок" },
    "PbI₂": { color: "#FFD700", name: "Золотисто-жёлтый осадок" },
    
    // Хроматы (жёлтые)
    "BaCrO₄": { color: "#FFD700", name: "Жёлтый осадок" },
    "PbCrO₄": { color: "#FFA500", name: "Оранжево-жёлтый осадок" },
    
    // Растворы (цветные ионы)
    "CuSO₄": { color: "#87CEEB", name: "Голубой раствор" },
    "CoCl₂": { color: "#FF69B4", name: "Розовый раствор" },
    "NiCl₂": { color: "#90EE90", name: "Зелёный раствор" },
    "KMnO₄": { color: "#8B008B", name: "Фиолетовый раствор" },
    
    // ... 100+ веществ с реалистичными цветами
};
```


---

## 🎨 CSS-классы категорий элементов

```css
/* Светлая тема */
.alkali-metal { background-color: #ff9999; }
.alkaline-earth-metal { background-color: #ffcc99; }
.transition-metal { background-color: #ffff99; }
.post-transition-metal { background-color: #ccff99; }
.metalloid { background-color: #99ffcc; }
.nonmetal { background-color: #99ffff; }
.halogen { background-color: #99ccff; }
.noble-gas { background-color: #cc99ff; }
.lanthanide { background-color: #ff99cc; }
.actinide { background-color: #ff99ff; }

/* Тёмная тема — добавить body.dark-theme перед селектором */
body.dark-theme .alkali-metal { background-color: #8b3a3a; }
// ... и т.д.
```

---

## 🔧 Ключевые функции

### Модульный загрузчик (js/scrypt.js)
```javascript
// Динамическая загрузка модулей
function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Последовательная загрузка модулей
async function initApp() {
    await loadScript('js/icons.js');
    await loadScript('js/elements.js');
    await loadScript('js/modules/theme.js');
    // ... и т.д.
}
```

### Периодическая таблица (js/modules/modal.js)
```javascript
// Открытие модального окна элемента
function openElementModal(symbol) { ... }

// Рендеринг содержимого с аллотропами
function renderModalContent(data) { ... }

// Создание табов аллотропов
function createAllotropeTabs(mainData) { ... }
```

### Тема (js/modules/theme.js)
```javascript
// Переключение темы с волновой анимацией
function toggleTheme() {
    const isDark = document.body.classList.toggle('dark-theme');
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
    
    // Волна запускается от кнопки
    createThemeWave(event.clientX, event.clientY);
}

// Волновая анимация
function createThemeWave(x, y) { ... }
```

### Калькулятор (js/modules/calculator.js)
```javascript
// Добавление атома в калькулятор
function addAtomToCalculator(symbol, fromDrop = false) { ... }

// Пересчёт массы
function updateTotalMass() { ... }

// Drag & Drop поддержка
elementCell.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', symbol);
});
```

### Таблица растворимости (js/solubility/*.js)
```javascript
// Рендеринг таблицы 24×16
function renderSolubilityTable() { ... }

// Выделение крестовиной
function highlightCrosshair(rowIdx, colIdx) { ... }

// Переключение реалистичных цветов
function toggleRealisticColors() {
    isRealisticColors = !isRealisticColors;
    renderSolubilityTable();
}

// Поиск вещества (интегрирован с главным поиском)
function searchInSolubilityTable(query) { ... }

// Продвинутая модалка (двойной клик / долгое нажатие)
function openAdvancedModal(cationFormula, anionFormula) {
    const key = normalizeFormula(cationFormula) + '-' + normalizeFormula(anionFormula);
    const substance = substancesData[key];
    // Рендер 5 вкладок с информацией
}
```

### Поиск и фильтры (js/modules/search-filters.js)
```javascript
// Поиск по всем данным элементов
function searchElements(query) { ... }

// Фильтрация по категории
function applyCategoryFilter(categoryClass) { ... }

// Химический парсер (распознаёт формулы)
function parseChemicalFormula(query) {
    // "BaSO4" → { cation: "Ba2+", anion: "SO42-" }
    // "хлорид натрия" → { cation: "Na+", anion: "Cl-" }
}
```

### NodeMap (js/nodemap/*.js) — НОВОЕ!
```javascript
// Инициализация (клавиша '.')
function initNodeMap() {
    window.addEventListener('keydown', (e) => {
        if (e.key === '.') {
            if (!nodemapOpen) openNodeMap();
            else closeNodeMap();
        }
    });
}

// Парсинг всех функций из window
function parseFunctions() {
    const functions = [];
    for (let key in window) {
        if (typeof window[key] === 'function') {
            const func = window[key];
            const code = func.toString();
            // Анализ кода функции
            functions.push({
                name: key,
                calls: extractFunctionCalls(code),
                lines: code.split('\n').length,
                complexity: calculateComplexity(code),
                params: extractParameters(code)
            });
        }
    }
    return functions;
}

// Force-directed layout
function calculateLayout(nodes, edges) {
    // Алгоритм размещения нод на плоскости
    // Учитывает силы притяжения и отталкивания
}

// Рендеринг на Canvas
function renderGraph(ctx, nodes, edges) {
    // Отрисовка графа с цветовой кодировкой
}

// Поиск и фильтры
function searchFunction(query) { ... }
function filterByType(type) { ... } // 'hub', 'entry', 'leaf', 'island'
```

### Определение устройств (js/utils.js) — НОВОЕ!
```javascript
// Функция для определения типа устройства
function getDeviceType() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;

    // Проверка на iOS
    const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;

    // Проверка на iPhone
    const isIPhone = /iPhone/.test(userAgent) && !window.MSStream;

    // Проверка на iPad
    const isIPad = /iPad/.test(userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

    // Проверка на Android
    const isAndroid = /android/i.test(userAgent);

    // Проверка на Windows
    const isWindows = /Win/.test(userAgent);

    // Проверка на Mac (не iOS)
    const isMac = /Mac/.test(userAgent) && !isIOS;

    // Проверка на Mobile (любое мобильное устройство)
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);

    // Проверка на Touch Device
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

    return {
        isIOS,
        isIPhone,
        isIPad,
        isAndroid,
        isWindows,
        isMac,
        isMobile,
        isTouchDevice
    };
}

// Функция для добавления классов устройства к body
function addDeviceClassToBody() {
    const device = getDeviceType();
    const body = document.body;

    // Удаляем старые классы
    body.classList.remove(
        'device-ios',
        'device-iphone',
        'device-ipad',
        'device-android',
        'device-windows',
        'device-mac',
        'device-mobile',
        'device-touch'
    );

    // Добавляем новые классы в зависимости от устройства
    if (device.isIOS) body.classList.add('device-ios');
    if (device.isIPhone) body.classList.add('device-iphone');
    if (device.isIPad) body.classList.add('device-ipad');
    if (device.isAndroid) body.classList.add('device-android');
    if (device.isWindows) body.classList.add('device-windows');
    if (device.isMac) body.classList.add('device-mac');
    if (device.isMobile) body.classList.add('device-mobile');
    if (device.isTouchDevice) body.classList.add('device-touch');
}
```

---

## 📱 Адаптивность

```css
/* Брейкпоинты */
@media (max-width: 1024px) { 
    /* Планшеты и мобильные */ 
}

@media (max-width: 768px) and (orientation: landscape) { 
    /* Горизонтальная ориентация */ 
}

@media (max-width: 480px) { 
    /* Маленькие телефоны */ 
}

/* Safe Area для iOS (вырез экрана) */
.modal-content {
    padding-top: max(20px, env(safe-area-inset-top));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
}
```

**Ключевые адаптации:**
- Таблица: горизонтальный скролл на мобильных
- Модальное окно: полноэкранное снизу (bottom sheet)
- FAB-меню: горизонтальное расположение слева
- Калькулятор: нижняя панель на всю ширину
- **Таблица растворимости:** полноэкранный режим с учётом safe-area
- **NodeMap:** адаптивный UI, touch-события
- **Определение устройств:** автоматическое добавление классов устройств к body для адаптивных стилей
- **Адаптация интерфейса:** специфичные стили для iPhone и Android устройств

---

## 🚀 Возможности v1.0.0

### Реализовано:
- ✅ Интерактивная таблица 118 элементов
- ✅ Детальная информация по всем 118 элементам
- ✅ Система аллотропов (основные + дополнительные)
- ✅ Тёмная тема с волновой анимацией
- ✅ 3D модели атомов на Canvas
- ✅ Калькулятор молярной массы (Drag & Drop)
- ✅ Поиск по всем данным элементов
- ✅ Фильтры по категориям
- ✅ Таблица растворимости 24×16 (384 соединения)
- ✅ Sticky headers в таблице растворимости
- ✅ Выделение крестовиной (строка + столбец)
- ✅ Режим реалистичных цветов (100+ веществ)
- ✅ Умный поиск веществ (интеграция с таблицей)
- ✅ **Продвинутая модалка** — детальная информация о веществах
- ✅ **substances-data.js** — структурированная база данных
- ✅ **NodeMap** — визуализация архитектуры кода
- ✅ **Мобильная оптимизация** — safe-area, bounce, hidden scrollbars
- ✅ PWA (оффлайн-режим)
- ✅ **Определение устройств** — автоматическое определение типа устройства для адаптивных стилей
- ✅ **Адаптация интерфейса** — оптимизированные размеры элементов для iPhone и Android
- ✅ **LaTeX экспорт** — генерация `.tex` файлов по элементу
- ✅ **Electron Windows/Linux** — десктопные сборки
- ✅ **Режим обоев** — только Windows (Electron)
- ✅ **Оптимизация больших экранов** — адаптивные размеры и отступы


---

## 📝 Правила для AI

### При добавлении кода:
1. **Никаких import/export** — только глобальные переменные
2. **Данные встраивать в JS** — не использовать fetch для JSON
3. **Учитывать file:// протокол** — никаких серверных API
4. **Проверять оба режима** — светлая и тёмная тема
5. **Следовать модульной структуре** — новый функционал в отдельные файлы
6. **Добавлять файлы в scrypt.js** — для динамической загрузки
7. **Обновлять sw.js** — добавлять новые файлы в кэш PWA

### При исправлении багов:
1. **Хирургические правки** — только изменённые строки
2. **Указывать файл и место** — функция/селектор/строка
3. **Не переписывать файлы целиком** — они большие
4. **Тестировать на мобильных** — адаптивность критична

### При работе с данными:
1. **elementsData** — добавлять элементы последовательно
2. **substanceColors** — реалистичные hex-цвета
3. **substancesData** — полная структура (6 разделов)
4. **solubilityData.rows** — проверять на 24 символа

### Формат ответа:
```
В файле `js/modules/calculator.js`, функция `updateTotalMass()`:

// Было:
total = Math.round(total * 100) / 100;

// Стало:
total = Math.round(total * 1000) / 1000;

Причина: Увеличена точность до 3 знаков после запятой.
```

---

## 🔗 Ссылки

- **GitHub:** https://github.com/layfhaker/mendeleevtable
- **GitHub Pages:** https://layfhaker.github.io/mendeleevtable/
- **Документация:**
  - [README.md](../README.md) — общая информация
  - [TODO.md](TODO.md) — задачи и планы
  - [NODEMAP_GUIDE.md](NODEMAP_GUIDE.md) — руководство по NodeMap
  - [js/nodemap/README.md](../js/nodemap/README.md) — техническая документация NodeMap
  - [js/solubility/README.md](../js/solubility/README.md) — модуль растворимости
  - [js/solubility/MODULES_STRUCTURE.md](../js/solubility/MODULES_STRUCTURE.md) — структура модулей

---

## 🎯 Быстрые факты

- **Язык:** Русский
- **Технологии:** HTML5, CSS3, Vanilla JavaScript
- **Размер:** ~150 КБ
- **Функций:** 200+
- **Строк кода:** 6000+
- **CSS файлов:** 11
- **JS модулей:** 24
- **Последнее обновление:** Январь 2026

---

*Проект для школьной олимпиады по химии/информатике*


============================================================
ФАЙЛ: .\md\CHANGELOG.md
============================================================

# 📝 CHANGELOG — История изменений

Все значительные изменения в проекте документируются в этом файле.

Формат основан на [Keep a Changelog](https://keepachangelog.com/ru/1.0.0/),
проект придерживается [Semantic Versioning](https://semver.org/lang/ru/).

---

## [1.0.0] — 2026-01

### 🆕 Добавлено
- Полные данные по всем 118 элементам
- Экспорт элемента в LaTeX (`.tex`)
- Electron сборки для Linux (AppImage / deb / snap)
- Режим обоев для Windows (Electron)

### 🔧 Улучшено
- Оптимизация интерфейса на больших экранах
- Подстройка панелей (калькулятор/уравниватель) под сетку

### 🐛 Исправлено
- Мелкие баги UI и позиционирования панелей

## [0.6.5] — 2026-01-05 37 коммит

### 🗺️ Добавлено — NodeMap
- **Визуализация архитектуры** — автоматический анализ всех функций проекта
- **Интерактивный граф** — навигация по зависимостям между функциями
- **Тепловая карта** — цветовая индикация частоты вызовов (Cold/Normal/Warm/Hot)
- **Типизация функций** — Entry Points, Hubs, Leaves, Islands
- **Метрики сложности** — Lines, Complexity, Parameters для каждой функции
- **Поиск и фильтры** — быстрое нахождение нужных функций
- **Панель предупреждений** — Dead Code, Circular Dependencies, High Complexity
- Открытие по клавише `.` (точка)
- 8 модулей в папке `js/nodemap/`

### 📱 Добавлено — Мобильная оптимизация таблицы растворимости
- **Полноэкранный режим** — таблица на весь экран без отступов
- **Safe-area поддержка** — корректное отображение на устройствах с "челкой"
- **Скрытые скроллбары** — чистый интерфейс без полос прокрутки
- **Вертикальная шапка** — заголовок сверху, кнопки снизу
- **Bounce эффекты** — естественное поведение при скролле
- **0px bottom padding** в PWA/fullscreen режиме
- **Правильные рамки** — все 4 стороны выделенных ячеек

### 🧪 Добавлено — Продвинутая модалка для веществ
- **Детальная информация** о веществах при двойном клике / долгом нажатии
- **5 вкладок:**
  - Химия — формула, молярная масса, степени окисления
  - Растворимость — точные данные, Ksp, зависимость от температуры
  - Внешний вид — цвета, кристаллическая система
  - Реакции — стабильность, характерные реакции
  - Применение — использование, безопасность, факты
- **substances-data.js** — новая структурированная база данных
- **advanced-modal.js** — логика продвинутой модалки
- **advanced-modal.css** — стили (адаптивные, темная тема)

### 📱 Улучшено — Отображение на мобильных устройствах
- **Оптимизация для iPhone** — уменьшены размеры кнопок в таблице растворимости
- **Оптимизация для Android** — уменьшены размеры иконок в FAB меню
- **Единообразие цветов** — синие кнопки на всех устройствах
- **Улучшена видимость иконок** — оптимизированы размеры SVG иконок для разных устройств
- **JavaScript-детекция устройств** — автоматическое определение типа устройства для применения соответствующих стилей

### 🔧 Исправлено
- Исправлена ошибка в `sw.js` — обновлен список файлов для кэширования
- Убрана синяя полоска внизу модальных окон на мобильных
- Правильная работа выделения ячеек (4-сторонняя рамка)
- Белое пространство внизу в fullscreen/PWA режиме
- Проблемы с отображением иконок на разных устройствах

### 📝 Документация
- Обновлен README.md — добавлена информация о NodeMap и мобильной оптимизации
- Обновлен TODO.md — актуализирован список задач
- Обновлен AI_CONTEXT.md — добавлена структура новых модулей
- Создан CHANGELOG.md — история изменений

---

## [0.6.0] — 2025-12-20

### 🧪 Добавлено — Таблица растворимости
- **Полноэкранная модалка** 24×16 (384 соединения)
- **Sticky headers** — фиксированные заголовки катионов и анионов
- **Подсветка крестовиной** — выделение строки и столбца при клике
- **Toggle-логика** — повторный клик снимает выделение
- **Режим "Реальные цвета"** — 100+ веществ с реалистичными цветами:
  - Чёрные осадки (сульфиды)
  - Жёлтые осадки (иодиды, хроматы)
  - Цветные растворы (Cu²⁺, Co²⁺, Ni²⁺, Mn²⁺, Cr³⁺, KMnO₄)
  - Белые осадки с градиентом
  - Бесцветные растворы
- **6 модулей растворимости:**
  - `data.js` — данные катионов, анионов, матрицы
  - `colors.js` — цвета веществ
  - `solubility-table.js` — рендеринг
  - `filters.js` — фильтрация
  - `search.js` — поиск
  - `modal.js` — управление модалкой

### 🔍 Добавлено — Умный поиск
- **Панель поиска и фильтров** — единый интерфейс
- **Химический парсер** — распознавание формул:
  - "BaSO4" → открывает таблицу растворимости
  - "хлорид натрия" → NaCl → таблица растворимости
  - Автоматическая подсветка найденного вещества
- **Фильтры по категориям** — 10 категорий элементов
- **Поиск по всем данным** — название, символ, факты, применение

### ⚙️ Добавлено — Модульная система
- **scrypt.js** — динамический загрузчик модулей
- Разделение кода на логические модули:
  - `js/modules/` — основные модули (6 файлов)
  - `js/solubility/` — модули растворимости (6 файлов)
- Последовательная загрузка через `loadScript()`
- Совместимость с `file://` протоколом

### 📱 Добавлено — PWA
- **manifest.json** — настройки веб-приложения
- **sw.js** — Service Worker для оффлайн-режима
- **Кэширование** — все статические файлы
- **Иконки** — 192x192 и 512x512
- **Установка на устройство** — Android и iOS
- **Работа без интернета**

### 🔧 Исправлено
- Оптимизирована загрузка стилей (1 главный файл с @import)
- Улучшена производительность рендеринга таблицы растворимости
- Исправлены баги с модальными окнами на мобильных

---

## [0.5.0] — 2025-11-15

### 🎨 Добавлено
- **SVG иконки** вместо эмодзи
- **FAB-меню** — плавающая кнопка с 5 функциями
- **Калькулятор молярной массы:**
  - Drag & Drop элементов из таблицы
  - Тап для добавления на мобильных
  - Редактирование индексов
  - Автоматический пересчёт массы
- **Тёмная тема:**
  - Переключатель в FAB-меню
  - Волновая анимация перехода
  - Сохранение выбора в localStorage
  - Адаптация всех элементов интерфейса
- **3D атомы:**
  - Canvas рендеринг
  - Вращающиеся электроны
  - Полупрозрачные модальные окна (видны атомы на фоне)
- **Частицы на фоне:**
  - Летающие точки
  - Соединения между точками
  - Адаптация к размеру окна

### 🎨 CSS
- `fab.css` — стили FAB-меню
- `calculator.css` — стили калькулятора
- `theme.css` — темная тема и анимации

### 📦 JS
- `js/modules/calculator.js` — логика калькулятора
- `js/modules/theme.js` — переключение темы
- `js/modules/ui.js` — FAB-меню и UI
- `js/particles.js` — Canvas анимации

---

## [0.4.0] — 2025-10-10

### 📚 Добавлено
- **Элементы 11-40** в базу данных (Na–Zr)
- **Аллотропы** для углерода, серы, фосфора, кислорода
- **FAB-меню** — первая версия

### 🔧 Улучшено
- Оптимизация модального окна
- Улучшена система аллотропов

---

## [0.3.0] — 2025-09-05

### ⚗️ Добавлено
- **Система аллотропов:**
  - Основные формы (allotropes)
  - Редкие формы (extraAllotropes)
  - Табы для переключения
  - Кнопка "+ Ещё" для дополнительных форм
- Аллотропы для C, O, S, P

### 🎨 Улучшено
- Дизайн табов
- Анимация переключения между формами

---

## [0.2.0] — 2025-08-01

### 📖 Добавлено
- **Модальное окно элемента:**
  - Анимация открытия из точки клика
  - Эффект "разлёта" элементов таблицы
  - 4 информационные секции:
    - Базовая информация
    - Физические свойства
    - История и практика
    - Интересные факты
- **Элементы 1-10** в базе данных (H–Ne)

### 🎨 CSS
- `modal.css` — стили модального окна
- Адаптивность для мобильных

### 📦 JS
- `js/elements.js` — база данных элементов
- `js/modules/modal.js` — логика модального окна

---

## [0.1.0] — 2025-07-01

### 🎉 Первый релиз
- **Базовая таблица Менделеева:**
  - 118 элементов
  - Цветовая кодировка по категориям
  - Лантаноиды и актиноиды отдельно
  - Grid layout
- **Поиск элементов** — базовая функциональность
- **Адаптивный дизайн**

### 🎨 CSS
- `base.css` — базовые стили
- `table.css` — таблица Менделеева
- `filters.css` — панель поиска

### 📦 JS
- `js/scrypt.js` — основная логика
- `js/icons.js` — SVG иконки

---

## Формат

### Типы изменений
- `Добавлено` — новые функции
- `Изменено` — изменения в существующей функциональности
- `Устарело` — функции, которые скоро будут удалены
- `Удалено` — удалённые функции
- `Исправлено` — исправления багов
- `Безопасность` — исправления уязвимостей

---

*Последнее обновление: 05 января 2026*


============================================================
ФАЙЛ: .\md\NODEMAP_GUIDE.md
============================================================

# 🗺️ NodeMap - Руководство пользователя

## Что это такое?

NodeMap - это **автоматический анализатор архитектуры** вашего JavaScript проекта. Он сканирует все функции, находит зависимости между ними и строит **интерактивный граф**.

## Быстрый старт

### Шаг 1: Открыть карту
Просто нажми клавишу **`.`** (точка) в любом месте страницы.

### Шаг 2: Навигация
- **Перемещение**: зажми левую кнопку мыши и перетащи граф
- **Зум**: крути колесо мыши
- **Выбор функции**: кликни по любой ноде

### Шаг 3: Исследуй!

## 🎨 Что означают цвета?

Каждая нода (прямоугольник с именем функции) окрашена в зависимости от того, **как часто её вызывают**:

| Цвет | Значение | Описание |
|------|----------|----------|
| 🔵 Синий | **Cold** | 0-1 вызов - редко используется |
| 🟢 Зелёный | **Normal** | 2-5 вызовов - обычная функция |
| 🟡 Жёлтый | **Warm** | 6-10 вызовов - важная функция |
| 🔴 Красный | **Hot** | >10 вызовов - КРИТИЧЕСКАЯ функция! |

**Горячие (красные) функции** - это ключевые узлы вашего приложения. Изменения в них могут сломать много чего!

## 🏷️ Типы функций

В левом верхнем углу каждой ноды есть иконка:

| Иконка | Тип | Описание |
|--------|-----|----------|
| 📥 | **Entry Point** | Никто не вызывает, но сама вызывает других. Точка входа в модуль! |
| 📤 | **Leaf** | Ничего не вызывает. Конечная функция (обычно делает реальную работу) |
| 🔄 | **Hub** | Много входящих И исходящих связей. Центральный узел архитектуры! |
| 🏝️ | **Island** | Изолированная функция. Возможно, мёртвый код? |
| ⚡ | **Normal** | Обычная функция |

## 🔍 Как искать функции?

### Поиск по имени
В верхней части окна есть поле поиска. Начни вводить имя функции:
```
openModal  → найдёт openModal, openModalWithData, и т.д.
```

При нахождении:
- Функция автоматически **подсвечивается**
- Граф **центрируется** на ней
- Показывается **подробная информация** справа

### Фильтры
Используй кнопки-фильтры для быстрого поиска:

- **📥 Entry** - покажет все точки входа
- **🔄 Hubs** - покажет центральные функции
- **📤 Leaves** - покажет конечные функции
- **🏝️ Islands** - покажет изолированный код

## 📊 Информационная панель (справа)

Когда кликнешь на ноду, справа появится детальная информация:

```
openSearchModal
├─ Type: hub
├─ Temperature: hot
├─ Lines: 87
├─ Complexity: 12
├─ Parameters: query, options
│
├─ Calls (3):
│  ├─ filterElements
│  ├─ highlightElement
│  └─ updateResults
│
└─ Called by (5):
   ├─ handleKeyPress
   ├─ initSearchHandlers
   ├─ onDomReady
   ├─ searchButtonClick
   └─ handleShortcut
```

### Метрики объясняются:

**Lines** - количество строк кода функции
- < 20 строк: простая функция ✅
- 20-50 строк: средняя функция ⚠️
- \> 50 строк: сложная, возможно стоит разбить 🔴

**Complexity** - цикломатическая сложность
- 1-5: простая логика ✅
- 6-10: умеренная сложность ⚠️
- 11-20: сложная, трудная для тестирования 🔴
- \> 20: ОПАСНО! Рефакторинг необходим! ⛔

**Parameters** - параметры функции
- Показывает, что функция принимает

**Calls** - какие функции вызывает эта функция

**Called by** - кто вызывает эту функцию

## ⚠️ Панель предупреждений

Внизу справа может появиться панель с предупреждениями:

### 🏝️ Dead Code
```
⚠️ Dead Code
5 unused functions found
Details: renderOldVersion, legacyInit, deprecatedHelper, ...
```
Функции, которые **никто не вызывает**. Возможно:
- Забытый код после рефакторинга
- Устаревшие функции
- Временный код для отладки

### 🔄 Circular Dependencies
```
🔄 Circular Dependencies
2 circular dependency chains found
Details:
  validateForm → checkField → validateForm
  loadData → processData → loadData
```
Циклические зависимости могут привести к:
- Бесконечной рекурсии
- Сложности в понимании кода
- Проблемам при рефакторинге

### 📊 High Complexity
```
📊 High Complexity
3 functions with complexity > 20
Details: handleUserInput (34), processPayment (27), renderTable (23)
```
Функции со слишком высокой сложностью стоит **разбить** на несколько меньших.

## 💡 Практические сценарии использования

### 1. Понять архитектуру нового проекта
```
1. Нажми `.`
2. Найди Hub'ы (🔄) - это центральные функции
3. Посмотри на Entry Points (📥) - точки входа в разные модули
4. Изучи связи между ними
```

### 2. Найти, где используется функция
```
1. Найди функцию через поиск
2. Посмотри раздел "Called by"
3. Кликай по вызывающим функциям, чтобы проследить цепочку
```

### 3. Рефакторинг: найти кандидатов на упрощение
```
1. Открой панель Warnings
2. Раздел "High Complexity" покажет проблемные функции
3. Кликни на них, чтобы увидеть детали
4. Функции с > 20 complexity стоит разбить на части
```

### 4. Удаление мёртвого кода
```
1. Найди Islands (🏝️) через фильтр
2. Проверь раздел Warnings → Dead Code
3. Убедись, что эти функции действительно не нужны
4. Удаляй их из проекта
```

### 5. Анализ влияния изменений
```
Перед изменением функции:
1. Кликни на неё
2. Посмотри "Called by" - кто её использует
3. Hot (🔴) функции меняй ОЧЕНЬ осторожно!
4. Cold (🔵) функции можно менять смелее
```

## 🎮 Все горячие клавиши

| Клавиша | Действие |
|---------|----------|
| `.` | Открыть NodeMap |
| `Esc` | Закрыть NodeMap |
| Колесо мыши | Зум |
| Клик + перетаскивание | Перемещение графа |
| Клик по ноде | Выбрать/снять выбор |

## 🎯 Кнопки управления

| Кнопка | Что делает |
|--------|------------|
| **🔍 Поиск** | Найти функцию по имени |
| **⊡** | Fit to view - показать весь граф |
| **100%** | Сбросить зум |
| **🔄** | Обновить анализ (пересканировать проект) |

## 🤔 FAQ

**Q: Почему некоторые функции не отображаются?**
A: NodeMap показывает только функции из глобальной области видимости (`window`). Функции внутри замыканий или модулей не видны.

**Q: Слишком много нод, не могу найти нужную!**
A: Используй **поиск** (поле вверху) или **фильтры** (кнопки Entry/Hub/Leaf/Island).

**Q: Граф слишком запутанный!**
A: Попробуй:
1. Нажать кнопку **⊡ Fit to view**
2. Использовать **зум** для фокуса на интересующей области
3. Кликнуть на конкретную ноду - подсветятся только её связи

**Q: Можно ли сохранить граф как картинку?**
A: Пока нет, но это в планах! 🚀

**Q: Анализ долго грузится!**
A: Если в проекте >200 функций, расчёт layout может занять несколько секунд. Это нормально.

## 🎓 Примеры анализа

### Хорошая архитектура:
```
Entry Point → Controller → Service → Helper → Leaf
    ↓              ↓           ↓         ↓       ↓
  (📥)          (🔄)        (⚡)      (⚡)    (📤)
  Cold          Warm      Normal    Normal   Cold
```
- Чёткая иерархия
- Нет циклов
- Мало Hub'ов (не всё завязано на одну функцию)

### Плохая архитектура:
```
    Hub (🔴 HOT!)
     ↙ ↓ ↓ ↘
    ↙  ↓ ↓  ↘
   ↙   ↓ ↓   ↘
  ↙    ↓ ↓    ↘
Everything calls Hub!
```
- Всё завязано на одну функцию
- Изменение Hub сломает весь проект
- Сложно тестировать

## 🏆 Лучшие практики

1. **Регулярно проверяй Dead Code** - мёртвый код увеличивает bundle size

2. **Избегай циклических зависимостей** - они усложняют отладку

3. **Следи за Complexity** - функции > 20 стоит разбивать

4. **Изучай Hot функции** - они критичны для работы приложения

5. **Документируй Entry Points** - они показывают структуру модулей

6. **Учитывай адаптивность интерфейса** - новые функции определения устройств позволяют адаптировать UI под конкретные платформы

---

**Совет**: открывай NodeMap после каждого крупного рефакторинга, чтобы увидеть как изменилась архитектура! 📊


============================================================
ФАЙЛ: .\md\TODO.md
============================================================

# 📋 TODO.md — Задачи проекта

> Приоритеты: 🔴 Критично | 🟡 Важно | 🟢 Улучшения | ⚪ Идеи на будущее

---

## 🟡 Важные задачи (до олимпиады)

### База данных элементов
- [x] Добавить элементы 101-118 в `elementsData`
- [ ] Заполнить аллотропы для Sn (олово: белое/серое/ромбическое)
- [ ] Заполнить аллотропы для Fe (железо: α/γ/δ)
- [ ] Проверить корректность атомных масс всех элементов

### Таблица растворимости
- [ ] Добавить больше цветов осадков в `colors.js`
- [ ] Добавить всплывающие подсказки с формулой при наведении
- [ ] Сохранять состояние переключателя "Реальные цвета" в localStorage
- [ ] Графики растворимости vs температура
- [ ] Режим сравнения двух веществ

### NodeMap
- [ ] **Документация** — автогенерация комментариев для функций
- [ ] **История изменений** — сравнение графов разных версий

### Доступность (A11y)
- [ ] Навигация стрелками по таблице Менделеева
- [ ] `aria-label` для всех интерактивных элементов
- [ ] Фокус-индикаторы для клавиатурной навигации
- [ ] `role="grid"` для таблицы растворимости
- [ ] Screen reader поддержка

### PWA и производительность
- [ ] Обновить sw.js — добавить все новые файлы в кэш
- [ ] Добавить iOS-иконки (apple-touch-icon) разных размеров
- [ ] Добавить splash-screen для iOS
- [ ] Проверить офлайн-режим на всех страницах
- [ ] Оптимизация загрузки — lazy loading модулей
- [ ] Минификация CSS/JS для production

---

## 🟢 Улучшения UX/UI

### Визуальные эффекты
- [ ] Hover-анимация для элементов таблицы на мобильных (тактильная обратная связь)
- [ ] Улучшить 3D-атомы — добавить подуровни (s, p, d, f)
- [ ] Анимация появления результатов поиска
- [ ] Плавный скролл к найденному элементу
- [ ] Микро-анимации при взаимодействии

### Калькулятор
- [ ] История вычислений (последние 5-10)
- [ ] Кнопка "Копировать формулу"
- [ ] Поддержка скобок: Ca(OH)₂, Fe₂(SO₄)₃
- [ ] Расчет процентного состава
- [ ] Экспорт результатов

### Поиск и фильтры
- [ ] Поиск по электронной конфигурации (например: "1s2 2s2 2p6")
- [ ] Фильтр по агрегатному состоянию (газ/жидкость/твердое)
- [ ] Фильтр "Радиоактивные элементы"
- [ ] Голосовой поиск (Web Speech API)
- [ ] История поиска
- [ ] Автодополнение в поле поиска

### Информация об элементах
- [ ] Добавить изотопы с периодами полураспада
- [ ] Добавить спектры излучения (графики)
- [ ] Добавить кристаллическую структуру (3D модели)
- [ ] Сравнение двух элементов side-by-side
- [ ] Временная шкала открытий элементов
- [ ] Карта распространенности в земной коре

### Таблица растворимости - UX
- [ ] Режим "Обучение" — скрывать растворимость, показывать по клику
- [ ] Быстрые действия — меню при правом клике на ячейку
- [ ] Закладки — сохранение избранных веществ
- [ ] История просмотров

---

## ⚪ Идеи на будущее (v0.7+)

### 🔬 Лабораторный режим
- [ ] **Симулятор химических реакций**
  - Визуализация реакции с анимацией молекул
  - База типичных реакций (нейтрализация, осаждение, окисление-восстановление)
  - Термодинамические расчеты (ΔH, ΔS, ΔG)
  - Кинетика реакций (скорость, константа равновесия)

### ⚖️ Уравниватель реакций
- [ ] Автоматическая расстановка коэффициентов
- [ ] Пошаговое объяснение балансировки
- [ ] Проверка введённых уравнений
- [ ] Определение типа реакции
- [ ] Расчет реагентов и продуктов

### 📊 Графики и визуализация
- [ ] График зависимости свойств от атомного номера
- [ ] Электронные конфигурации (визуализация орбиталей)
- [ ] Энергетические диаграммы
- [ ] Периодические тренды (размер атома, электроотрицательность, энергия ионизации)

### 📤 Экспорт и интеграция
- [ ] Сохранение карточки элемента как PNG/PDF
- [ ] Экспорт результата калькулятора
- [ ] Поделиться в соц.сетях
- [ ] API для внешних приложений
- [ ] Интеграция с Google Classroom
- [ ] QR-коды для быстрого доступа

### 🧠 Образовательный режим
- [ ] **Интерактивные тесты:**
  - Тесты по элементам (название → символ, масса → элемент)
  - Тесты по растворимости
  - Тесты по типам реакций
  - Адаптивная сложность (Easy/Medium/Hard)
  
- [ ] **Flashcards (карточки для запоминания):**
  - Режим тренировки
  - Spaced Repetition (метод интервальных повторений)
  - Статистика запоминания
  
- [ ] **Режим викторины:**
  - Соревновательный режим
  - Таймер и очки
  - Таблица лидеров
  
- [ ] **Система достижений:**
  - Бейджи за изучение элементов
  - Прогресс обучения
  - Мотивация через геймификацию

### 🗺️ NodeMap — Расширения
- [ ] **Flow-диаграммы** — визуализация потока данных между функциями
- [ ] **Временная шкала** — анализ изменений архитектуры
- [ ] **Сравнение версий** — diff между коммитами
- [ ] **Автогенерация документации** — комментарии на основе анализа
- [ ] **Рефакторинг-подсказки** — автоматические предложения по улучшению кода
- [ ] **Export** — сохранение графа как изображение (PNG, SVG)
- [ ] **Интеграция с Git** — показ авторов функций, частоты изменений

### 🌐 Мультиязычность и локализация
- [ ] Английский язык (EN)
- [ ] Казахский язык (KZ)
- [ ] Переключатель языков в FAB-меню
- [ ] Локализация всех текстов, названий, описаний

### 🎨 Дополнительные темы
- [ ] Светлая тема (классический вариант)
- [ ] Режим для дальтоников (специальная палитра)
- [ ] Контрастный режим (высокая контрастность)
- [ ] Режим энергосбережения (минимум анимаций)

### 🔌 Внешние интеграции
- [ ] PubChem API — дополнительная информация о веществах
- [ ] ChemSpider API — структурные формулы
- [ ] Wikipedia API — расширенная информация
- [ ] NIST Chemistry WebBook — спектры, термодинамика

### 🥽 Экспериментальные технологии
- [ ] **WebXR/AR режим:**
  - Просмотр 3D моделей атомов в AR
  - Виртуальная лаборатория
  - Взаимодействие с молекулами в пространстве
  
- [ ] **WebGPU:**
  - Ускорение рендеринга графов
  - Более сложные 3D визуализации
  
- [ ] **WebAssembly:**
  - Ускорение сложных расчетов (термодинамика, квантовая химия)

---

## ✅ Выполнено

### v0.6.5 (январь 2026)
- [x] **NodeMap** — визуализация архитектуры
- [x] Автоматический анализ кода
- [x] Интерактивный граф зависимостей
- [x] Тепловая карта вызовов
- [x] Метрики сложности (Lines, Complexity, Parameters)
- [x] Панель предупреждений (Dead Code, Circular Deps, High Complexity)
- [x] Поиск и фильтры функций
- [x] **Мобильная оптимизация таблицы растворимости**
- [x] Полноэкранный режим с safe-area
- [x] Скрытые скроллбары
- [x] Bounce эффекты
- [x] Правильные рамки выделенных ячеек
- [x] 0px bottom padding в PWA-режиме
- [x] **Продвинутая модалка веществ**
- [x] substances-data.js — база данных о веществах
- [x] 5 вкладок: Химия, Растворимость, Внешний вид, Реакции, Применение
- [x] Двойной клик / долгое нажатие для открытия
- [x] **Оптимизация отображения на мобильных устройствах**
- [x] Уменьшены размеры кнопок в таблице растворимости на iPhone
- [x] Уменьшены размеры иконок в FAB меню на Android
- [x] Единообразие цветов кнопок на всех устройствах
- [x] JavaScript-детекция устройств для адаптивных стилей

### v0.6 (декабрь 2025)
- [x] SVG-иконки вместо эмодзи
- [x] FAB-меню с 5 функциями
- [x] Калькулятор молярной массы (Drag & Drop)
- [x] Тёмная тема с волновой анимацией
- [x] 3D-атомы на Canvas
- [x] PWA (manifest + Service Worker)
- [x] Мобильная адаптация всех компонентов
- [x] **Таблица растворимости 24×16**
- [x] **Sticky headers**
- [x] **Подсветка крестовиной**
- [x] **Режим реальных цветов** (100+ веществ)
- [x] **Умный поиск по формулам**
- [x] **Распознавание "хлорид натрия" → NaCl**
- [x] Панель фильтров по категориям
- [x] База цветов 100+ веществ
- [x] Модульная система загрузки (scrypt.js)

### v0.5
- [x] Система аллотропов с табами
- [x] Интересные факты о элементах

### v0.4
- [x] Элементы 11-40 в базе данных

### v0.3
- [x] Модальное окно элемента с анимацией

### v0.2
- [x] Поиск по элементам

### v0.1
- [x] Базовая таблица Менделеева

---

## 📊 Прогресс проекта

| Компонент | Готовность | Статус |
|-----------|------------|--------|
| Элементы в базе | 118/118 (100%) | ✅ Готово |
| Аллотропы | ~12/25 (48%) | 🟡 В работе |
| Вещества в таблице растворимости | 384/384 (100%) | ✅ Готово |
| Цвета веществ | 100+/384 (26%) | 🟡 В работе |
| Детальная информация о веществах | 10+/384 (2.6%) | 🔴 Требуется работа |
| Мобильная адаптация | 95% | ✅ Почти готово |
| PWA | 100% | ✅ Готово |
| A11y (доступность) | 30% | 🔴 Требуется работа |
| Интернационализация | 0% | ⚪ Не начато |
| NodeMap | 80% | 🟢 Работает |

---

## 🎯 Приоритеты на ближайшее время

### Февраль 2026
1. **Заполнить substances-data.js** (хотя бы 50 веществ)
2. **Исправить критические баги** (опечатки, дублирования)
3. **Добавить элементы 41-60**

### Март 2026
1. **Улучшить A11y** (навигация, aria-labels)
2. **Оптимизация производительности**
3. **Лабораторный режим** (базовая версия)

### Апрель 2026
1. **Уравниватель реакций**
2. **Образовательный режим** (тесты)
3. **Подготовка к олимпиаде**

---

## 💡 Как помочь проекту?

### Для разработчиков:
- Добавить новые элементы в `elements.js`
- Заполнить информацию о веществах в `substances-data.js`
- Улучшить производительность
- Написать тесты

### Для химиков:
- Проверить корректность данных
- Добавить интересные факты
- Описать характерные реакции веществ

### Для дизайнеров:
- Улучшить UI/UX
- Создать новые иконки
- Разработать splash-screens

### Для всех:
- Сообщить о багах
- Предложить идеи
- Протестировать на разных устройствах

---

*Последнее обновление: январь 2026*


============================================================
ФАЙЛ: .\scripts\sync-reactions-db.js
============================================================

﻿const fs = require('fs');
const path = require('path');

const root = path.join(__dirname, '..');
const src = path.join(root, 'data', 'reactions-db.json');
const dst = path.join(root, 'js', 'reactions-db.js');

const json = fs.readFileSync(src, 'utf8');
fs.writeFileSync(dst, 'window.REACTIONS_DB = ' + json + ';\n', 'utf8');

console.log('Synced reactions DB -> js/reactions-db.js');


============================================================
ФАЙЛ: .\scripts\sync-solubility-colors.js
============================================================

'use strict';

const fs = require('fs');
const path = require('path');

const repoRoot = path.resolve(__dirname, '..');
const dataPath = path.join(repoRoot, 'js', 'solubility', 'data.js');
const jsonPath = path.join(repoRoot, 'solubility-colors.json');

const args = new Set(process.argv.slice(2));
const checkOnly = args.has('--check');

const content = fs.readFileSync(dataPath, 'utf8');
const marker = 'const substanceColors';
const start = content.indexOf(marker);
if (start === -1) {
  console.error('Failed to find substanceColors in data.js');
  process.exit(2);
}
const open = content.indexOf('{', start);
if (open === -1) {
  console.error('Failed to find opening { for substanceColors');
  process.exit(2);
}
const close = content.indexOf('};', open);
if (close === -1) {
  console.error('Failed to find closing }; for substanceColors');
  process.exit(2);
}

const block = content.slice(open + 1, close);
const re = /"([^"]+)"\s*:\s*"([^"]*)"/g;
const entries = [];
let match;
while ((match = re.exec(block)) !== null) {
  entries.push({ key: match[1], value: match[2] });
}

if (entries.length === 0) {
  console.error('No entries found in substanceColors');
  process.exit(2);
}

const jsonOutput = JSON.stringify(entries, null, 2) + '\n';
let existing = '';
if (fs.existsSync(jsonPath)) {
  existing = fs.readFileSync(jsonPath, 'utf8');
}

if (checkOnly) {
  if (existing !== jsonOutput) {
    console.error('solubility-colors.json is out of sync with data.js');
    process.exit(1);
  }
  console.log('solubility-colors.json is in sync.');
  process.exit(0);
}

if (existing !== jsonOutput) {
  fs.writeFileSync(jsonPath, jsonOutput, 'utf8');
  console.log('Updated solubility-colors.json from data.js');
} else {
  console.log('No changes needed.');
}


============================================================
ФАЙЛ: .\scripts\video_to_table.py
============================================================

#!/usr/bin/env python3
"""Convert video into BadApplePlayer JSON payload."""

from __future__ import annotations

import argparse
import json
import sys
from pathlib import Path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Convert video frames into compact 18x10 payload for js/bad-apple.js "
            "(binary or 16-level grayscale)."
        )
    )
    parser.add_argument("input", type=Path, help="Path to source video.")
    parser.add_argument("output", type=Path, help="Path to output payload JSON.")
    parser.add_argument("--width", type=int, default=18, help="Output width. Default: 18.")
    parser.add_argument("--height", type=int, default=10, help="Output height. Default: 10.")
    parser.add_argument("--fps", type=float, default=12.0, help="Target fps. Default: 12.")
    parser.add_argument(
        "--mode",
        choices=("bw", "gray"),
        default="bw",
        help="bw = 1-bit, gray = 16-level grayscale. Default: bw.",
    )
    parser.add_argument(
        "--threshold",
        type=int,
        default=128,
        help="Threshold for bw mode (0..255). Darker pixels are on. Default: 128.",
    )
    parser.add_argument(
        "--invert",
        action="store_true",
        help="Invert polarity (light pixels become on).",
    )
    parser.add_argument(
        "--max-frames",
        type=int,
        default=0,
        help="Stop after this many frames (0 = no limit).",
    )
    parser.add_argument(
        "--pretty",
        action="store_true",
        help="Write pretty JSON instead of compact JSON.",
    )
    parser.add_argument(
        "--output-format",
        choices=("json", "js"),
        default="json",
        help="json = raw payload, js = window variable assignment. Default: json.",
    )
    parser.add_argument(
        "--var-name",
        default="BAD_APPLE_PAYLOAD",
        help="Window variable name for --output-format js. Default: BAD_APPLE_PAYLOAD.",
    )
    return parser.parse_args()


def encode_bw_hex_bitset(gray_frame, threshold: int, invert: bool) -> str:
    flat = gray_frame.reshape(-1)
    bits = (flat < threshold).astype("uint8")
    if invert:
        bits = 1 - bits

    chars = []
    total = len(bits)
    for i in range(0, total, 4):
        b0 = int(bits[i]) if i < total else 0
        b1 = int(bits[i + 1]) if i + 1 < total else 0
        b2 = int(bits[i + 2]) if i + 2 < total else 0
        b3 = int(bits[i + 3]) if i + 3 < total else 0
        chars.append(format((b0 << 3) | (b1 << 2) | (b2 << 1) | b3, "x"))
    return "".join(chars)


def encode_gray_hex_nibbles(gray_frame, invert: bool) -> str:
    # 0 -> offColor, 15 -> onColor in BadApplePlayer.
    levels = ((255 - gray_frame) * 15.0 / 255.0).round().astype("uint8")
    if invert:
        levels = 15 - levels
    return "".join(format(int(value) & 0xF, "x") for value in levels.reshape(-1))


def convert_video(
    *,
    input_path: Path,
    width: int,
    height: int,
    target_fps: float,
    mode: str,
    threshold: int,
    invert: bool,
    max_frames: int,
) -> tuple[dict, int]:
    try:
        import cv2
    except ImportError as exc:  # pragma: no cover
        raise RuntimeError(
            "opencv-python is required. Install with: pip install opencv-python"
        ) from exc

    capture = cv2.VideoCapture(str(input_path))
    if not capture.isOpened():
        raise RuntimeError(f"Cannot open video: {input_path}")

    source_fps = float(capture.get(cv2.CAP_PROP_FPS) or 0.0)
    if source_fps <= 0:
        source_fps = target_fps if target_fps > 0 else 25.0
    if target_fps <= 0:
        target_fps = source_fps

    frames: list[str] = []
    frame_index = 0
    next_emit_time = 0.0
    emit_step = 1.0 / target_fps
    encoding = "hex-bitset-v1"

    while True:
        ok, frame_bgr = capture.read()
        if not ok:
            break

        current_time = frame_index / source_fps
        frame_index += 1

        if current_time + 1e-9 < next_emit_time:
            continue

        frame_gray = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2GRAY)
        resized = cv2.resize(frame_gray, (width, height), interpolation=cv2.INTER_AREA)

        if mode == "gray":
            frames.append(encode_gray_hex_nibbles(resized, invert=invert))
            encoding = "hex-nibbles-v1"
        else:
            frames.append(
                encode_bw_hex_bitset(
                    resized,
                    threshold=threshold,
                    invert=invert,
                )
            )
            encoding = "hex-bitset-v1"

        next_emit_time += emit_step

        if max_frames > 0 and len(frames) >= max_frames:
            break

    capture.release()

    payload = {
        "encoding": encoding,
        "width": width,
        "height": height,
        "fps": target_fps,
        "frames": frames,
        "meta": {
            "source_video": input_path.name,
            "source_fps": source_fps,
            "mode": mode,
            "threshold": threshold if mode == "bw" else None,
            "invert": invert,
        },
    }
    return payload, frame_index


def main() -> int:
    args = parse_args()

    if args.width <= 0 or args.height <= 0:
        print("Width and height must be positive.", file=sys.stderr)
        return 2
    if args.fps <= 0:
        print("FPS must be greater than zero.", file=sys.stderr)
        return 2
    if args.mode == "bw" and not (0 <= args.threshold <= 255):
        print("Threshold must be in range 0..255.", file=sys.stderr)
        return 2
    if not args.input.exists():
        print(f"Input file not found: {args.input}", file=sys.stderr)
        return 2
    if args.output_format == "js" and not args.var_name.strip():
        print("Variable name must not be empty.", file=sys.stderr)
        return 2

    try:
        payload, decoded_frames = convert_video(
            input_path=args.input,
            width=args.width,
            height=args.height,
            target_fps=args.fps,
            mode=args.mode,
            threshold=args.threshold,
            invert=args.invert,
            max_frames=max(0, args.max_frames),
        )
    except Exception as exc:
        print(f"Conversion failed: {exc}", file=sys.stderr)
        return 1

    args.output.parent.mkdir(parents=True, exist_ok=True)
    with args.output.open("w", encoding="utf-8") as out_file:
        if args.output_format == "js":
            if args.pretty:
                payload_json = json.dumps(payload, ensure_ascii=False, indent=2)
            else:
                payload_json = json.dumps(payload, ensure_ascii=False, separators=(",", ":"))
            out_file.write(f"window.{args.var_name.strip()} = {payload_json};\n")
        else:
            if args.pretty:
                json.dump(payload, out_file, ensure_ascii=False, indent=2)
            else:
                json.dump(payload, out_file, ensure_ascii=False, separators=(",", ":"))

    print(
        "Done: wrote",
        len(payload["frames"]),
        "frames to",
        str(args.output),
        f"(decoded input frames: {decoded_frames})",
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


============================================================
ФАЙЛ: .\Tabletable\451 градус по Фаренгейту.md
============================================================

>[!quote] Цитата
>Онемение онемелости онемевшой пустотелости
 ---
>[!important] Главная мысль
>Конец начинается, когда ты перестаешь думать

============================================================
ФАЙЛ: .\Tabletable\Gemini.md
============================================================

- #### [[Скиллы Gemini]]
- #### [[Общение с Gemini]]


============================================================
ФАЙЛ: .\Tabletable\TableTable.md
============================================================

- #### [[Таблица Менделеева]]
---
- #### [[Модули]]
---
- #### [[Приложение]]
---
- #### [[Оптимизация]]
---
- #### [[Canvas]]
---
- #### [[NodeMap]]

============================================================
ФАЙЛ: .\Tabletable\В очереди.md
============================================================



============================================================
ФАЙЛ: .\Tabletable\В планах.md
============================================================



============================================================
ФАЙЛ: .\Tabletable\Нейросети.md
============================================================

- ### [[Gemini]]
- ### [[ChatGPT]]
- ### [[Qwen]]
- ### [[Claude]]
- ### [[Grok]]
- ### [[Deepseek ]]
- ### [[Perplexity]]
- ### [[Kimi]]
- ### [[MiniMax]]


============================================================
ФАЙЛ: .\Tabletable\Признания.md
============================================================

>[!quote] Цитата
>Мораль и общественные устои — не более чем простые истины, что нам вдалбливают в школе

---
>[!important] Главная мысль
>Зло пораждает не справедливость, а цепную реакцию мести

============================================================
ФАЙЛ: .\Tabletable\Проект.md
============================================================

- ## [[Репозитории]]
- ## [[Нейросети]]


============================================================
ФАЙЛ: .\Tabletable\Прочитанное.md
============================================================

- ## [[Станция лихо]]
- ## [[Если все кошки в мире исчезнут]]
- ## [[Кафка на пляже]]
- ## [[Цветы смерти]]
- ## [[Рыбки в пятнах света]]
- ## [[Дом с синей комнатой]]
- ## [[Ящик скиннера]]
- ## [[Искупление]]
- ## [[Последний пассажир]]
- ## [[Санаторий]]
- ## [[Дом кривых стен]]
- ## [[1984]]
- ## [[Признания]]
- ## [[Человек с миллионом]]
- ## [[451 градус по Фаренгейту]]
- ## [[Скотный двор]]

============================================================
ФАЙЛ: .\Tabletable\Расписание.md
============================================================

- [[Понедельник]]
- [[Вторник]]
- [[Среда]]
- [[Четверг]]
- [[Пятница]]
- [[Суббота]]
- [[Воскресенье]]

============================================================
ФАЙЛ: .\Tabletable\Репозитории.md
============================================================

- ### [[TableTable]]
- ### [[Cards]]
- ### [[Trio Orchestra ]]
- ### [[TrainerBot]]
- ### [[Gazprom Project]]
- ### [[BeznegBot]]

============================================================
ФАЙЛ: .\Tabletable\Скотный двор.md
============================================================

>[!quote] Цитата
>Все животные равны, но некоторые равнее других

---
>[!important] Главная мысль
>В борьбе с врагом главное - не превратиться в него самого

============================================================
ФАЙЛ: .\Tabletable\Человек с миллионом.md
============================================================

>[!quote] Цитата
>Все что нужно для жизни это смелость воображение и немного денег
---
>[!important] Главная мысль
>Деньги это не цель а просто инструмент

============================================================
ФАЙЛ: .\Tabletable\Чтение.md
============================================================

- # [[Прочитанное]]
- # [[В очереди]]
- # [[В планах]]

============================================================
ФАЙЛ: .\Tabletable\Дни недели\Воскресенье.md
============================================================

- **09:30–10:00** — подъём  
---
- **утро и день** — свободное воемя
---
- **20:30–21:30** — ванна и рутина
---
- **21:30–23:00** — [[Чтение]]
---
- **23:00** — сон

============================================================
ФАЙЛ: .\Tabletable\Дни недели\Вторник.md
============================================================

- **08:20** — подъём  
- **09:00–16:00** — школа  
- **16:00–17:00** — отдых  
---
- **17:00–18:00** — вебинар + ДЗ по нему  
- **18:00–20:00** — [[Проект]]
---
- **20:00–20:30** — прогулка с собакой  
- **20:30–21:15** — школьное ДЗ  
---
- **21:15–21:30** — душ  
- **21:30–23:00** — [[Чтение]]
---
- **23:00** — сон

============================================================
ФАЙЛ: .\Tabletable\Дни недели\Понедельник.md
============================================================

- **08:20** — подъём  
- **09:00–16:00** — школа  
- **16:00–17:30** — отдых  
---
- **17:30–18:00** — ДЗ к репетитору  
- **18:00–19:00** — репетитор (онлайн)  
---
- **19:00–19:30** — прогулка с собакой  
- **19:30–20:30** — школьное ДЗ     
---
- **20:30–21:15** — ванна  
- **21:15–21:30** — рутина (волосы, зубы и т.п.)  
----
- **21:30–23:00** — [[Чтение]]
---
- **23:00** — сон

============================================================
ФАЙЛ: .\Tabletable\Дни недели\Пятница.md
============================================================

- **08:20** — подъём  
- **09:00–16:00** — школа  
---
- **16:00–17:30** — отдых  
---
- **17:30–17:50** — дорога на тренировку 
---
- **18:00–19:00** — тренировка (теннис)  
---
- **19:00–19:30** — дорога домой  
---
- **19:30–20:00** — Прогулка с собакой
---
- **20:00–21:00** — дз 
---
- **21:00–21:15** — душ  
---
- **21:15–23:00** — [[Чтение]]
---
- **23:00** — сон

============================================================
ФАЙЛ: .\Tabletable\Дни недели\Среда.md
============================================================

- **08:20** — подъём  
- **09:00–16:00** — школа  
---
- **16:00–17:00** — школьное ДЗ (в школе)  
---
- **17:00–19:15** — автодело  
---
- **19:30–20:00** — прогулка с собакой  
---
- **20:00–21:15** — ванна  
- **21:15–21:30** — рутина  
---
- **21:30–23:00** — [[Чтение]]
---
- **23:00** — сон

============================================================
ФАЙЛ: .\Tabletable\Дни недели\Суббота.md
============================================================

- **08:20** — подъём  
- **09:00–14:50** — школа  
---
- **15:00–16:00** — вебинар + ДЗ по нему  
---
- **16:00–18:00** — [[Проект]]  
---
- **18:00–21:00** — игры с друзьями (ПК) 
---
- **21:00–21:30** — душ и рутина
---
- **21:30–23:00** — [[Чтение]]
---
- **23:00** — сон

============================================================
ФАЙЛ: .\Tabletable\Дни недели\Четверг.md
============================================================

- **08:20** — подъём  
- **09:00–16:00** — школа  
---
- **16:00–17:00** — отдых  
---
- **17:00–19:00** — [[Проект]]
---
- **19:00–19:30** — прогулка с собакой  
---
- **19:30–20:15** — школьное ДЗ  
---
- **20:15–20:30** — душ
- **20:30–20:45** — рутина  
---
- **20:45–23:00** — [[Чтение]]
---
- **23:00** — сон

============================================================
ФАЙЛ: .\Tabletable\Проект\Canvas.md
============================================================

- [[Частицы]]
- [[Атомы]]

============================================================
ФАЙЛ: .\Tabletable\Проект\NodeMap.md
============================================================



============================================================
ФАЙЛ: .\Tabletable\Проект\Аллотропия.md
============================================================

- ## Основные аллотропные модификации
- ## Дополнительные 
- 

============================================================
ФАЙЛ: .\Tabletable\Проект\Атомы.md
============================================================



============================================================
ФАЙЛ: .\Tabletable\Проект\Группы.md
============================================================

- ### Щелочные металлы
- ### Щелочноземельные металлы
- ### Переходные 
- ### Постпереходные
- ### Металлоиды
- ### Неметаллы
- ### Галогены
- ### Благородные газы
- ### Лантаноиды
- ### Актиноиды
- ### С неизвестными свойствами

============================================================
ФАЙЛ: .\Tabletable\Проект\Данные.md
============================================================

- ## [[Файлы]]
- ## [[Структура данных]]
  

============================================================
ФАЙЛ: .\Tabletable\Проект\Модули.md
============================================================

- [[Таблица Растворимости]]
- [[Калькулятор]]
- [[Уравниватель]]
- [[Фильтры]]

============================================================
ФАЙЛ: .\Tabletable\Проект\Оптимизация.md
============================================================

- [[Для мобильных телефонов]]
- [[Для больших экранов]]
- [[Для режим обоев]]

============================================================
ФАЙЛ: .\Tabletable\Проект\Приложение.md
============================================================

- [[electron для windows]]
- [[electron для linux]]
- [[pwa]]

============================================================
ФАЙЛ: .\Tabletable\Проект\Секции элемента.md
============================================================

### Базовое
- Масса
- Период
- Группа
- Блок
- Категория
- Электронная конфигурация
- Электроотрицательность
---
### Физические свойства
- Плотность 
- Температура плавления
- Температура кипения
- Состояние (20°C) 
- Цвет
---
### Химические свойства
 - Год открытия элемента
 - Кто открыл элемент
 - Год открытия аллотропной формы
 - Кто открыл аллотропную форму
 - Происхождение названия
 - Области применения
 ---
### Интересные факты
 - Факты об элементе
 - Факты об аллотропной форме

============================================================
ФАЙЛ: .\Tabletable\Проект\Структура данных.md
============================================================

## elements.js:
- ### const elementsData:
	- ``` Js
	  "B": {
        atomicNumber: "",
        name: "",
        atomicMass: "",
        period: "",
        group: "",
        block: "",
        category: "",
        electronConfig: "",
        valenceStates: "",
        electronegativity: "",
        density: "",
        meltingPoint: "",
        boilingPoint: "",
        state: "",
        color: "",
        discoveryYear: "",
        discoverer: "",
        nameOrigin: "",
        applications: "",
        facts: "",
        allotropes: {
            amorphous: {
                name: "",
                density: "",
                color: "",
                structure: "",
                alloDiscoveryYear: "",
                alloDiscoverer: "",
                alloFacts: ""
            },
        },
        extraAllotropes: {
            alphaRhombohedral: {
                name: "",
                density: "",
                color: "",
                structure: "",
                properties: "",
                alloDiscoveryYear: "",
                alloDiscoverer: "",
                alloFacts: ""
            },
        }
    },

============================================================
ФАЙЛ: .\Tabletable\Проект\Структура таблицы Менделеева.md
============================================================

- Сетка: **grid 18×7**
- Колонки = **группы 1–18**
- Строки = **периоды 1–7**
- Элемент ставится по **(group, period)**
- Пустые клетки допустимы (ранние периоды)
---
## Лантаноиды / актиноиды
- Рисуются **двумя отдельными строками снизу**
- Лантаноиды: **57–71** (6 период)
- Актиноиды: **89–103** (7 период)
---
## На мобильных
- **горизонтальный скролл**


============================================================
ФАЙЛ: .\Tabletable\Проект\Таблица Менделеева.md
============================================================

- ## [[Структура таблицы Менделеева]]
---
- ## [[Элементы]]
---
- ## [[Данные]]

============================================================
ФАЙЛ: .\Tabletable\Проект\Файлы.md
============================================================

- ## elements.js - база данных об элементах
- ## index.html - подключение базы данных к сайту
- ## modal.js - для интеграции данных в модальное окно


============================================================
ФАЙЛ: .\Tabletable\Проект\Экспорт в PDF.md
============================================================

- ## Использование LaTeX
- ## Скрипты для автоматической генерации .tex в .pdf
- ## Загрузка PDF файла по кнопке
- 

============================================================
ФАЙЛ: .\Tabletable\Проект\Элементы.md
============================================================

- ### [[Группы]]
---
- ## [[Секции элемента]]
---
- ## [[Аллотропия]]
---
- ## [[Экспорт в PDF]]




--
